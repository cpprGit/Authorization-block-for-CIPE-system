src / index.tsx;
import {Button, ButtonGroup, Divider, Icon, Intent, Tab, Tabs} from '@blueprintjs/core';
import {FC, useCallback, useEffect, useMemo, useRef, useState} from 'react';
import ReactDOM from 'react-dom';
import {useSelector} from 'react-redux';
import {Link} from 'react-router-dom';
import {State} from 'src/store/reducers';
import {ChatState} from 'src/store/reducers/chats.reducer';
import {AsyncStatus, AttributeRef, AttributesByUserRole, ProfileType, ProjectRequestStatus, Stage, Usage, UserAction, UserRole} from 'src/types';
import {ChatHistory} from 'src/ui/blocks/chat-history/chat-history';
import 'src/ui/blocks/chat-info/chat-info.styl';
import {ChatUsers} from 'src/ui/blocks/chat-users/chat-users';
import {CommentView} from 'src/ui/blocks/comment-view/comment-view';
import {FormCard2} from 'src/ui/blocks/form-card/form-card';
import {FormInput} from 'src/ui/blocks/form-input/form-input';
import {HomePageParagraph} from 'src/ui/blocks/home-page-paragraph/home-page-paragraph';
import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
import {ProfileList} from 'src/ui/blocks/profile-list/profile-list';
import {
    ProjectApplicationCard,
    ProjectApplicationOwnerCard,
    ProjectApplicationOwnerCard2,
    ProjectApplicationOwnerCard3,
} from 'src/ui/blocks/project-application-card/project-application-card';
import {StageView} from 'src/ui/blocks/stage-view/stage-view';
import {TreeItem} from 'src/ui/blocks/tree-item/tree-item';
import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
import {DEFAULT_ATTRIBUTE_ID, DEFAULT_FORM_ID} from 'ui/utils/constants';
import './home.styl';
import './index.styl';
import './profile-lists.styl';
import './success-view.styl';

import {App} from './ui/app';

ReactDOM.render(<App / >, document.getElementById('root'));

src / ui / blocks / profile - lists / profile - lists.tsx;

const SimpleCard: FC<{ name: string, link: string }> = ({name, link}) => (
    <Link to = {link}
className = 'profile-lists__link' > {name} < /Link>;
)
;

type ProfileListDescriber = {
    title: string,
    path: string,
    component: FC<any>,
    userRoles?: UserRole[],
};

const LISTS: { [k in ProfileType]: ProfileListDescriber[] } = {
    [ProfileType.User]: [
        {
            title: 'Посты',
            path: '',
            component: CommentView,
        },
        {
            title: 'Активности',
            path: 'getAllUsersActivities',
            component: SimpleCard,
        },
        {
            title: 'Проекты',
            path: 'getAllStudentsProjects',
            component: SimpleCard,
            userRoles: [UserRole.Student],
        },
        {
            title: 'Менторы',
            path: 'getAllStudentMentors',
            component: SimpleCard,
            userRoles: [UserRole.Student],
        },
        {
            title: 'Заявки на проекты',
            path: 'getAllStudentsProjectApplications',
            component: ProjectApplicationOwnerCard,
            userRoles: [UserRole.Student],
        },
        {
            title: 'Проекты',
            path: 'getAllUsersProjects',
            component: SimpleCard,
            userRoles: [UserRole.Mentor, UserRole.Representative, UserRole.Manager, UserRole.Supervisor],
        },
        {
            title: 'Менти',
            path: 'getAllMentorMenties',
            component: SimpleCard,
            userRoles: [UserRole.Mentor],
        },
        {
            title: 'Заявки на проекты',
            path: 'getAllUsersProjectRequests',
            component: ProjectApplicationOwnerCard3,
            userRoles: [UserRole.Mentor, UserRole.Representative, UserRole.Manager, UserRole.Supervisor],
        },
        {
            title: 'Опросы',
            path: 'getAllUsersQuestionnaires',
            component: FormCard2,
        },
    ],
    [ProfileType.Organisation]: [
        {
            title: 'Посты',
            path: '',
            component: CommentView,
        },
        {
            title: 'Структура',
            path: 'getOrganisationStructure',
            component: TreeItem,
        },
        {
            title: 'Сотрудники',
            path: 'getOrganisationMembers',
            component: SimpleCard,
        },
    ],
    [ProfileType.Activity]: [
        {
            title: 'Этапы',
            path: '',
            component: StageView,
        },
        {
            title: 'Материалы',
            path: 'getAllPosts',
            component: CommentView,
        },
        {
            title: 'Выбор проектов',
            path: 'getAllActivitiesProjects',
            component: ProjectApplicationOwnerCard2,
        },
    ],
    [ProfileType.Project]: [
        {
            title: 'Этапы',
            path: '',
            component: StageView,
        },
        {
            title: 'Материалы',
            path: 'getAllPosts',
            component: CommentView,
        },
        {
            title: 'Заявки студентов',
            path: 'getAllProjectsApplications',
            component: ProjectApplicationCard,
        },
    ],
    [ProfileType.ProjectRequest]: [
        {
            title: 'Комментарии',
            path: '',
            component: CommentView,
        },
    ],
};

type Props = {
    schemaContentId: string;
    profileType: ProfileType;
    id: string;
    // Или массив постов
    firstList: Stage[];
    info: any;
    setInfo: (info: any) => void;
    modifyAllowed: boolean;
}
export const ProfileLists: FC<Props> = ({schemaContentId, profileType, id, firstList, info, setInfo, modifyAllowed}) => {
    const cppwApi = useCppwApiContext();

    const {userId} = useSelector((state: State) => state.user.isAuthed ? state.user : {role: UserRole.Initial, userId: ''});

    const commentRef = useRef<AttributeRef>(null);
    const fileRef = useRef<{ value: { id: string, name: string, type: 'file' } | null }>(null);
    const fileClearStateRef = useRef<() => void>(() => {});

    const [selectedTabId, setSelectedTabId] = useState(0);
    const validators = useMemo(() => [], []);
    const isPost = useMemo(() => (modifyAllowed && ['Материалы', 'Комментарии', 'Посты'].includes(LISTS[profileType][selectedTabId].title)),
                           [modifyAllowed, profileType, selectedTabId]);
    const [lists, setLists] = useState(LISTS[profileType].map(({path, component}, index) => ({
        status: index === 0 ? AsyncStatus.Success : AsyncStatus.Initial,
        items: index === 0 ? firstList : [],
        component,
        path: `${path}`,
        profileId: isPost ? schemaContentId : id,
    })));
    const onChangeTab = useCallback((tabId: number) => setSelectedTabId(tabId), [setSelectedTabId]);
    const editCurrentList = useCallback(({status, items}) => {
        const newLists = lists.map((list, index) => {
            if (index === selectedTabId) {
                return {...list, status, items};
            }
            return list;
        });
        setLists(newLists);
    }, [lists, selectedTabId]);
    const comment = useCallback((userAction, id) => {
        editCurrentList({
                            status: AsyncStatus.Success,
                            items: [...lists[selectedTabId].items,
                                {
                                    id,
                                    // TODO Присылать в токене имя
                                    userName: 'Руководитель центра',
                                    userLink: `/user/${userId}`,
                                    userAction,
                                    text: commentRef.current
                                          ? commentRef.current.value
                                          : '',
                                    file: fileRef.current
                                          ? fileRef.current.value
                                          : null,
                                }],
                        });
        if (commentRef.current) {
            commentRef.current.value = '';
        }
        if (fileRef.current) {
            // @ts-ignore
            fileRef.current = null;
            fileClearStateRef.current();
        }
    }, [userId, editCurrentList, selectedTabId, lists]);
    const onAccept = useCallback(() => {
                                     cppwApi && cppwApi.addProjectRequestComment(id,
                                                                                 Intent.PRIMARY,
                                                                                 () => {
                                                                                     setInfo(ProjectRequestStatus.Accepted);
                                                                                     if (!commentRef.current || !commentRef.current.value) {
                                                                                         return;
                                                                                     }
                                                                                     cppwApi && cppwApi.addPost(schemaContentId,
                                                                                                                UserAction.Approve,
                                                                                                                commentRef.current
                                                                                                                ? commentRef.current.value
                                                                                                                : '',
                                                                                                                fileRef.current
                                                                                                                ? fileRef.current.value
                                                                                                                : null,
                                                                                                                (id) => {
                                                                                                                    comment(UserAction.Approve, id);
                                                                                                                });
                                                                                 });
                                 },
                                 [schemaContentId, cppwApi, id, comment, setInfo]);
    const onReject = useCallback(() => {
                                     cppwApi && cppwApi.addProjectRequestComment(id,
                                                                                 Intent.DANGER,
                                                                                 () => {
                                                                                     setInfo(ProjectRequestStatus.Rejected);
                                                                                     if (!commentRef.current || !commentRef.current.value) {
                                                                                         return;
                                                                                     }
                                                                                     cppwApi && cppwApi.addPost(schemaContentId,
                                                                                                                UserAction.Reject,
                                                                                                                commentRef.current
                                                                                                                ? commentRef.current.value
                                                                                                                : '',
                                                                                                                fileRef.current
                                                                                                                ? fileRef.current.value
                                                                                                                : null,
                                                                                                                (id) => {
                                                                                                                    comment(UserAction.Reject, id);
                                                                                                                });
                                                                                 });
                                 },
                                 [schemaContentId, cppwApi, id, comment, setInfo]);
    const onComment = useCallback(() => {
        if (!commentRef.current || !commentRef.current.value) {
            return;
        }
        cppwApi && cppwApi.addPost(schemaContentId,
                                   UserAction.Comment,
                                   commentRef.current ? commentRef.current.value : '',
                                   fileRef.current ? fileRef.current.value : null,
                                   (id) => {
                                       comment(UserAction.Comment, id);
                                   });
    }, [schemaContentId, cppwApi, comment]);

    const setCommentRef = useCallback((val) => {commentRef.current = val;}, []);
    const setFileRef = useCallback((val) => {
        // @ts-ignore
        fileRef.current = val;
    }, []);
    const setFileClearStateRef = useCallback((val) => {
        fileClearStateRef.current = val;
    }, []);

    // Обновим списки при переходе в другой профиль.
    useEffect(() => {
        setLists(LISTS[profileType].map(({path, component}: ProfileListDescriber, index) => ({
            status: index === 0 ? AsyncStatus.Success : AsyncStatus.Initial,
            items: index === 0 ? firstList : [],
            component,
            path,
            profileId: isPost ? schemaContentId : id,
        })));
    }, [schemaContentId, isPost, profileType, firstList, id]);

    return (
        <>
            <Divider / >
        <Tabs id = 'profile-tabs'
    className = 'profile__navbar';
    selectedTabId = {selectedTabId};
    onChange = {onChangeTab} >
    {
        LISTS[profileType] && LISTS[profileType].map(({title, userRoles}: ProfileListDescriber, index: number) => {
            if (profileType === ProfileType.User && info && userRoles) {
                if (!userRoles.includes(info)) {
                    return null;
                }
            }
            return <Tab key = {index};
            id = {index};
            title = {title};
            />;;
        }),
    }
                             < /Tabs>
                             < Divider / >
    {
        isPost && <div
                                 className = 'profile-lists__comments' >
                                             <FormInput title = '';
    key = {'comment'};
    name = {'net'};
    id = {'net-name'};
    mandatory = {false};
    validators = {validators};
    placeholder = {ProfileType.ProjectRequest === profileType ? 'Комментировать...' : 'Написать...'};
    usage = {Usage.LongText};
    inputRef = {setCommentRef};
    formIndex = { - 1;
}
    index = { - 1;
}
    />
    < FormInput;
    key = {'filik'};
    title = '';
    name = {'file'};
    id = {'filik'};
    mandatory = {false};
    validators = {validators};
    usage = {Usage.File};
    inputRef = {setFileRef};
    formIndex = { - 1;
}
    index = { - 1;
}
    placeholder = 'Нажмите для выбора файла...';
    clearRef = {setFileClearStateRef};
    />
    < ButtonGroup >
    <Button text = {ProfileType.ProjectRequest === profileType ? 'Комментировать' : 'Написать'};
    onClick = {onComment};
    />;
    {
        ProfileType.ProjectRequest === profileType && info !== ProjectRequestStatus.Accepted && <Button text = 'Утвердить';
        intent = {Intent.PRIMARY};
        onClick = {onAccept};
        />};
        {
            ProfileType.ProjectRequest === profileType && info !== ProjectRequestStatus.Accepted && <Button text = 'Отклонить';
            intent = {Intent.DANGER};
            onClick = {onReject};
            />}
            < /ButtonGroup>

            < /div>;
        }
        <ProfileList {...lists[selectedTabId]};
        editCurrentList = {editCurrentList};
        className = {isPost ? 'profile-lists__reversed-list' : ''};
        />
        < />;
    )
    ;
};
src / ui / blocks / success - view / success - view.tsx;

type Props = {
    title: string;
    onRetry?: () => void;
    size?: 's';
}

export const SuccessView: FC<Props> = ({title, onRetry, size}) => (
    <div className = {`success-view ${size ? `_size-${size}` : ''}`
}
onClick = {onRetry} >
                    <div className = 'success-view__block' >
                                     <Icon className = 'success-view__icon';
icon = 'tick';
intent = {Intent.SUCCESS};
/>;
{
    title && <div className = 'success-view__title' > {title} < /div>};
    {
        onRetry && <div className = 'success-view__subtitle' > Заполнить;
        повторно. < /div>}
        < /div>
        < /div>;
    )
;
src / ui / blocks / home / home.tsx;

const info = [
    {
        title: 'Центр практик и проектной работы',
        mode: 1,
        description: 'Центр организует сбор и представление проектов ИТ-компаний, собрания по проведению практик и стажировок, заключение договоров и соглашений о сотрудничестве с работодателями, а также методически поддерживает проведение практик и проектной работы на образовательных программах ФКН.\n',
    },
    {
        title: 'Наша главная цель',
        mode: 3,
        description: 'Построение плодотворного и дружественного сотрудничества с компаниями-работодателями!',
    },
    {
        src: 'cppr-main-image.jpg',
    },
    {
        title: 'В чем заключается наша задача?',
        mode: 3,
        description: 'Построить систему взаимодействия Факультета Компьютерных Наук с компаниями – работодателями в части, касающейся практик и проектной работы, а также развить иные формы сотрудничества с работодателями.',
    },
    {
        title: 'Как мы поможем компаниям взаимодействовать со студентами?',
        mode: 3,
        description: 'Мы занимаемся организационной и методической поддержкой в подготовке и проведении практик и проектной работы на образовательных программах факультета, привлечение работников факультета к сотрудничеству с работодателями.',
    },
    {
        title: '',
        mode: 3,
        description: 'Центр практик и проектной работы создан в декабре 2018 г. как структурное подразделение факультета компьютерных наук Национального исследовательского университета «Высшая школа экономики».',
    },
];

export const Home: FC = () => {
    return <>
               {
                   info.map((elem, ind) => {
                       if ('src' in elem) {
                           return <img key = {ind};
                           className = 'home__img';
                           alt = 'Люди, пожимающие руки.';
                           src = {elem.src};
                           />;;
                       }
                       return <HomePageParagraph key = {ind};
                       {...
                           elem;
                       }
                       />;;
                   }),
               }
           < />;;
};
src / ui / blocks / chat - info / chat - info.tsx;

type Props = {
    status: AsyncStatus;
    chat: ChatState;
    attributes: AttributesByUserRole;
    chatIndex: number;
    isEditing: boolean;
}

export const ChatInfo: FC<Props> = ({status, chat, attributes, chatIndex, isEditing}) => {
    const {status: historyStatus = AsyncStatus.Initial, logs = []} = chat?.history ? chat.history : {};
    const [selectedTabId, setSelectedTabId] = useState(0);
    const onChangeTab = useCallback((tabId: number) => setSelectedTabId(tabId), [setSelectedTabId]);
    const mailTo = useMemo(() => chat?.users.map(({email}) => email).join(','), [chat]);

    useEffect(() => {setSelectedTabId(0);}, [isEditing]);

    return <LoadableView status = {status};
    spinnerClassName = 'spinner-full-height' >
    {chat && <Tabs id = 'chat-info__tabs';
    className = 'chat-info__tabs';
    selectedTabId = {selectedTabId};
    onChange = {onChangeTab};
    large = {true} >
                   <Tab key = {0};
    id = {0};
    title = 'Участники' / >
            {!;
    isEditing && <Tab key = {1};
    id = {1};
    title = 'История' / >
}
    </Tabs>};
    {
        selectedTabId === 0 && chat && <ChatUsers users = {chat && chat.users;
    }
        id = {chat && chat.id;
    }
        chatIndex = {chatIndex};
        title = {chat && chat.name;
    }
        backup = {chat && chat.backup;
    }
        isEditing = {isEditing};
        attributes = {attributes};
        />};

        {
            selectedTabId === 1 && chat && <ChatHistory chatId = {chat.id};
            chatIndex = {chatIndex};
            status = {historyStatus};
            logs = {logs};
            mailTo = {mailTo};
            />}
            < /LoadableView>;;
        }
        ;
        src / ui / blocks / form - stats / form - stats.tsx;
        import React, {FC, useCallback, useEffect, useMemo} from 'react';
        import {AsyncStatus, Attribute, Content, SearchType, Usage} from 'src/types';
        import {Layout} from 'src/ui/blocks/layout/layout';
        import {SearchColumn} from 'src/ui/blocks/search-column/search-column';
        import {SearchResults} from 'src/ui/blocks/search-results/search-results';
        import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

        type Props = {
            formId: string;
            formIndex: number;
            status: AsyncStatus;
            records: Content[];
            fields: Attribute[];
        }

        export const FormStats: FC<Props> = ({status, records, fields, formId, formIndex}) => {
            const cppwApi = useCppwApiContext();
            const realFields = useMemo(() => [
                                           {
                                               id: '1',
                                               name: 'fillBy',
                                               realName: 'fillBy',
                                               usage: Usage.ShortText,
                                               title: 'Пользователь',
                                               mandatory: true,
                                               isAdded: true,
                                               validators: [],
                                           },
                                           {
                                               id: '2',
                                               name: 'isFilled',
                                               realName: 'isFilled',
                                               usage: Usage.ShortText,
                                               title: 'Статус',
                                               mandatory: true,
                                               isAdded: true,
                                               validators: [],
                                           }, ...fields],
                                       [fields]);
            const handleSearch = useCallback((filter: Attribute[]) => {
                cppwApi && cppwApi.getFormStats(formIndex, formId, filter);
            }, [cppwApi, formIndex, formId]);
            useEffect(() => {
                if (status === AsyncStatus.Initial) {
                    cppwApi && cppwApi.getFormStats(formIndex, formId);
                }
                // Проставлять в зависимости всё остальное не стоит. Ничего происходить не будет, только лишний вызов.
            }, [cppwApi]);

            return <Layout leftComponent = { < SearchColumn;
            status = {AsyncStatus.Success};
            fields = {realFields};
            isColumnsUpdateDisabled = {true};
            handleSearch = {handleSearch};
            searchType = {SearchType.Questionnaire};
            />};
            rightComponent = { < SearchResults;
            status = {status};
            records = {records};
            fields = {realFields};
            searchType = {SearchType.Questionnaire};
            />}/ >;

        }
            ;
            src / ui / blocks / footer / footer.tsx;
            import {Alignment, Button, Navbar} from '@blueprintjs/core';

            import React, {FC, memo} from 'react';
            import {Link} from 'react-router-dom';
            import './footer.styl';

            export const Footer: FC = memo(() => (
                <Navbar>
                    <Navbar.Group align = {Alignment.LEFT} >
                                                           <Navbar.Heading className = 'footer__long-title' >© {
                (new Date()).getFullYear();
            }
            ЦППР;
            ФКН;
            НИУ;
            ВШЭ < /Navbar.Heading>
            < Navbar.Heading;
            className = 'footer__short-title' >© {
                (new Date()).getFullYear();
            }
            ЦППР < /Navbar.Heading>
            < /Navbar.Group>

            < Navbar.Group;
            align = {Alignment.RIGHT} >
                                      <Link className = 'header__link';
            to = '/contacts' > <Button className = 'bp3-minimal';
            text = 'Контакты' / > </Link>
                   < Link;
            className = 'header__link';
            to = '/help' > <Button className = 'bp3-minimal';
            text = 'Помощь' / > </Link>
                   < /Navbar.Group>
                   < /Navbar>;
        ))
            ;
            src / ui / blocks / chat - history / chat - history.tsx;
            import {Button, ButtonGroup, Card, H3, Intent} from '@blueprintjs/core';
            import React, {FC, useCallback, useEffect, useMemo, useRef, useState} from 'react';
            import {HistoryLog} from 'src/store/reducers/chats.reducer';
            import {AsyncStatus, Usage} from 'src/types';
            import {FormCardLite} from 'src/ui/blocks/form-card/form-card';
            import {FormInput} from 'src/ui/blocks/form-input/form-input';
            import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
            import {Search} from 'src/ui/blocks/search/search';
            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
            import './chat-history.styl';

            type Props = {
                chatId: string;
                chatIndex: number;
                logs: HistoryLog[];
                status: AsyncStatus;
                mailTo: string;
            }
            export const ChatHistory: FC<Props> = ({chatId, chatIndex, status, logs, mailTo}) => {
                const cppwApi = useCppwApiContext();
                const [isQuestionnaireSenderOpen, setIsQuestionnaireSenderOpen] = useState(false);
                const [isNotificationSenderOpen, setIsNotificationSenderOpen] = useState(false);
                const onNotificationSenderOpen = useCallback(() => {setIsNotificationSenderOpen(true);}, [setIsNotificationSenderOpen]);
                const onNotificationSenderClose = useCallback((text: string) => {
                    if (text) {
                        cppwApi && cppwApi.sendNotification(chatId,
                                                            chatIndex,
                                                            text,
                                                            () => {setIsNotificationSenderOpen(false);});
                    } else {
                        setIsNotificationSenderOpen(false);
                    }
                }, [chatIndex, chatId, cppwApi, setIsNotificationSenderOpen]);
                const onQuestionnaireSenderOpen = useCallback(() => {setIsQuestionnaireSenderOpen(true);}, [setIsQuestionnaireSenderOpen]);
                const onQuestionnaireSenderClose = useCallback(() => {setIsQuestionnaireSenderOpen(false);}, [setIsQuestionnaireSenderOpen]);
                const onCopyText = useCallback(() => {
                    const copytext = document.createElement('input');
                    copytext.value = mailTo;
                    document.body.appendChild(copytext);
                    copytext.select();
                    document.execCommand('copy');
                    document.body.removeChild(copytext);
                }, [mailTo]);

                useEffect(() => {
                    if (status === AsyncStatus.Initial) {
                        cppwApi && cppwApi.requestChatsHistoryLog(chatId, chatIndex);
                    }
                }, [status, cppwApi, chatId, chatIndex]);
                return <>
                    <ButtonGroup className = 'chat-history__buttons' >
                {
                    mailTo && <Button onClick = {onCopyText} > <a href = {`mailto:${mailTo}`;
            }>
                Написать;
                сообщение < /a></;
                Button >
            }
                <Button text = 'Отправить нотификацию';
                onClick = {onNotificationSenderOpen};
                />
                < Button;
                text = 'Отправить опрос';
                onClick = {onQuestionnaireSenderOpen};
                />
                < /ButtonGroup>
                < LoadableView;
                status = {status} >
                {
                    isQuestionnaireSenderOpen && <QuestionnaireSender chatId = {chatId};
                onClose = {onQuestionnaireSenderClose};
                chatIndex = {chatIndex};
                />;
            }
                {

                    isNotificationSenderOpen && <NotificationSender onClose = {onNotificationSenderClose};
                    />;
                }
                <div className = 'chat-history__logs' >
                    {
                        logs.map((log) => <HistoryLogView key = {log.id}
                {...
                    log;
                }
                />);
            }
                </div>
                < /LoadableView>
                < />;;
            };

            const HistoryLogView: FC<HistoryLog> = ({date, link, title, name}) => {
                return <div className = 'history-log' >
                                        <span className = 'history-log__date' > {date} < /span>
                                                          < span;
                className = 'history-log__title' > {title};
                {
                    link && name && <a className = 'history-log__link';
                    href = {link};
                    target = '_blank' > {name} < /a>}</s;
                    pan >
                    </div>;;
                }
                ;

                type QuestionnaireSenderProps = {
                    chatId: string;
                    chatIndex: number;
                    onClose: () => void;
                }
                const QuestionnaireSender: FC<QuestionnaireSenderProps> = ({chatId, chatIndex, onClose}) => {
                    const cppwApi = useCppwApiContext();
                    const [status, setStatus] = useState(AsyncStatus.Initial);
                    const [forms, setForms] = useState<{ id: string; name: string }[]>([]);
                    const items = useMemo(() => (forms.map(({id, name}) => ({
                        name,
                        onClick: () => {cppwApi && cppwApi.sendForm(chatIndex, chatId, id, name);},
                    }))), [forms, cppwApi, chatIndex, chatId]);

                    useEffect(() => {
                        if (status === AsyncStatus.Initial) {
                            cppwApi && cppwApi.getAllQuestionnaires(
                                () => setStatus(AsyncStatus.Pending),
                                (result) => {
                                    setStatus(AsyncStatus.Success);
                                    setForms(result);
                                },
                                () => setStatus(AsyncStatus.Error));
                        }
                    });

                    return (
                        <Card className = 'questionnaire_sender' >
                                          <H3 className = 'form-layout__title' > Выберите
                    опрос;
                    для;
                    отправки < /H3>
                    < div;
                    className = 'questionnaire_sender__scrollable' >
                                <LoadableView status = {status} >
                                                                <Search component = {FormCardLite};
                    searchPropertyName = 'name';
                    items = {items};
                    className = 'side-margin-search' / >
                                </LoadableView>
                                < /div>
                                < Button;
                    text = 'Готово';
                    intent = {Intent.PRIMARY};
                    onClick = {onClose};
                    />
                    < /Card>;
                )
                    ;
                };

                type NotificationSenderProps = {
                    onClose: (text: string) => void;
                };
                const NotificationSender: FC<NotificationSenderProps> = ({onClose}) => {
                    const ref = useRef<HTMLInputElement | null>(null);
                    const setRef = useCallback((val) => {ref.current = val; }, [ref]);
                    const onClick = useCallback(() => onClose(ref.current ? ref.current.value : ''), [onClose, ref]);

                    return (
                        <Card className = 'questionnaire_sender' >
                                          <FormInput id = {'NotificationSender'}
                    name = {'NotificationSender'};
                    usage = {Usage.LongText};
                    title = 'Введите текст нотификации';
                    mandatory = {true};
                    validators = {[]};
                    inputRef = {setRef};
                    formIndex = { - 1;
                }
                    index = { - 1;
                }
                    />
                    < Button;
                    text = 'Готово';
                    intent = {Intent.PRIMARY};
                    onClick = {onClick};
                    />
                    < /Card>;
                )
                    ;
                };
                src / ui / blocks / search - results / search - results.tsx;
                import React, {FC, memo, useCallback, useEffect, useMemo, useState} from 'react';
                import {useSelector} from 'react-redux';
                import {State} from 'src/store/reducers';
                import {AsyncStatus, Attribute, ProfileOrSearchItem, SearchType, Usage, UserRole} from 'src/types';
                import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                import {SEARCH_TYPE_TO_BUTTONS_MAP, SearchButtons} from 'src/ui/blocks/search-buttons/search-buttons';
                import {Table} from 'src/ui/blocks/table/table';
                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                import {getFormattedStringValue, getLinkOrText, getText} from 'src/ui/utils/get-formatted-attribute-value';
                import {reorderArray} from 'src/ui/utils/reoder-array';

                type Props = {
                    searchType: SearchType;
                    status: AsyncStatus;
                    fields: Attribute[];
                    records: ProfileOrSearchItem[];
                    setMark?: (mark: string, recordIndex: number, fieldName: string) => void;
                    profileId?: string;
                };
                export const SearchResults: FC<Props> = memo(({searchType, status, fields, records, setMark, profileId}) => {
                    const cppwApi = useCppwApiContext();
                    const {role: userRole} = useSelector((state: State) => state.user.isAuthed ? state.user : {
                        role: undefined,
                    });
                    const [innerFields, setInnerFields] = useState(fields.filter(({isAdded}) => isAdded).map((field, index) => ({
                        ...field,
                        width: (180 + index * 10),
                    })));
                    const [recordsState, setRecordsState] = useState(records);

                    const hasButtons = !!SEARCH_TYPE_TO_BUTTONS_MAP[searchType]?.length && userRole && [UserRole.Manager,
                                                                                                        UserRole.Supervisor].includes(userRole);
                    const columnWidths = useMemo(() => [recordsState.length.toString().length * 10 + 10, ...(innerFields.map(({width}) => width))],
                                                 [recordsState.length, innerFields]);

                    const getCellElement = useCallback((col: number, row: number) => {
                        const field = innerFields[col - 1];
                        const {realName, name, title} = field;

                        if (!row) {
                            return title;
                        }
                        if (field.modifyAllowed && realName && profileId) {
                            const callback = (e: any) => {
                                e.stopPropagation();
                            };
                            const itemInfo = recordsState[row - 1];
                            const [, stageId, gradeType] = realName.split(':');
                            return <input className = {'table__input'};
                            type = 'text';
                            defaultValue = {getText(itemInfo, searchType, realName || name, field.usage;
                        )
                        }
                            onKeyUp = {(e);
                        =>
                            {
                                if (e.keyCode === 13) {
                                    // @ts-ignore
                                    cppwApi && cppwApi.changeMark(e.target && e.target.value,
                                                                  profileId,
                                                                  itemInfo.student.id,
                                                                  stageId,
                                                                  gradeType, (mark) => {setMark && setMark(mark, row - 1, realName);});
                                }
                            }
                        }
                            onMouseUp = {callback};
                            onMouseDown = {callback};
                            onClick = {callback};
                            />;;
                        }

                        return getLinkOrText(
                            recordsState[row - 1],
                            searchType,
                            realName || name,
                            field.usage,
                        );
                    }, [profileId, cppwApi, innerFields, recordsState, searchType, setMark]);
                    const getCellData = useCallback((col, row) => {
                        if (!row) {
                            const field = innerFields[col - 1];
                            const {title} = field;
                            return title;
                        }
                        const item = recordsState[row - 1];
                        const field = innerFields[col - 1];
                        const {realName} = field;
                        if (realName) {
                            return getFormattedStringValue(item[realName], field.usage);
                        }
                        return getFormattedStringValue(item.content[field.name], field.usage);
                    }, [recordsState, innerFields]);
                    const handleColumnsReordered = useCallback((oldIndex: number, newIndex: number) => {
                        if (oldIndex === newIndex) {
                            return;
                        }
                        const nextFields = reorderArray(innerFields, oldIndex - 1, newIndex - 1, 1);
                        if (nextFields) {
                            setInnerFields(nextFields);
                        }
                    }, [innerFields]);
                    const handleColumnWidthChange = useCallback((columnIndex: number, newWidth: number) => {
                        setInnerFields(innerFields.map((field, index) => {
                            if (index === columnIndex) {
                                field.width = newWidth;
                            }
                            return field;
                        }));
                    }, [innerFields]);
                    const sortRecords = useCallback((column, ascending) => {
                        setRecordsState(recordsState.sort((a, b) => {
                            const field = innerFields[column - 1];
                            const [aVal, bVal] = [a, b].map(x => x[field.realName || '']).map((x) => (x?.name || x));
                            if (aVal === bVal) {
                                return 0;
                            }
                            if (field.usage === Usage.Number) {
                                const isBigger = Number(aVal) > Number(bVal);
                                return ascending === isBigger ? 1 : -1;
                            }

                            const isBigger = aVal > bVal;
                            return ascending === isBigger ? 1 : -1;
                        }));
                    }, [recordsState, innerFields]);

                    useEffect(() => {
                        setRecordsState(records);
                    }, [records]);
                    useEffect(() => {
                        setInnerFields(fields.filter(({isAdded}) => isAdded).map((field, index) => ({...field, width: (180 + index * 10)})));
                    }, [fields]);

                    return <LoadableView status = {status};
                    spinnerClassName = 'spinner-full-height';
                    errorTitle = 'Ошибка загрузки результатов поиска';
                    errorSubtitle = 'Повторите попытку, нажав кнопку Найти' >
                                    <>
                                        <SearchButtons searchType = {searchType};
                    records = {recordsState};
                    fields = {fields};
                    />
                    < Table;
                    columnWidths = {columnWidths};
                    rowCount = {recordsState.length};
                    getCellData = {getCellData};
                    getCellElement = {getCellElement};
                    onColumnsReordered = {handleColumnsReordered};
                    onColumnWidthChange = {handleColumnWidthChange};
                    className = {hasButtons ? '_with-buttons' : ''};
                    onColumnSorted = {sortRecords};
                    />
                    < />
                    < /LoadableView>;;
                });
                src / ui / blocks / error - view / error - view.tsx;
                import {Icon, Intent} from '@blueprintjs/core';
                import React, {FC} from 'react';
                import './error-view.styl';

                type Props = {
                    title?: string;
                    subtitle?: string;
                    onRetry?: () => void;
                    size?: 's';
                }

                export const ErrorView: FC<Props> = ({title, subtitle, onRetry, size}) => (
                    <div className = {`error-view ${onRetry ? '_is-link' : ''} ${size ? `_size-${size}` : ''}`
            }
                onClick = {onRetry} >
                                    <div className = 'error-view__block' >
                                                     <Icon className = 'error-view__icon';
                icon = {onRetry ? 'refresh' : 'error'};
                intent = {Intent.DANGER};
                />
                < div;
                className = 'error-view__message' >
                {title && <div className = 'error-view__title' > {title} < /div>};
                {
                    subtitle && <div className = 'error-view__subtitle' > {subtitle} < /div>}
                                                 < /div>
                                                 < /div>
                                                 < /div>;
                )
                ;
                src / ui / blocks / empty / empty.tsx;
                import React, {FC} from 'react';

                export const Empty: FC = () => {
                    return <div></div>;;
                };
                src / ui / blocks / chat - user - card / chat - user - card.tsx;
                import {Icon, Intent} from '@blueprintjs/core';
                import React, {FC, useCallback} from 'react';
                import {Link} from 'react-router-dom';
                import {Attribute, ProfileOrSearchItem} from 'src/types';
                import './chat-user-card.styl';

                type SimpleProps = {
                    userName: string;
                    userId: string;
                    handleAdd?: () => void;
                    handleDelete?: () => void;
                    isAdded?: boolean;
                };

                export const SimpleChatUserCard: FC<SimpleProps> = ({userName, userId, isAdded, handleAdd, handleDelete}) => {
                    const onIconClick = useCallback(() => {
                        if (isAdded) {
                            handleDelete && handleDelete();
                        } else {
                            handleAdd && handleAdd();
                        }
                    }, [isAdded, handleAdd, handleDelete]);

                    return <div className = 'chat-user-card' >
                    {handleAdd && handleDelete && <Icon className = 'chat-user-card__icon';
                    icon = {isAdded ? 'small-tick' : 'small-plus'};
                    intent = {isAdded ? Intent.SUCCESS : Intent.DANGER};
                    onClick = {onIconClick};
                    />}
                    < div;
                    className = 'chat-user-card__texts' >
                                <Link className = 'chat-user-card__main';
                    to = {`/user/${userId}`;
                }>
                    {
                        userName;
                    }
                    </Link>
                    < /div>
                    < /div>;;
                }
                    ;
                    type Props = {
                        user: ProfileOrSearchItem;
                        attributes: Attribute[];
                        handleAdd?: () => void;
                        handleDelete?: () => void;
                        isAdded?: boolean;
                    };

                    export const ChatUserCard: FC<Props> = ({user, attributes, isAdded, handleAdd, handleDelete}) => {
                        const onIconClick = useCallback(() => {
                            if (isAdded) {
                                handleDelete && handleDelete();
                            } else {
                                handleAdd && handleAdd();
                            }
                        }, [isAdded, handleAdd, handleDelete]);

                        return <div className = 'chat-user-card' >
                        {handleAdd && handleDelete && <Icon className = 'chat-user-card__icon';
                        icon = {isAdded ? 'small-tick' : 'small-plus'};
                        intent = {isAdded ? Intent.SUCCESS : Intent.DANGER};
                        onClick = {onIconClick};
                        />}
                        < div;
                        className = 'chat-user-card__texts' >
                                    <Link className = 'chat-user-card__main';
                        to = {`/user/${user.id}`;
                    }>
                        {
                            user.name;
                        }
                        </Link>;
                        {
                            attributes.map(({realName, title}: Attribute) => realName !== 'name' && realName && <div
                                className = 'chat-user-card__minor' > {`${title}: ${user[realName]}`
                        }
                            </div>);
                        }
                        </div>
                        < /div>;;
                    }
                        ;
                        src / ui / blocks / form - card / form - card.tsx;
                        import {Icon, IconName, Intent, Position, Tooltip} from '@blueprintjs/core';
                        import {Color} from 'csstype';
                        import React, {FC, memo, useCallback, useEffect, useState} from 'react';
                        import {CppwApi} from 'src/api/api';
                        import {addNewUserForm, changeUserFormMode} from 'src/store/actions/user-forms.actions';
                        import {Attribute, AttributeValue, Content, Form, FormMode, FormType} from 'src/types';
                        import {FormLayout} from 'src/ui/blocks/form-layout/form-layout';
                        import {SuccessView} from 'src/ui/blocks/success-view/success-view';
                        import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                        import './form-card.styl';

                        type Props = {
                            form?: Form;
                            title?: string;
                            onClick: () => void;
                            isPlaceholder?: boolean;
                            index?: number;
                            isArchive?: boolean;
                            isActive?: boolean;
                            isEditing?: boolean;
                        }
                        const OPTIONS = [
                            {
                                name: 'Редактировать',
                                onClick: (form: Form, cppwApi?: CppwApi, index?: number) => {
                                    cppwApi && Number(index) > -1 && cppwApi.store.dispatch(changeUserFormMode(Number(index), FormMode.Edit));
                                },
                                forArchive: false,
                            },
                            {
                                name: 'Дублировать',
                                onClick: (form: Form, cppwApi?: CppwApi) => {
                                    if (cppwApi) {
                                        const {type, title, attributes, description, buttonName} = form;
                                        cppwApi.store.dispatch(addNewUserForm({
                                                                                  id: DEFAULT_FORM_ID,
                                                                                  title: `${title} (2)`,
                                                                                  type,
                                                                                  attributes,
                                                                                  description,
                                                                                  buttonName,
                                                                                  mode: FormMode.Edit,
                                                                              }));
                                    }
                                },
                                forArchive: false,
                            },
                            {
                                name: 'Сделать формой по умолчанию',
                                onClick: (form: Form, cppwApi?: CppwApi) => {
                                    cppwApi && cppwApi.updateDefaultForm(form);
                                },
                                forArchive: false,
                            },
                            {
                                name: 'Статистика',
                                onClick: (form: Form, cppwApi?: CppwApi, index?: number) => {
                                    cppwApi && index !== undefined && index > -1 && cppwApi.store.dispatch(changeUserFormMode(index, FormMode.Stats));
                                },
                                forArchive: false,
                            },
                            {
                                name: 'В архив',
                                onClick: (form: Form, cppwApi?: CppwApi, index?: number) => {
                                    if (cppwApi && index !== undefined) {
                                        cppwApi.addToArchive(index, form);
                                    }
                                },
                                forArchive: false,
                            },
                            {
                                name: 'В активные формы',
                                onClick: (form: Form, cppwApi?: CppwApi, index?: number) => {
                                    if (cppwApi && index !== undefined) {
                                        cppwApi.deleteFromArchive(index, form);
                                    }
                                },
                                forArchive: true,
                            },
                        ];

                        const FORM_TYPE_TO_NAME_MAP: { [k in FormType]: string } = {
                            [FormType.Help]: 'Помощь',
                            [FormType.StudentRegistration]: 'Регистрация студента',
                            [FormType.StudentProfileTemplate]: 'Профиль студента',
                            [FormType.UserRegistration]: 'Регистрация пользователя',
                            [FormType.UserProfileTemplate]: 'Профиль пользователя',
                            [FormType.OrgProfile]: 'Профиль организации',
                            [FormType.Questionnaire]: 'Опросник',
                            [FormType.ProjectRequest]: 'Создание заявки на проект',
                            [FormType.Activity]: 'Создание активности',

                            // Не должны появляться в списках но на всякий случай, чтоб ничего не поломалось.
                            [FormType.AttributeCreator]: 'Создание атрибута',
                            [FormType.Project]: 'Создание проекта',
                            [FormType.UserProfile]: 'Профиль пользователя',
                            [FormType.OrgProfileTemplate]: 'Профиль организации',
                            [FormType.StudentProfile]: 'Профиль студента',
                            [FormType.Initial]: '',
                        };
                        const FORM_TYPE_TO_ICON_MAP: { [k in FormType]: IconName } = {
                            [FormType.Help]: 'headset',
                            [FormType.StudentRegistration]: 'following',
                            [FormType.StudentProfileTemplate]: 'mugshot',
                            [FormType.UserRegistration]: 'following',
                            [FormType.UserProfileTemplate]: 'mugshot',
                            [FormType.OrgProfile]: 'people',
                            [FormType.Questionnaire]: 'property',
                            [FormType.ProjectRequest]: 'annotation',
                            [FormType.Activity]: 'globe-network',

                            // Не должны появляться в списках но на всякий случай, чтоб ничего не поломалось.
                            [FormType.AttributeCreator]: 'clipboard',
                            [FormType.Project]: 'clipboard',
                            [FormType.UserProfile]: 'clipboard',
                            [FormType.OrgProfileTemplate]: 'clipboard',
                            [FormType.StudentProfile]: 'clipboard',
                            [FormType.Initial]: 'clipboard',
                        };
                        const FORM_TYPE_TO_COLOR_MAP: { [k in FormType]: Color } = {
                            [FormType.Help]: '#106BA3',
                            [FormType.StudentRegistration]: '#0D8050',
                            [FormType.StudentProfileTemplate]: '#0D8050',
                            [FormType.UserRegistration]: '#BF7326',
                            [FormType.UserProfileTemplate]: '#BF7326',
                            [FormType.OrgProfile]: '#752F75',
                            [FormType.Questionnaire]: '#106BA3',
                            [FormType.ProjectRequest]: '#106BA3',
                            [FormType.Activity]: '#106BA3',

                            // Не должны появляться в списках но на всякий случай, чтоб ничего не поломалось.
                            [FormType.AttributeCreator]: '#106BA3',
                            [FormType.Project]: '#106BA3',
                            [FormType.UserProfile]: '#106BA3',
                            [FormType.OrgProfileTemplate]: '#106BA3',
                            [FormType.StudentProfile]: '#106BA3',
                            [FormType.Initial]: '#106BA3',
                        };

                        export const FormCard: FC<Props> = memo(({form, title, onClick, isPlaceholder, isArchive, isActive, isEditing, index}) => {
                            const cppwApi = useCppwApiContext();
                            const [isMenuOpen, setIsMenuOpen] = useState(false);
                            const onIconClick = useCallback(() => {
                                setIsMenuOpen(!isMenuOpen);
                            }, [isMenuOpen]);

                            useEffect(() => {
                                if (!isActive) {
                                    setIsMenuOpen(false);
                                }
                            }, [isActive]);

                            if (isPlaceholder) {
                                return (
                                    <div className = 'form-card _placeholder'
                                onClick = {onClick} >
                                                    <Icon icon = 'plus' / >
                                                                 </div>;
                            )
                                ;
                            }
                            return (
                                <>
                                    <div className = {`form-card ${isActive ? '_is-active' : ''} ${isEditing ? '_is-editing' : ''}`
                        }
                            onClick = {onClick} >
                            {form && FORM_TYPE_TO_ICON_MAP[form.type] && <Tooltip content = {FORM_TYPE_TO_NAME_MAP[form.type]};
                            position = {Position.BOTTOM} >
                                                         <Icon className = 'form-card__left-icon';
                            color = {FORM_TYPE_TO_COLOR_MAP[form.type]};
                            icon = {FORM_TYPE_TO_ICON_MAP[form.type]};
                            title = {form.type};
                            />
                            < /Tooltip>}
                            < div;
                            className = 'form-card__text' > {title} < /div>
                                        < Icon;
                            icon = 'chevron-down';
                            className = 'form-card__right-icon';
                            onClick = {onIconClick};
                            />
                            < /div>
                            < div;
                            className = {`form-card__menu ${isMenuOpen ? '_opened' : ''} ${isArchive ? '_is-archive' : ''}`;
                        }>
                            {
                                OPTIONS.map(({name, onClick, forArchive}) => {
                                    if (forArchive === undefined || forArchive === isArchive) {
                                        return <div key = {`${name} ${title}`;
                                    }
                                        className = 'form-card__menu-item';
                                        onClick = {();
                                    =>
                                        {
                                            onClick && form && onClick(form, cppwApi, index);
                                        }
                                    }>
                                        {
                                            name;
                                        }
                                        </div>;;
                                    }
                                    return null;
                                });
                            }
                            </div>
                            < />;
                        )
                            ;
                        });

                        type FormCardProps = {
                            id: string;
                            title: string;
                            type: FormType;
                            attributes: Attribute[];
                            mode: FormMode;
                            description?: string;
                            buttonName?: string;
                            content?: Content;
                        }
                        export const FormCard2: FC<FormCardProps> = memo(({id, title, type, attributes, mode, buttonName, content}) => {
                            const cppwApi = useCppwApiContext();
                            const [isMenuOpen, setIsMenuOpen] = useState(false);
                            const [isFilledSuccessfully, setIsFilledSuccessfully] = useState(false);
                            const [errors, setErrors] = useState();
                            const onClick = useCallback(() => {
                                if (!content) {
                                    setIsMenuOpen(!isMenuOpen);
                                }
                            }, [content, isMenuOpen]);
                            const onFormSubmit = useCallback((values: AttributeValue[], attributes: Attribute[]) => {

                                const content = attributes.reduce((res: { [k: string]: AttributeValue }, attribute: Attribute, index: number) => {
                                    res[attribute.name] = values[index];
                                    return res;
                                }, {});
                                cppwApi && cppwApi.submitQuestionnaire(id, JSON.stringify(content), () => {setIsFilledSuccessfully(true);});
                            }, [id, cppwApi]);

                            return (
                                <>
                                    <div className = {`form-card`
                        }
                            onClick = {onClick} >
                                {
                                                < Icon;
                            className = 'form-card__left-icon';
                            color = {FORM_TYPE_TO_COLOR_MAP[type]};
                            icon = {FORM_TYPE_TO_ICON_MAP[type]};
                            title = {type};
                            />;
                        }
                            <div className = 'form-card__text' > {title} < /div>
                                             < Icon;
                            icon = {content ? 'tick' : 'cross'};
                            intent = {content ? Intent.SUCCESS : Intent.DANGER};
                            className = 'form-card__right-icon' / >
                                        </div>;
                            {
                                isMenuOpen && !isFilledSuccessfully && <div className = {`form-card__men`;
                            }>
                                <FormLayout id = {id};
                                type = {type};
                                buttonName = {buttonName};
                                title = {title};
                                attributes = {attributes};
                                mode = {mode};
                                onSetError = {setErrors};
                                errors = {errors};
                                onFormSubmit = {onFormSubmit};
                                index = { - 1;
                            }
                                />
                                < /div>;
                            }
                            {
                                isMenuOpen && isFilledSuccessfully &&
                                <SuccessView title = 'Опрос пройден! Спасибо!' / >
                            }
                            </>;
                        )
                            ;
                        });

                        type LiteProps = {
                            name: string;
                            onClick: () => void;
                        }
                        export const FormCardLite: FC<LiteProps> = memo(({name, onClick}) => (<div className = {`form-card`
                    }
                        onClick = {onClick} >
                            {
                                FORM_TYPE_TO_ICON_MAP[FormType.Questionnaire] && <Tooltip content = {FORM_TYPE_TO_NAME_MAP[FormType.Questionnaire]}
                                position = {Position.BOTTOM} >
                                                             <Icon className = 'form-card__left-icon'
                                color = {FORM_TYPE_TO_COLOR_MAP[FormType.Questionnaire]}
                                icon = {FORM_TYPE_TO_ICON_MAP[FormType.Questionnaire]}
                                title = {FormType.Questionnaire}
                        />
                        < /Tooltip>}
                        < div;
                        className = 'form-card__text' > {name} < /div>
                                    < /div>;
                    ))
                        ;
                        src / ui / blocks / layout / layout.tsx;
                        import React, {FC, memo} from 'react';
                        import './layout.styl';

                        type Props = {
                            leftComponent?: JSX.Element | JSX.Element[];
                            rightComponent?: JSX.Element | JSX.Element[];
                        }

                        export const Layout: FC<Props> = memo((
                                                                  {
                                                                      leftComponent = null,
                                                                      rightComponent = null,
                                                                  },
                                                              ) => (
                            <div className = 'layout' >
                                             <div className = 'layout__left-column' >
                                {
                                    leftComponent,
                                }
                                                              < /div>
                                                              < div
                        className = 'layout__right-column' >
                            {
                                rightComponent,
                            }
                                    < /div>
                                    < /div>;
                    ))
                        ;
                        src / ui / blocks / contacts / contacts.tsx;
                        import React, {FC} from 'react';
                        import {HomePageParagraph} from 'src/ui/blocks/home-page-paragraph/home-page-paragraph';

                        const info = [
                            {
                                title: 'Контакты',
                                mode: 1,
                                description: '',
                            },
                            {
                                title: 'Адрес',
                                mode: 3,
                                description: '109028, г. Москва, Покровский бульвар, д. 11',
                            },
                            {
                                title: 'E-mail',
                                mode: 3,
                                description: 'cppr.cs@hse.ru',
                            },
                            {
                                title: 'Руководство',
                                mode: 3,
                                description: '',
                            },
                        ];

                        const contacts = [
                            {
                                position: 'Руководитель центра',
                                name: 'Ахметсафина Римма Закиевна',
                                link: 'https://www.hse.ru/staff/rakhmetsafina',
                            },
                            {
                                position: 'Менеджер центра',
                                name: 'Ченцова Элина Александровна',
                                link: 'https://www.hse.ru/staff/elinachentsova',
                            },
                            {
                                position: 'Менеджер по работе со студентами ',
                                name: 'Ге́тун Юлия Александровна',
                                link: 'https://www.hse.ru/org/persons/325138530',
                            },
                        ];

                        export const Contacts: FC = () => {
                            return <>
                                {
                                    info.map((elem, ind) => {
                                        return <HomePageParagraph key = {ind};
                                        {...
                                            elem;
                                        }
                                        />;;
                                    }),
                                };
                            {
                                contacts.map(({position, name, link}, ind) => (
                                    <p key = {ind}
                                className = 'home-page-heading__description' > {position} - <a href = {link};
                                target = 'blank';
                                rel = 'noopener noreferrer' > {name} < /a></;
                                p >
                            ))
                            }
                            </>;;
                        };
                        src / ui / blocks / project - application - card / project - application - card.tsx;
                        import {Button, ButtonGroup, Intent} from '@blueprintjs/core';
                        import React, {FC, useCallback, useMemo} from 'react';
                        import {Link} from 'react-router-dom';
                        import {ProfileOrSearchItem, ProjectApplicationStatus, ProjectRequestStatus} from 'src/types';
                        import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                        import './project-application-card.styl';

                        type ProjectApplicationCardProps = {
                            name: string;
                            link: string;
                            status: ProjectApplicationStatus;
                            projectId: string;
                            studentId: string;
                            editItem: (itemIndex: number, newInfo: ProfileOrSearchItem) => void;
                            itemIndex: number;
                        }
                        export const ProjectApplicationCard: FC<ProjectApplicationCardProps> = ({name, link, status, projectId, studentId, editItem, itemIndex}) => {
                            const cppwApi = useCppwApiContext();
                            const handleAccept = useCallback(() => {
                                cppwApi && cppwApi.changeProjectApplicationStatus(projectId, studentId, ProjectApplicationStatus.Accepted, () => {

                                    editItem(itemIndex, {status: ProjectApplicationStatus.Accepted});
                                });
                            }, [projectId, studentId, cppwApi, editItem, itemIndex]);
                            const handleReject = useCallback(() => {
                                cppwApi && cppwApi.changeProjectApplicationStatus(projectId, studentId, ProjectApplicationStatus.Rejected, () => {

                                    editItem(itemIndex, {status: ProjectApplicationStatus.Rejected});
                                });
                            }, [projectId, studentId, cppwApi, editItem, itemIndex]);
                            const handleRestart = useCallback(() => {
                                cppwApi && cppwApi.changeProjectApplicationStatus(projectId, studentId, ProjectApplicationStatus.Waiting, () => {

                                    editItem(itemIndex, {status: ProjectApplicationStatus.Waiting});
                                });
                            }, [projectId, studentId, cppwApi, editItem, itemIndex]);

                            const cardControls = useMemo(() => {
                                switch (status) {
                                    case ProjectApplicationStatus.Waiting: {
                                        return <ButtonGroup className = 'project-application-card__buttons' >
                                                                        <Button text = 'Подтвердить';
                                        onClick = {handleAccept};
                                        intent = {Intent.PRIMARY};
                                        />
                                        < Button;
                                        text = 'Отклонить';
                                        onClick = {handleReject};
                                        intent = {Intent.DANGER};
                                        />
                                        < /ButtonGroup>;;
                                    }
                                    case ProjectApplicationStatus.Accepted: {
                                        return <div>
                                            <span className = 'project-application-card__accepted' > Заявка;
                                        подтверждена. < /span>
                                        < Button;
                                        className = 'project-application-card__buttons';
                                        text = 'Вернуть в рассмотрение';
                                        onClick = {handleRestart};
                                        />
                                        < /div>;;
                                    }
                                    case ProjectApplicationStatus.Rejected: {
                                        return <div>
                                            <span className = 'project-application-card__rejected' > Заявка;
                                        отклонена. < /span>
                                        < Button;
                                        className = 'project-application-card__buttons';
                                        text = 'Вернуть в рассмотрение';
                                        onClick = {handleRestart};
                                        />
                                        < /div>;;
                                    }
                                    default:
                                        return null;
                                }
                            }, [handleAccept, handleReject, handleRestart, status]);
                            return <div className = 'project-application-card' >
                                                    <Link to = {link};
                            className = 'project-application-card__link' > {name} < /Link>
                                        < div;
                            className = 'project-application-card__controls' >
                                {cardControls}
                                        < /div>
                                        < /div>;;
                        };

                        type ProjectApplicationOwnerCardProps = {
                            name: string;
                            link: string;
                            status: ProjectApplicationStatus | ProjectRequestStatus;
                            isCanceled?: boolean;
                            // Иногда он на самом деле projectId:)
                            applicationId: string;
                            editItem: (itemIndex: number, newInfo: ProfileOrSearchItem) => void;
                            itemIndex: number;
                        }
                        export const ProjectApplicationOwnerCard: FC<ProjectApplicationOwnerCardProps> = ({name, link, status, isCanceled, applicationId, editItem, itemIndex}) => {
                            const cppwApi = useCppwApiContext();
                            const handleCancel = useCallback(() => {
                                if (isCanceled) {
                                    cppwApi && cppwApi.reapplyForProjectApplication('', applicationId, () => {
                                        editItem(itemIndex, {isCanceled: false});
                                    });
                                } else {
                                    cppwApi && cppwApi.cancelProjectApplication('', applicationId, () => {
                                        editItem(itemIndex, {isCanceled: true});
                                    });
                                }
                            }, [isCanceled, applicationId, cppwApi, editItem, itemIndex]);
                            const cardControls = useMemo(() => {
                                switch (status) {
                                    case ProjectRequestStatus.Waiting:
                                    case ProjectApplicationStatus.Waiting: {
                                        return <div>
                                            {!;
                                        isCanceled && <span className = 'project-application-card__waiting' > Заявка;
                                        на;
                                        рассмотрении. < /span>}
                                        < Button;
                                        text = {isCanceled ? 'Подать заявку' : 'Отменить заявку'};
                                        onClick = {handleCancel};
                                        />
                                        < /div>;;
                                    }
                                    case
                                        ProjectRequestStatus.Accepted;
                                    :
                                    case
                                        ProjectApplicationStatus.Accepted;
                                    :
                                        {
                                            return <div>
                                                <span className = 'project-application-card__accepted _cancel-margin' > Заявка;
                                            подтверждена. < /span>
                                            < /div>;;
                                        }
                                    case
                                        ProjectRequestStatus.Rejected;
                                    :
                                    case
                                        ProjectApplicationStatus.Rejected;
                                    :
                                        {
                                            return <div>
                                                <span className = 'project-application-card__rejected _cancel-margin' > Заявка;
                                            отклонена. < /span>
                                            < /div>;;
                                        }
                                    default:
                                        return null;
                                    }
                                }
                            ,
                                [isCanceled, handleCancel, status];
                            );
                            return <div className = 'project-application-card' >
                                                    <Link to = {link};
                            className = 'project-application-card__link' > {name} < /Link>
                                        < div;
                            className = 'project-application-card__controls' >
                                {cardControls}
                                        < /div>
                                        < /div>;;
                        };
                        export const ProjectApplicationOwnerCard3: FC<ProjectApplicationOwnerCardProps> = ({name, link, status, isCanceled, applicationId, editItem, itemIndex}) => {
                            const cppwApi = useCppwApiContext();
                            const handleCancel = useCallback(() => {
                                if (isCanceled) {
                                    cppwApi && cppwApi.recreateProjectRequest(applicationId, () => {
                                        editItem(itemIndex, {isCanceled: false});
                                    });
                                } else {
                                    cppwApi && cppwApi.cancelProjectRequest(applicationId, () => {
                                        editItem(itemIndex, {isCanceled: true});
                                    });
                                }
                            }, [isCanceled, applicationId, cppwApi, editItem, itemIndex]);
                            const cardControls = useMemo(() => {
                                switch (status) {
                                    case ProjectRequestStatus.Waiting:
                                    case ProjectApplicationStatus.Waiting: {
                                        return <div>
                                            {!;
                                        isCanceled && <span className = 'project-application-card__waiting' > Заявка;
                                        на;
                                        рассмотрении. < /span>}
                                        < Button;
                                        text = {isCanceled ? 'Подать заявку' : 'Отменить заявку'};
                                        onClick = {handleCancel};
                                        />
                                        < /div>;;
                                    }
                                    case
                                        ProjectRequestStatus.Accepted;
                                    :
                                    case
                                        ProjectApplicationStatus.Accepted;
                                    :
                                        {
                                            return <div>
                                                <span className = 'project-application-card__accepted _cancel-margin' > Заявка;
                                            подтверждена. < /span>
                                            < /div>;;
                                        }
                                    case
                                        ProjectRequestStatus.Rejected;
                                    :
                                    case
                                        ProjectApplicationStatus.Rejected;
                                    :
                                        {
                                            return <div>
                                                <span className = 'project-application-card__rejected _cancel-margin' > Заявка;
                                            отклонена. < /span>
                                            < /div>;;
                                        }
                                    default:
                                        return null;
                                    }
                                }
                            ,
                                [isCanceled, handleCancel, status];
                            );
                            return <div className = 'project-application-card' >
                                                    <Link to = {link};
                            className = 'project-application-card__link' > {name} < /Link>
                                        < div;
                            className = 'project-application-card__controls' >
                                {cardControls}
                                        < /div>
                                        < /div>;;
                        };

                        type ProjectApplicationOwnerCard2Props = {
                            name: string;
                            link: string;
                            isRequested: boolean;
                            projectId: string;
                            editItem: (itemIndex: number, newInfo: ProfileOrSearchItem) => void;
                            itemIndex: number;
                        }
                        export const ProjectApplicationOwnerCard2: FC<ProjectApplicationOwnerCard2Props> = ({name, link, isRequested, projectId, editItem, itemIndex}) => {
                            const cppwApi = useCppwApiContext();
                            const handleRequest = useCallback(() => {
                                // TODO разобраться с idшниками
                                if (!isRequested) {
                                    cppwApi && cppwApi.reapplyForProjectApplication('', projectId, () => {
                                        editItem(itemIndex, {isRequested: true});
                                    });
                                } else {
                                    cppwApi && cppwApi.cancelProjectApplication('', projectId, () => {
                                        editItem(itemIndex, {isRequested: false});
                                    });
                                }
                            }, [isRequested, projectId, cppwApi, editItem, itemIndex]);
                            return <div className = 'project-application-card' >
                                                    <Link to = {link};
                            className = 'project-application-card__link' > {name} < /Link>
                                        < div;
                            className = 'project-application-card__controls' >
                                        <Button text = {isRequested ? 'Отменить заявку' : 'Подать заявку'};
                            onClick = {handleRequest};
                            intent = {isRequested ? Intent.DANGER : Intent.PRIMARY};
                            />
                            < /div>
                            < /div>;;
                        };
                        src / ui / blocks / admin / students - group - actualisation.tsx;
                        import {Button, ButtonGroup, Intent} from '@blueprintjs/core';
                        import React, {FC, useCallback, useEffect, useMemo, useRef, useState} from 'react';
                        import {AsyncStatus, Usage} from 'src/types';
                        import {FormInput} from 'src/ui/blocks/form-input/form-input';
                        import {HomePageParagraph} from 'src/ui/blocks/home-page-paragraph/home-page-paragraph';
                        import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                        import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                        export const StudentsGroupActualisation: FC = () => {
                            const cppwApi = useCppwApiContext();

                            const [status, setStatus] = useState(AsyncStatus.Initial);
                            const [isEditing, setIsEditing] = useState(false);
                            const [groups, setGroups] = useState<string[]>([]);

                            const groupsRef = useRef<{ value: string[] } | null>(null);

                            const validators = useMemo(() => [], []);

                            const setGroupsRef = useCallback((val: any) => {groupsRef.current = val;}, []);
                            const startEditing = useCallback(() => {setIsEditing(true);}, [setIsEditing]);
                            const finishEditing = useCallback(() => {
                                groupsRef.current && cppwApi && cppwApi.setNewStudentGroupsList(groupsRef.current.value, () => {
                                    if (groupsRef.current) {
                                        setGroups(groupsRef.current.value);
                                        setIsEditing(false);
                                    } else {
                                        throw new Error();
                                    }
                                });
                            }, [cppwApi, setIsEditing]);
                            const cancelEditing = useCallback(() => {setIsEditing(false);}, [setIsEditing]);
                            const onRetry = useCallback(() => {
                                cppwApi && cppwApi.getStudentGroupsList(
                                    () => {
                                        setStatus(AsyncStatus.Pending);
                                    },
                                    (groups: string[]) => {
                                        setGroups(groups);
                                        setStatus(AsyncStatus.Success);
                                    },
                                    () => {
                                        setStatus(AsyncStatus.Error);
                                    },
                                );
                            }, [cppwApi, setStatus]);

                            useEffect(() => {
                                if (status === AsyncStatus.Initial) {
                                    cppwApi && cppwApi.getStudentGroupsList(
                                        () => {
                                            setStatus(AsyncStatus.Pending);
                                        },
                                        (groups: string[]) => {
                                            setGroups(groups);
                                            setStatus(AsyncStatus.Success);
                                        },
                                        () => {
                                            setStatus(AsyncStatus.Error);
                                        },
                                    );
                                }
                                // Не стоит добавлять в зависимости статус. Если он изменился, значит данный useEffect отработал и выполнил свою функцию.
                            }, [cppwApi, setStatus]);
                            return <LoadableView status = {status};
                            errorTitle = 'Группы студентов не загрузились';
                            errorSubtitle = {'Нажмите для повторного запроса'};
                            onRetry = {onRetry} >
                                                <HomePageParagraph title = 'Обновление списка активных студенческих групп';
                            mode = {2};
                            />;
                            {
                                !isEditing && groups.map((name, index) => <div key = {index}
                                className = 'students-group-actualisation__item' > {name} < /div>);
                            }
                            {
                                isEditing && <div className = 'students-group-actualisation__input' >
                                                              <FormInput title = '';
                                key = {'groups'};
                                name = {'groups'};
                                id = {'groups'};
                                mandatory = {false};
                                validators = {validators};
                                usage = {Usage.Variants};
                                inputRef = {setGroupsRef};
                                formIndex = { - 1;
                            }
                                defaultValue = {groups};
                                index = { - 1;
                            }
                                />
                                < /div>;
                            }
                            <ButtonGroup className = 'students-group-actualisation__buttons' >
                                {
                            !isEditing && <Button text = 'Редактировать';
                            intent = {Intent.PRIMARY};
                            onClick = {startEditing};
                            />};
                            {
                                isEditing && <Button text = 'Сохранить';
                                intent = {Intent.PRIMARY};
                                onClick = {finishEditing};
                                />;
                            }
                            {
                                isEditing && <Button text = 'Отменить';
                                onClick = {cancelEditing};
                                />;
                            }
                            </ButtonGroup>
                            < /LoadableView>;;
                        }
                            ;src / ui / blocks / admin / new - academic - year.tsx;
                            import {Button, Intent} from '@blueprintjs/core';
                            import React, {FC, useCallback, useEffect, useMemo, useState} from 'react';
                            import {AsyncStatus} from 'src/types';
                            import {HomePageParagraph} from 'src/ui/blocks/home-page-paragraph/home-page-paragraph';
                            import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                            import {parseDate} from 'src/ui/utils/parse-date';

                            const ELEVEN_MONTHS = 11 * 30 * 24 * 60 * 60 * 1000;

                            export const NewAcademicYear: FC = () => {
                                const cppwApi = useCppwApiContext();

                                const [status, setStatus] = useState(AsyncStatus.Initial);
                                const [lastDate, setLastDate] = useState(new Date(0));

                                const nextDate = useMemo(() => new Date(Number(lastDate) + ELEVEN_MONTHS), [lastDate]);
                                const disabled = useMemo(() => new Date() < nextDate, [nextDate]);

                                const startNewAcademicYear = useCallback(() => {
                                    if (!disabled) {
                                        cppwApi && cppwApi.startNewAcademicYear(
                                            () => {
                                                setLastDate(new Date());
                                            },
                                        );
                                    }
                                }, [disabled, cppwApi, setLastDate]);
                                const onRetry = useCallback(() => {
                                    cppwApi && cppwApi.getLastAcademicYearStartDate(
                                        () => {
                                            setStatus(AsyncStatus.Pending);
                                        },
                                        (date: number) => {
                                            setLastDate(new Date(date));
                                            setStatus(AsyncStatus.Success);
                                        },
                                        () => {
                                            setStatus(AsyncStatus.Error);
                                        },
                                    );
                                }, [cppwApi, setStatus]);

                                useEffect(() => {
                                    if (status === AsyncStatus.Initial) {
                                        cppwApi && cppwApi.getLastAcademicYearStartDate(
                                            () => {
                                                setStatus(AsyncStatus.Pending);
                                            },
                                            (date: number) => {
                                                setLastDate(new Date(date));
                                                setStatus(AsyncStatus.Success);
                                            },
                                            () => {
                                                setStatus(AsyncStatus.Error);
                                            },
                                        );
                                    }
                                    // Не стоит добавлять в зависимости статус. Если он изменился, значит данный useEffect отработал и выполнил свою функцию.
                                }, [cppwApi, setStatus]);

                                return <LoadableView status = {status};
                                errorTitle = 'Функция временно недоступна';
                                onRetry = {onRetry};
                                errorSubtitle = {'Нажмите для повторного запроса.'} >
                                                                                    <HomePageParagraph title = 'Начало учебного года';
                                mode = {2};
                                description = {`Последний раз начало учебного года происходило ${parseDate(lastDate)} В следующий раз функция будет доступна ${parseDate(
                                    nextDate)}`;
                            }
                                />
                                < Button;
                                className = {'new-academic-year__start-button'};
                                disabled = {disabled};
                                onClick = {startNewAcademicYear};
                                text = 'Начать учебный год';
                                intent = {Intent.PRIMARY};
                                />
                                < /LoadableView>;;
                            };
                            src / ui / blocks / admin / contacts - actualisation.tsx;
                            import {Button, Intent} from '@blueprintjs/core';
                            import React, {FC, useCallback, useEffect, useState} from 'react';
                            import {AsyncStatus} from 'src/types';
                            import {HomePageParagraph} from 'src/ui/blocks/home-page-paragraph/home-page-paragraph';
                            import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                            import {parseDate} from 'src/ui/utils/parse-date';

                            export const ContactsActualisation: FC = () => {
                                const cppwApi = useCppwApiContext();

                                const [status, setStatus] = useState(AsyncStatus.Initial);
                                const [lastDate, setLastDate] = useState(new Date(0));

                                const startNewAcademicYear = useCallback(() => {
                                    cppwApi && cppwApi.actualizeContacts(
                                        () => {
                                            setLastDate(new Date());
                                        },
                                    );
                                }, [cppwApi, setLastDate]);
                                const onRetry = useCallback(() => {
                                    cppwApi && cppwApi.getLastContactsActualisationDate(
                                        () => {
                                            setStatus(AsyncStatus.Pending);
                                        },
                                        (date: number) => {
                                            setLastDate(new Date(date));
                                            setStatus(AsyncStatus.Success);
                                        },
                                        () => {
                                            setStatus(AsyncStatus.Error);
                                        },
                                    );
                                }, [cppwApi, setStatus]);

                                useEffect(() => {
                                    if (status === AsyncStatus.Initial) {
                                        cppwApi && cppwApi.getLastContactsActualisationDate(
                                            () => {
                                                setStatus(AsyncStatus.Pending);
                                            },
                                            (date: number) => {
                                                setLastDate(new Date(date));
                                                setStatus(AsyncStatus.Success);
                                            },
                                            () => {
                                                setStatus(AsyncStatus.Error);
                                            },
                                        );
                                    }
                                    // Не стоит добавлять в зависимости статус. Если он изменился, значит данный useEffect отработал и выполнил свою функцию.
                                }, [cppwApi, setStatus]);

                                return <LoadableView status = {status};
                                errorTitle = 'Функция временно недоступна';
                                onRetry = {onRetry};
                                errorSubtitle = {'Нажмите для повторного запроса.'} >
                                                                                    <HomePageParagraph title = 'Актуализация контактов';
                                mode = {2};
                                description = {`Последний раз актуализация контактов производилась ${parseDate(lastDate)}`;
                            }
                                />
                                < Button;
                                className = {'new-academic-year__start-button'};
                                onClick = {startNewAcademicYear};
                                text = 'Актуализировать контакты';
                                intent = {Intent.PRIMARY};
                                />
                                < /LoadableView>;;
                            };
                            src / ui / blocks / admin / add - student - to - activity.tsx;
                            import React, {FC, useCallback, useState} from 'react';
                            import {FormMode, FormType, Usage} from 'src/types';
                            import {FormLayout} from 'src/ui/blocks/form-layout/form-layout';
                            import {SuccessView} from 'src/ui/blocks/success-view/success-view';
                            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                            const ADD_STUDENTS_TO_ACTIVITY_ATTRIBUTES = [
                                {
                                    id: `${DEFAULT_ATTRIBUTE_ID}${DEFAULT_ATTRIBUTE_ID}$-student`,
                                    name: 'student',
                                    usage: Usage.Student,
                                    title: 'ФИО студента',
                                    mandatory: true,
                                    validators: [],
                                    isPlaceholder: true,
                                },
                                {
                                    id: `${DEFAULT_ATTRIBUTE_ID}${DEFAULT_ATTRIBUTE_ID}$-activity`,
                                    name: 'activity',
                                    usage: Usage.Activity,
                                    title: 'Наименование активности',
                                    mandatory: true,
                                    validators: [],
                                    isPlaceholder: true,
                                },
                            ];

                            export const AddStudentToActivity: FC = () => {
                                const cppwApi = useCppwApiContext();
                                const [errors, setErrors] = useState();
                                const [sentStatus, setSentStatus] = useState(false);
                                const onRetryFilling = useCallback(() => {
                                    setSentStatus(false);
                                    setErrors(undefined);
                                }, [setSentStatus, setErrors]);

                                const onFormSubmit = useCallback((vals) => {
                                    cppwApi && cppwApi.addStudentToActivity(vals[0].id, vals[1],
                                                                            () => {
                                                                                setSentStatus(true);
                                                                            },
                                    );
                                }, [cppwApi]);

                                if (sentStatus) {
                                    return <>
                                               {
                                           < SuccessView;
                                    title = {'Студент добавлен!'};
                                    onRetry = {onRetryFilling};
                                    />;
                                }
                                    </>;;
                                }

                                return <>
                                    <FormLayout type = {FormType.Questionnaire};
                                buttonName = {'Добавить'};
                                id = {''};
                                title = '';
                                description = 'Добавление студента в активность';
                                mode = {FormMode.Fill};
                                errors = {errors};
                                onSetError = {setErrors};
                                onFormSubmit = {onFormSubmit};
                                // Приходит отрицательным (-1) для форм вне списка форм пользователя.
                                // Фактически запрещает редактирование
                                index = { - 1;
                            }
                                attributes = {ADD_STUDENTS_TO_ACTIVITY_ATTRIBUTES};
                                />
                                < />;;
                            };
                            src / ui / blocks / admin / admin.tsx;
                            import React, {FC} from 'react';
                            import {AddStudentToActivity} from 'src/ui/blocks/admin/add-student-to-activity';
                            import {ContactsActualisation} from 'src/ui/blocks/admin/contacts-actualisation';
                            import {NewAcademicYear} from 'src/ui/blocks/admin/new-academic-year';
                            import {StudentsGroupActualisation} from 'src/ui/blocks/admin/students-group-actualisation';
                            import {Activity} from 'src/ui/blocks/default-form-view/activity';
                            import {Organisation} from 'src/ui/blocks/default-form-view/organisation';
                            import {Project} from 'src/ui/blocks/default-form-view/project';
                            import {UsersRegistration} from 'src/ui/blocks/default-form-view/registration';
                            import {HomePageParagraph} from 'src/ui/blocks/home-page-paragraph/home-page-paragraph';
                            import './admin.styl';

                            type Props = {
                                selectedTab: number;
                            }
                            export const Admin: FC<Props> = ({selectedTab}) => {
                                return <div>
                                    <HomePageParagraph title = 'Панель администратора';
                                mode = {1};
                                />;
                                {
                                    selectedTab === 0 && <Activity / >
                                }
                                {
                                    selectedTab === 1 && <Project / >
                                }
                                {
                                    selectedTab === 2 && <Organisation / >
                                }
                                {
                                    selectedTab === 3 && <UsersRegistration / >
                                }
                                {
                                    selectedTab === 4 && <NewAcademicYear / >
                                }
                                {
                                    selectedTab === 5 && <ContactsActualisation / >
                                }
                                {
                                    selectedTab === 6 && <StudentsGroupActualisation / >
                                }
                                {
                                    selectedTab === 7 && <AddStudentToActivity / >
                                }
                                </div>;;
                            };
                            src / ui / blocks / comment - view / comment - view.tsx;
                            import {Button, ButtonGroup, Icon, Intent} from '@blueprintjs/core';
                            import React, {FC, useCallback, useMemo, useRef, useState} from 'react';
                            import {Link} from 'react-router-dom';
                            import {AttributeRef, Usage, UserAction} from 'src/types';
                            import {FormInput} from 'src/ui/blocks/form-input/form-input';
                            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                            import './comment-view.styl';
                            import {BACKEND_URL} from 'src/ui/utils/constants';

                            type Props = {
                                // id комментария, по которому будет осуществляться редактирование иудаление
                                id: string;
                                userName: string;
                                userAction: UserAction;
                                userLink: string;
                                text: string;
                                file: {
                                          id: string;
                                          name: string;
                                          type: 'file';
                                      } | null;
                                editItem: (itemIndex: number, newItem: any) => void;
                                itemIndex: number;
                            }
                            export const CommentView: FC<Props> = ({id, userName, userLink, userAction, text, file, editItem, itemIndex}) => {
                                const cppwApi = useCppwApiContext();

                                const [isEditing, setIsEditing] = useState(false);

                                const commentRef = useRef<AttributeRef>(null);
                                const fileRef = useRef<{ value: { id: string, name: string, type: 'file' } | null }>(null);

                                const validators = useMemo(() => [], []);

                                const setCommentRef = useCallback((val) => {commentRef.current = val;}, []);
                                const setFileRef = useCallback((val) => {
                                    // @ts-ignore
                                    fileRef.current = val;
                                }, []);
                                const onDelete = useCallback(() => {
                                    cppwApi && cppwApi.deleteComment(id, () => {editItem(itemIndex, null);});
                                }, [id, cppwApi, editItem, itemIndex]);
                                const onStartEditing = useCallback(() => {setIsEditing(true);}, [setIsEditing]);
                                const onFinishEditing = useCallback(() => {
                                    const newComment = {
                                        file: fileRef.current ? fileRef.current.value : undefined,
                                        text: commentRef.current ? commentRef.current.value : undefined,
                                    };
                                    cppwApi && cppwApi.editComment(id, newComment, () => {
                                        editItem(itemIndex, newComment);
                                        setIsEditing(false);
                                    });
                                }, [editItem, itemIndex, id, cppwApi, setIsEditing]);
                                const onCancelEditing = useCallback(() => {setIsEditing(false);}, [setIsEditing]);
                                return <div className = {'comment-view'} >
                                                                         <div className = {'comment-view__title'} > <Link to = {userLink} > {userName} < /Link>{` ${userAction}`}</;
                                div >
                                {
                                    isEditing ? <FormInput title = ''
                                                key = {'comment'}
                                    name = {'net'}
                                    id = {'net-name'}
                                    defaultValue = {text}
                                    mandatory = {false}
                                    validators = {validators}
                                    placeholder = {''}
                                    usage = {Usage.LongText}
                                    inputRef = {setCommentRef}
                                    formIndex = { - 1,
                                };
                                index = { - 1;
                            }
                                />;
                            :
                                <div>{text} < /div>};
                                {
                                    file && !isEditing && <div><a href = {`${BACKEND_URL}/api/v1/${file.type}/${file.id}`;
                                }
                                    download = {true} > {file.name} < /a></;
                                    div >
                                }
                                {
                                    isEditing && <FormInput key = {'filik'};
                                    title = '';
                                    name = {'file'};
                                    id = {'filik'};
                                    defaultValue = {file};
                                    mandatory = {false};
                                    validators = {validators};
                                    usage = {Usage.File};
                                    inputRef = {setFileRef};
                                    formIndex = { - 1;
                                }
                                    index = { - 1;
                                }
                                    placeholder = 'Нажмите для выбора файла...'
                                                  / >
                                }
                                {
                                    !isEditing && <><Icon icon = {'cross'};
                                    className = 'comment-view__cross';
                                    onClick = {onDelete};
                                    /><Icon icon='cog' className='comment-view__cog';
                                    onClick = {onStartEditing};
                                    /></ >
                                }
                                {
                                    isEditing && <ButtonGroup>
                                        <Button text = 'Сохранить';
                                    intent = {Intent.PRIMARY};
                                    onClick = {onFinishEditing};
                                    />
                                    < Button;
                                    text = 'Отменить';
                                    onClick = {onCancelEditing};
                                    />
                                    < /ButtonGroup>;
                                }
                                </div>;;
                            }
                                ;
                                src / ui / blocks / forms - column / forms - column.tsx;
                                import {Classes, Spinner, Tab, Tabs} from '@blueprintjs/core';

                                import React, {FC, useCallback, useMemo} from 'react';
                                import {useDispatch} from 'react-redux';
                                import {addNewUserForm} from 'src/store/actions/user-forms.actions';
                                import {AsyncStatus, Form, FormMode, FormsList, FormType} from 'src/types';
                                import {ErrorView} from 'src/ui/blocks/error-view/error-view';

                                import {FormCard} from 'src/ui/blocks/form-card/form-card';
                                import {Search} from 'src/ui/blocks/search/search';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                import './forms-column.styl';

                                type Props = {
                                    forms: Form[];
                                    status: AsyncStatus;
                                    currentFormIndex: number;
                                    setCurrentFormIndex: (index: number) => void;
                                    currentTab: FormsList;
                                    setCurrentTab: (index: FormsList) => void;
                                }

                                export const DEFAULT_FORM_ID = 'id-form-id';
                                const NEW_FORM = {
                                    id: DEFAULT_FORM_ID,
                                    type: FormType.Initial,
                                    title: 'Без названия',
                                    buttonName: '',
                                    attributes: [],
                                    mode: FormMode.Edit,
                                };

                                export const FormsColumn: FC<Props> = ({forms, status, currentFormIndex, setCurrentFormIndex, currentTab, setCurrentTab}) => {
                                    const dispatch = useDispatch();
                                    const cppwApi = useCppwApiContext();
                                    const items = useMemo(() => (forms.map((form: Form, index: number) => ({
                                        isActive: currentFormIndex === index,
                                        isEditing: form.mode === FormMode.Edit,
                                        isArchive: currentTab === FormsList.Archive,
                                        index,
                                        title: form.title,
                                        form,
                                        onClick: () => {setCurrentFormIndex(index);},
                                    }))), [forms, setCurrentFormIndex, currentTab, currentFormIndex]);

                                    const onRetry = useCallback(() => {
                                        if (cppwApi) {
                                            if (currentTab === FormsList.My) {
                                                cppwApi.getUserForms();
                                            } else {
                                                cppwApi.getUserArchiveForms();
                                            }
                                        }
                                    }, [currentTab, cppwApi]);
                                    const onCreateNewForm = useCallback(() => {
                                        dispatch(addNewUserForm(NEW_FORM));
                                        setCurrentFormIndex(forms.length);
                                    }, [dispatch, forms.length, setCurrentFormIndex]);
                                    const onSelectTab = useCallback((val) => {setCurrentTab(String(val) as FormsList);}, [setCurrentTab]);

                                    return (
                                        <>
                                            <Tabs id = 'forms-column__navbar'
                                    className = 'forms-column__navbar';
                                    selectedTabId = {currentTab};
                                    onChange = {onSelectTab};
                                    large = {true} >
                                                   <Tab key = {FormsList.My};
                                    id = {FormsList.My};
                                    title = 'Активные формы' / >
                                            <Tab key = {FormsList.Archive};
                                    id = {FormsList.Archive};
                                    title = 'Архив форм' / >
                                            </Tabs>
                                            < div;
                                    className = {`${Classes.FILL} scrollable-tabs`;
                                }
                                >
                                    <Search searchPropertyName = 'title';
                                    component = {FormCard};
                                    items = {items};
                                    />;
                                    {
                                        (status === AsyncStatus.Pending || status === AsyncStatus.Initial)
                                        && <Spinner className = 'spinner-full-width' / >
                                    }
                                    {

                                        status === AsyncStatus.Error && <ErrorView title = 'Ошибка загрузки списка форм.';
                                        subtitle = 'Нажмите для повторного запроса.';
                                        onRetry = {onRetry};
                                        size = 's' / >
                                    }
                                    {
                                        currentTab === FormsList.My && status === AsyncStatus.Success && <FormCard key = {'last'};
                                        isPlaceholder = {true};
                                        onClick = {onCreateNewForm};
                                        />}

                                        < /div>
                                        < />;
                                    )
                                    ;
                                };
                                src / ui / blocks / form - layout / form - layout.tsx;
                                import {Button, ButtonGroup, EditableText, H1, H2, H3, Intent} from '@blueprintjs/core';

                                import React, {FC, memo, useCallback, useEffect, useMemo, useState} from 'react';
                                import {useDispatch} from 'react-redux';
                                import {parseFields} from 'src/api/api-parser/form-parser';
                                import {
                                    addDraftFormAttributes,
                                    changeUserFormMode,
                                    deleteNewUserForm,
                                    editUserForm,
                                    setDraftFormButtonName,
                                    setDraftFormDescription,
                                    setDraftFormTitle,
                                } from 'src/store/actions/user-forms.actions';
                                import {AsyncStatus, Attribute, AttributeRef, AttributeValue, Form, FormMode, FormType} from 'src/types';
                                import {AttributeCreator} from 'src/ui/blocks/attribute-creator/attribute-creator';
                                import {FormInput} from 'src/ui/blocks/form-input/form-input';
                                import {FormStats} from 'src/ui/blocks/form-stats/form-stats';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                import {validateAllAttributes} from 'src/ui/utils/form-input-validator/validator';
                                import './form-layout.styl';

                                type Props = Form & {
                                    mode: FormMode;
                                    errors?: string[];
                                    onSetError: (newErrors: string[]) => void;
                                    HeaderComponent?: typeof H1 | typeof H2 | typeof H3;
                                    onFormSubmit: (values: AttributeValue[], attributes: Attribute[]) => void;
                                    // Приходит отрицательным (-1) для форм вне списка форм пользователя.
                                    // Фактически запрещает редактирование
                                    index: number;
                                    backup?: Form;
                                    className?: string;
                                    handleCancel?: () => void;
                                }

                                export const FormLayout: FC<Props> = memo(({
                                                                               id,
                                                                               attributes,
                                                                               title,
                                                                               type,
                                                                               description,
                                                                               buttonName,
                                                                               mode,
                                                                               backup,
                                                                               errors,
                                                                               onSetError,
                                                                               onFormSubmit,
                                                                               index: formIndex,
                                                                               HeaderComponent = H1,
                                                                               className,
                                                                               handleCancel,
                                                                               stats,
                                                                           }) => {
                                    const dispatch = useDispatch();
                                    const cppwApi = useCppwApiContext();

                                    const refs = useMemo<(AttributeRef)[]>(() => attributes.map(() => (
                                        null
                                    )), [attributes]);
                                    const setInputRefs = useMemo<((elem: AttributeRef) => void)[]>(() => attributes.map((
                                                                                                                            val,
                                                                                                                            index: number,
                                                                                                                        ) => (elem: AttributeRef) => {
                                        refs[index] = elem;
                                    }), [attributes]);
                                    const [formType, setFormType] = useState(type || '');

                                    const onChangeTitle = useCallback((value) => {
                                        if (formIndex > -1) {
                                            dispatch(setDraftFormTitle(formIndex, value));
                                        }
                                    }, [dispatch, formIndex]);
                                    const onChangeDescription = useCallback((value) => {
                                        if (formIndex > -1) {
                                            dispatch(setDraftFormDescription(formIndex, value));
                                        }
                                    }, [dispatch, formIndex]);
                                    const onChangeButtonName = useCallback((value) => {
                                        if (formIndex > -1) {
                                            dispatch(setDraftFormButtonName(formIndex, value));
                                        }
                                    }, [dispatch, formIndex]);
                                    const onEditFinished = useCallback(() => {
                                        if (attributes.some(({isPlaceholder}) => isPlaceholder)) {
                                            cppwApi && cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                {
                                                    icon: 'error',
                                                    intent: Intent.DANGER,
                                                    message: 'Пожалуйста, завершите редактирование всех полей формы.',
                                                },
                                            );
                                            return;
                                        }
                                        if (!formType) {
                                            cppwApi && cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                {
                                                    icon: 'error',
                                                    intent: Intent.DANGER,
                                                    message: 'Пожалуйста, задайте тип формы.',
                                                },
                                            );
                                            return;
                                        }
                                        if (formIndex > -1) {
                                            cppwApi && cppwApi.saveForm(formIndex, {
                                                id: id,
                                                attributes: [...attributes],
                                                title,
                                                description,
                                                buttonName,
                                                type: formType as FormType,
                                            }, () => dispatch(changeUserFormMode(formIndex, FormMode.View)));
                                        }

                                    }, [id, cppwApi, formIndex, formType, dispatch, attributes, title, description, buttonName]);
                                    const onCancel = useCallback(() => {
                                        if (backup) {
                                            dispatch(editUserForm(formIndex, backup));
                                        } else {
                                            dispatch(deleteNewUserForm(formIndex));
                                        }
                                    }, [dispatch, backup, formIndex]);
                                    const onSubmit = useCallback(() => {
                                        const values = refs.map(elem => {
                                            return (
                                                elem && elem.value
                                            );
                                        });
                                        console.log(values);
                                        const newErrors = validateAllAttributes(attributes, values);
                                        onSetError(newErrors);

                                        if (mode === FormMode.Fill && newErrors.every(elem => !Boolean(elem))) {
                                            onFormSubmit(values, attributes);
                                        }
                                    }, [onFormSubmit, attributes, refs, mode, onSetError]);
                                    const onChangeFormType = useCallback((val) => {
                                        setFormType(val.target.value);

                                        cppwApi && cppwApi.get(`formatted/default-fields/${val.target.value}`).then((res) => {
                                            cppwApi && cppwApi.store.dispatch(addDraftFormAttributes(formIndex, parseFields(res)));
                                        }).catch((e) => {
                                            console.error(e);
                                            cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                {
                                                    icon: 'error',
                                                    intent: Intent.DANGER,
                                                    message: 'Ошибка загрузки дефолтных атрибутов.',
                                                });
                                        });
                                    }, [formIndex, cppwApi]);

                                    useEffect(() => {
                                        setFormType(type || '');
                                    }, [type]);

                                    if (mode === FormMode.Stats && formIndex > -1) {
                                        return <FormStats formId = {id};
                                        status = {stats ? stats.status : AsyncStatus.Initial};
                                        records = {stats ? stats.records : []};
                                        fields = {attributes};
                                        formIndex = {formIndex};
                                        />;;
                                    }

                                    if (mode === FormMode.Edit && formIndex > -1) {
                                        return (
                                            <div className = {`form-layout ${className ? className : ''}`
                                    }>
                                        <div className = {`bp3-select bp3-fill`;
                                    }>
                                        <select disabled = {attributes.length > 0};
                                        value = {formType};
                                        onChange = {onChangeFormType} >
                                                                      <option value = {''} > Выберите;
                                        тип;
                                        формы < /option>
                                        < option;
                                        value = {FormType.Questionnaire} > Форма - опросник < /option>
                                                                         < option;
                                        value = {FormType.StudentRegistration} > Форма;
                                        регистрации;
                                        для;
                                        студентов < /option>
                                        < option;
                                        value = {FormType.StudentProfileTemplate} > Форма;
                                        профиля;
                                        для;
                                        студентов < /option>
                                        < option;
                                        value = {FormType.UserRegistration} > Форма;
                                        регистрации;
                                        для;
                                        НЕ;
                                        студентов < /option>
                                        < option;
                                        value = {FormType.UserProfileTemplate} > Форма;
                                        профиля;
                                        для;
                                        НЕ;
                                        студентов < /option>
                                        < option;
                                        value = {FormType.OrgProfile} > Форма;
                                        профиля;
                                        для;
                                        организаций < /option>
                                        < option;
                                        value = {FormType.ProjectRequest} > Форма;
                                        создания;
                                        проекта < /option>
                                        < option;
                                        value = {FormType.Activity} > Форма;
                                        активности < /option>
                                        < option;
                                        value = {FormType.Help} > Форма;
                                        помощи < /option>
                                        < /select>
                                        < /div>;
                                        {
                                            formType && <>
                                                <H1>
                                                    <EditableText
                                                        className = {'form-layout__title'};
                                            onChange = {onChangeTitle};
                                            placeholder = 'Наименование формы...';
                                            value = {title};
                                            />
                                            < /H1>
                                            < EditableText;
                                            className = {'form-layout__description _mode-edit'};
                                            minLines = {2};
                                            multiline = {true};
                                            value = {description};
                                            placeholder = 'Описание формы...';
                                            onChange = {onChangeDescription};
                                            />;
                                            {
                                                attributes.map((attribute, index) => (
                                                    <FormInput
                                                        {...attribute}
                                                key = {index};
                                                // кажется они тут не нужны
                                                inputRef = {setInputRefs[index]};
                                                error = {errors ? errors[index] : ''};
                                                isEditable = {mode === FormMode.Edit;
                                            }
                                                isDeletable = {!;
                                                attribute.realName;
                                            }
                                                index = {index};
                                                formIndex = {formIndex};
                                                disabled = {true};
                                                />;
                                            ))
                                            }
                                            <AttributeCreator className = 'form-layout__plus';
                                            formIndex = {formIndex};
                                            />
                                            < p >
                                            <EditableText className = 'form-layout__button-name';
                                            onChange = {onChangeButtonName};
                                            value = {buttonName};
                                            placeholder = 'Надпись на кнопке отправки формы...'
                                                          / >
                                                          </p>
                                                          < />}
                                                          < ButtonGroup;
                                            className = 'form-layout__buttons' >
                                            {formType && <Button text = 'Сохранить';
                                            intent = {Intent.PRIMARY};
                                            onClick = {onEditFinished};
                                            />}
                                            < Button;
                                            text = 'Отменить';
                                            onClick = {onCancel};
                                            />
                                            < /ButtonGroup>
                                            < /div>;
                                        )
                                        ;
                                    }

                                    return (
                                        <div className = {`form-layout ${className ? className : ''}`
                                }>
                                    <HeaderComponent className = 'form-layout__title' > {title} < /HeaderComponent>
                                                                 < p > {description} < /p>;
                                    {
                                        attributes.map((attribute, index) => (
                                            <FormInput
                                                formIndex = {formIndex}
                                        {...
                                            attribute;
                                        }
                                        key = {index};
                                        inputRef = {setInputRefs[index]};
                                        error = {errors ? errors[index] : ''};
                                        index = {index};
                                        />;
                                    ))
                                    }
                                    <ButtonGroup className = 'form-layout__buttons' >
                                                             <Button
                                                                 text = {buttonName || 'Отправить';
                                }
                                    intent = {handleCancel ? Intent.PRIMARY : Intent.NONE};
                                    onClick = {onSubmit};
                                    />;
                                    {
                                        handleCancel && <Button text = 'Отменить';
                                        onClick = {handleCancel};
                                        />}
                                        < /ButtonGroup>
                                        < /div>;
                                    )
                                    ;
                                });
                                src / ui / blocks /
                            default
                                -form - view /
                            default
                                -form - view.tsx;
                                import {Spinner} from '@blueprintjs/core';
                                import React, {FC, memo, useCallback, useEffect, useState} from 'react';
                                import {useSelector} from 'react-redux';
                                import {State} from 'src/store/reducers';
                                import {AsyncStatus, Attribute, AttributeValue, FormType, Usage} from 'src/types';
                                import {ErrorView} from 'src/ui/blocks/error-view/error-view';

                                import {FormLayout} from 'src/ui/blocks/form-layout/form-layout';
                                import {SuccessView} from 'src/ui/blocks/success-view/success-view';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                type Props = {
                                    formType: FormType;
                                    onSubmit: (req: { [k: string]: AttributeValue }, onSubmit: () => void) => void;
                                    successTitle: string;
                                    errorTitle: string;
                                };

                                export const DefaultFormView: FC<Props> = memo(({formType, onSubmit, successTitle, errorTitle}) => {
                                    const cppwApi = useCppwApiContext();
                                    const form = useSelector((state: State) => state.defaultForms[formType]);
                                    const [errors, setErrors] = useState();
                                    const [sentStatus, setSentStatus] = useState(false);
                                    const onRetry = useCallback(() => {
                                        cppwApi && cppwApi.getDefaultForm(formType);
                                    }, [cppwApi, formType]);
                                    const onRetryFilling = useCallback(() => {
                                        setSentStatus(false);
                                        setErrors(undefined);
                                    }, [setSentStatus, setErrors]);
                                    const wrappedOnSubmit = useCallback((values, attributes) => {
                                        const req = attributes.reduce((res: { [k: string]: AttributeValue }, attribute: Attribute, index: number) => {
                                            const {name, usage, realName} = attribute;
                                            const value = values[index];

                                            if (realName) {
                                                // поле статическое
                                                if (usage === Usage.Number) {
                                                    res[realName] = parseFloat(value);
                                                } else if (usage === Usage.Checkbox) {
                                                    res[realName] = JSON.stringify(value);
                                                } else {
                                                    res[realName] = value;
                                                }
                                                return res;
                                            } else {
                                                // поле динамическое
                                                res.content[name] = value;
                                                return res;
                                            }
                                        }, {content: {}});
                                        onSubmit(req, () => {
                                            setSentStatus(true);
                                        });
                                    }, [onSubmit, setSentStatus]);

                                    useEffect(() => {
                                        if (!form) {
                                            cppwApi && cppwApi.getDefaultForm(formType);
                                        }
                                    }, [cppwApi, form, formType]);

                                    if (sentStatus) {
                                        return <>
                                                   {
                                               < SuccessView;
                                        title = {successTitle};
                                        onRetry = {onRetryFilling};
                                        />;
                                    }
                                        </>;;
                                    }
                                    return <>
                                               {
                                                   form && form.status === AsyncStatus.Pending &&
                                           <Spinner / >
                                }
                                    {
                                        form && form.status === AsyncStatus.Error &&
                                        <ErrorView title = {errorTitle};
                                        subtitle = 'Нажмите для повторного запроса.';
                                        onRetry = {onRetry};
                                        />;
                                    }
                                    {
                                        form && form.status === AsyncStatus.Success &&
                                        <FormLayout {...form.form};
                                        index = { - 1;
                                    }
                                        onFormSubmit = {wrappedOnSubmit};
                                        errors = {errors};
                                        onSetError = {setErrors};
                                        />;
                                    }
                                    </>;;
                                });
                                src / ui / blocks /
                            default
                                -form - view / project - request.tsx;
                                import React, {FC, memo, useCallback} from 'react';

                                import {FormType} from 'src/types';
                                import {DefaultFormView} from 'src/ui/blocks/default-form-view/default-form-view';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                export const ProjectRequest: FC = memo(() => {
                                    const cppwApi = useCppwApiContext();
                                    const onSubmit = useCallback((req, onSubmit) => {
                                        cppwApi && cppwApi.submitDefaultForm(
                                            req,
                                            onSubmit,
                                            `formatted/${FormType.ProjectRequest}/`,
                                            {},
                                        );
                                    }, [cppwApi]);

                                    return <>
                                        <DefaultFormView formType = {FormType.ProjectRequest};
                                    onSubmit = {onSubmit};
                                    errorTitle = 'Ошибка загрузки формы создания проекта.';
                                    successTitle = 'Заявка на проект подана!' / >
                                                   </>;;
                                });
                                src / ui / blocks /
                            default
                                -form - view / organisation.tsx;
                                import React, {FC, memo, useCallback} from 'react';
                                import {FormType} from 'src/types';
                                import {DefaultFormView} from 'src/ui/blocks/default-form-view/default-form-view';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                export const Organisation: FC = memo(() => {
                                    const cppwApi = useCppwApiContext();
                                    const onSubmit = useCallback((req, onSubmit) => {
                                        cppwApi && cppwApi.submitDefaultForm(
                                            req,
                                            onSubmit,
                                            `formatted/organisation/`,
                                            {
                                                'createdBy': '123e4567-e89b-12d3-a000-000000000000',
                                                'lastModifiedBy': '123e4567-e89b-12d3-a000-000000000000',
                                                'lastModifiedTime': '2014-06-01T03:02:13.552+00:00',
                                                'type': 'IT',
                                                status: 'approved',
                                            },
                                        );
                                    }, [cppwApi]);

                                    return <>
                                        <DefaultFormView formType = {FormType.OrgProfile};
                                    onSubmit = {onSubmit};
                                    errorTitle = 'Ошибка загрузки формы регистрации компании.';
                                    successTitle = 'Регистрация компании прошла успешно!' / >
                                                   </>;;
                                });
                                src / ui / blocks /
                            default
                                -form - view / activity.tsx;
                                import React, {FC, memo, useCallback} from 'react';

                                import {FormType} from 'src/types';
                                import {DefaultFormView} from 'src/ui/blocks/default-form-view/default-form-view';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                export const Activity: FC = memo(() => {
                                    const cppwApi = useCppwApiContext();
                                    const onSubmit = useCallback((req, onSubmit) => {
                                        cppwApi && cppwApi.submitDefaultForm(
                                            req,
                                            onSubmit,
                                            `formatted/${FormType.Activity}/`,
                                            {
                                                course: Number(req.course),
                                            },
                                        );
                                    }, [cppwApi]);

                                    return <>
                                        <DefaultFormView formType = {FormType.Activity};
                                    onSubmit = {onSubmit};
                                    errorTitle = 'Ошибка загрузки формы создания активностей.';
                                    successTitle = 'Активность создана!' / >
                                                   </>;;
                                });
                                src / ui / blocks /
                            default
                                -form - view / signup.tsx;
                                import React, {FC, memo, useCallback} from 'react';
                                import {FormType} from 'src/types';
                                import {DefaultFormView} from 'src/ui/blocks/default-form-view/default-form-view';
                                import {HomePageParagraph} from 'src/ui/blocks/home-page-paragraph/home-page-paragraph';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                export const Signup: FC = memo(() => {
                                    const cppwApi = useCppwApiContext();
                                    const onSubmit = useCallback((req, onSubmit) => {
                                        cppwApi && cppwApi.submitDefaultForm(req, onSubmit, 'signup/student', {
                                            'created_by': '123e4567-e89b-12d3-a000-000000000000',
                                            role: 'student',
                                        });
                                    }, [cppwApi]);

                                    return <>
                                        <HomePageParagraph mode = {1};
                                    title = 'Студентам';
                                    description = 'Для получения фктуальной информации по проектам и практикам на Вашем курсе необходимо Войти или Зарегистрироваться:' / >
                                                  <DefaultFormView formType = {FormType.StudentRegistration};
                                    onSubmit = {onSubmit};
                                    errorTitle = 'Ошибка загрузки формы регистрации.';
                                    successTitle = 'Регистрация прошла успешно!' / >
                                                   </>;;
                                });
                                src / ui / blocks /
                            default
                                -form - view / project.tsx;
                                import React, {FC, memo, useCallback} from 'react';

                                import {FormType} from 'src/types';
                                import {DefaultFormView} from 'src/ui/blocks/default-form-view/default-form-view';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                export const Project: FC = memo(() => {
                                    const cppwApi = useCppwApiContext();
                                    const onSubmit = useCallback((req, onSubmit) => {
                                        cppwApi && cppwApi.submitDefaultForm(
                                            req,
                                            onSubmit,
                                            `formatted/${FormType.Project}/`,
                                            {
                                                status: 'approved',
                                            },
                                        );
                                    }, [cppwApi]);

                                    return <>
                                        <DefaultFormView formType = {FormType.Project};
                                    onSubmit = {onSubmit};
                                    errorTitle = 'Ошибка загрузки формы создания проекта.';
                                    successTitle = 'Проект создан!' / >
                                                   </>;;
                                });
                                src / ui / blocks /
                            default
                                -form - view / help.tsx;
                                import React, {FC, memo, useCallback} from 'react';

                                import {FormType} from 'src/types';
                                import {DefaultFormView} from 'src/ui/blocks/default-form-view/default-form-view';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                export const Help: FC = memo(() => {
                                    const cppwApi = useCppwApiContext();
                                    const onSubmit = useCallback((req, onSubmit) => {}, [cppwApi]);

                                    return <>
                                        <DefaultFormView formType = {FormType.Help};
                                    onSubmit = {onSubmit};
                                    errorTitle = 'Ошибка загрузки формы жалоб и предложений.';
                                    successTitle = 'Спасибо, что делаете нас лучше!' / >
                                                   </>;;
                                });
                                src / ui / blocks /
                            default
                                -form - view / users-registration.tsx;
                                import React, {FC, memo, useCallback} from 'react';
                                import {FormType} from 'src/types';
                                import {DefaultFormView} from 'src/ui/blocks/default-form-view/default-form-view';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                export const UsersRegistration: FC = memo(() => {
                                    const cppwApi = useCppwApiContext();
                                    const onSubmit = useCallback((req, onSubmit) => {}, [cppwApi]);

                                    return <>
                                        <DefaultFormView formType = {FormType.UserRegistration};
                                    onSubmit = {onSubmit};
                                    errorTitle = 'Ошибка загрузки формы регистрации.';
                                    successTitle = 'Регистрация прошла успешно!' / >
                                                   </>;;
                                });
                                src / ui / blocks / tab / tab.tsx;
                                import React, {FC, memo} from 'react';
                                import {Link} from 'react-router-dom';
                                import './tab.styl';

                                type Props = {
                                    link?: string;
                                    title: string;
                                    onClick?: () => void;
                                    isActive: boolean;
                                }

                                export const Tab: FC<Props> = memo(({link, title, onClick, isActive}) => (
                                    <div className = {`tab ${isActive ? '_is-active' : ''}`
                            }
                                onClick = {onClick} >
                                    {
                                        link ? <Link to = {link} className = 'tab__text'
                                        onClick = {onClick} > {title} < /Link> : <div className='tab__text'> {title}</
                                        div >
                            }
                                </div>;
                            ))
                                ;
                                src / ui / blocks / search / search.tsx;
                                import {Classes, InputGroup} from '@blueprintjs/core';
                                import React, {FC, useCallback, useState} from 'react';
                                import './search.styl';

                                type Props = {
                                    className?: string;
                                    component?: any;
                                    searchPropertyName?: string;
                                    items?: any[];
                                }

                                export const Search: FC<Props> = ({className, component: Component, items, searchPropertyName}) => {
                                    const [filter, setFilter] = useState('');
                                    const onChange = useCallback(({target}: any) => {setFilter(String(target.value).toLowerCase());}, [setFilter]);
                                    return (
                                        <>
                                            <InputGroup className = {`${Classes.ROUND} ${Classes.FILL} search ${className ? className : ''}`
                                }
                                    leftIcon = 'search';
                                    value = {filter};
                                    onChange = {onChange};
                                    placeholder = 'Искать...' / >
                                        {
                                            Component && items && searchPropertyName && items.filter((item) => item[searchPropertyName].toLowerCase()
                                                                                                                                       .includes(
                                                                                                                                           filter))
                                                                                             .map((item) => (<Component key = {item[searchPropertyName]}
                                    {...
                                        item;
                                    }
                                    />));
                                }
                                    </>;
                                )
                                    ;
                                };
                                src / ui / blocks / profile - column / profile - column.tsx;
                                import {Icon} from '@blueprintjs/core';
                                import React, {FC, useCallback, useEffect, useMemo, useState} from 'react';
                                import {useDispatch, useSelector} from 'react-redux';
                                import {logout} from 'src/store/actions/user.actions';
                                import {State} from 'src/store/reducers';
                                import {ProfileType, UserRole} from 'src/types';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                import './profile-column.styl';

                                enum PermissionType {
                                    Edit,
                                    Block,
                                    Complaint,
                                    Marks,
                                    Notifications
                                }

                                const getPermission = (type: PermissionType,
                                                       {userRole, profileId, userId, profileType, modifyAllowed}: { userRole?: UserRole, profileId: string, userId?: string, profileType: ProfileType, modifyAllowed: boolean }) => {
                                    switch (type) {
                                        case PermissionType.Edit: {
                                            switch (profileType) {
                                                case ProfileType.Activity: {
                                                    return userRole && [UserRole.Supervisor, UserRole.Manager].includes(userRole);
                                                }
                                                case ProfileType.User: {
                                                    return (userRole && [UserRole.Supervisor,
                                                                         UserRole.Manager].includes(userRole)) || (profileId === userId);
                                                }
                                                case ProfileType.Organisation: {
                                                    return (userRole && [UserRole.Supervisor, UserRole.Manager].includes(userRole)) || modifyAllowed;
                                                }
                                                case ProfileType.Project: {
                                                    return (userRole && [UserRole.Supervisor, UserRole.Manager].includes(userRole)) || modifyAllowed;
                                                }
                                                case ProfileType.ProjectRequest: {
                                                    return (userRole && [UserRole.Supervisor, UserRole.Manager].includes(userRole)) || modifyAllowed;
                                                }
                                                default:
                                                    return false;
                                            }
                                        }
                                        case PermissionType.Block: {
                                            switch (profileType) {
                                                case ProfileType.Organisation:
                                                case ProfileType.User: {
                                                    return userRole === UserRole.Supervisor && profileId !== userId;
                                                }
                                                default:
                                                    return false;
                                            }
                                        }
                                        case PermissionType.Complaint: {
                                            switch (profileType) {
                                                case ProfileType.Organisation:
                                                case ProfileType.User: {
                                                    return userRole !== UserRole.Supervisor && profileId !== userId;
                                                }
                                                default:
                                                    return false;
                                            }
                                        }
                                        case PermissionType.Marks: {
                                            switch (profileType) {
                                                case ProfileType.Activity: {
                                                    return userRole && [UserRole.Supervisor, UserRole.Manager].includes(userRole);
                                                }
                                                case ProfileType.Project: {
                                                    return (userRole && [UserRole.Supervisor, UserRole.Manager].includes(userRole)) || modifyAllowed;
                                                }
                                                default:
                                                    return false;
                                            }
                                        }
                                        case PermissionType.Notifications: {
                                            switch (profileType) {
                                                case ProfileType.User: {
                                                    return userId === profileId;
                                                }
                                                default:
                                                    return false;
                                            }
                                        }
                                        default:
                                            return false;
                                    }
                                };

                                type Props = {
                                    profileType: ProfileType;
                                    id: string;
                                    selectedIndex: number;
                                    setSelectedIndex: (selectedIndex: number) => void;
                                    setIsEditing?: (isEditing: boolean) => void;
                                    isBlocked?: boolean;
                                    setIsBlocked?: (isBlocked: boolean) => void;
                                    modifyAllowed: boolean;
                                }

                                export const ProfileColumn: FC<Props> = ({
                                                                             selectedIndex,
                                                                             setSelectedIndex,
                                                                             profileType,
                                                                             setIsEditing,
                                                                             id,
                                                                             setIsBlocked,
                                                                             isBlocked,
                                                                             modifyAllowed,
                                                                         }) => {
                                    const {userId: selfUserId, role} = useSelector((state: State) => 'userId' in state.user
                                                                                                     ? state.user
                                                                                                     : {userId: undefined, role: undefined});
                                    const dispatch = useDispatch();
                                    const cppwApi = useCppwApiContext();
                                    const [isMenuOpen, setIsMenuOpen] = useState(false);
                                    const onIconClick = useCallback(() => {
                                        if (selectedIndex === 0) {
                                            setIsMenuOpen(!isMenuOpen);
                                        }
                                    }, [selectedIndex, isMenuOpen]);
                                    const select0 = useCallback(() => {setSelectedIndex(0);}, [setSelectedIndex]);
                                    const select1 = useCallback(() => {setSelectedIndex(1);}, [setSelectedIndex]);
                                    const select2 = useCallback(() => {setSelectedIndex(2);}, [setSelectedIndex]);
                                    const permissionOptions = useMemo(() => ({
                                        userRole: role,
                                        profileId: id,
                                        userId: selfUserId,
                                        profileType,
                                        modifyAllowed,
                                    }), [role, id, selfUserId, profileType, modifyAllowed]);
                                    const options = useMemo(() => [
                                        {
                                            title: 'Редактировать',
                                            onClick: () => {
                                                setIsEditing && setIsEditing(true);
                                            },
                                            shouldShow: getPermission(PermissionType.Edit, permissionOptions),
                                        },
                                        {
                                            title: isBlocked ? 'Разблокировать' : 'Заблокировать',
                                            onClick: () => {
                                                if (setIsBlocked) {
                                                    if (isBlocked) {
                                                        cppwApi && cppwApi.unblockProfile(id, profileType, () => {setIsBlocked(false);});
                                                    } else {
                                                        cppwApi && cppwApi.blockProfile(id, profileType, () => {setIsBlocked(true);});
                                                    }
                                                }
                                            },
                                            shouldShow: getPermission(PermissionType.Block, permissionOptions),
                                        },
                                        {
                                            title: 'Пожаловаться',
                                            onClick: () => {
                                                cppwApi && cppwApi.complaintProfile(id, profileType);
                                            },
                                            shouldShow: getPermission(PermissionType.Complaint, permissionOptions),
                                        },
                                        {
                                            title: 'Выйти',
                                            onClick: () => {
                                                dispatch(logout());
                                            },
                                            shouldShow: id === selfUserId,
                                        },
                                    ], [role, profileType, isBlocked, setIsBlocked, cppwApi, dispatch, id, selfUserId, setIsEditing]);

                                    useEffect(() => {
                                        setIsMenuOpen(false);
                                    }, [selectedIndex]);
                                    return (

                                        <>
                                            <div className = {`profile-column ${selectedIndex === 0 ? '_is-active' : ''}`
                                }
                                    key = {0};
                                    onClick = {select0} >
                                                        <div className = 'profile-column__text' > Профиль < /div>
                                                                         < Icon;
                                    icon = 'chevron-down';
                                    className = 'profile-column__right-icon';
                                    onClick = {onIconClick};
                                    />
                                    < /div>;
                                    {
                                        selectedIndex === 0 && <div className = {`profile-column__menu ${isMenuOpen ? '_opened' : ''}`;
                                    }>
                                        {
                                            options.map(({title, onClick, shouldShow}) => {
                                                if (shouldShow) {
                                                    return <div key = {title};
                                                    className = 'profile-column__menu-item';
                                                    onClick = {onClick} >
                                                        {title}
                                                                        < /div>;;
                                                }
                                                return null;
                                            });
                                        }
                                        </div>};
                                        {
                                            getPermission(PermissionType.Notifications, permissionOptions) && <div
                                                className = {`profile-column ${selectedIndex === 1 ? '_is-active' : ''}`;
                                        }
                                            key = {1};
                                            onClick = {select1} >
                                                                <div className = 'profile-column__text' > Нотификации < /div>
                                                                                 < /div>;
                                        }
                                        {
                                            getPermission(PermissionType.Marks,
                                                          permissionOptions) && <div className = {`profile-column ${selectedIndex === 2
                                                                                                                    ? '_is-active'
                                                                                                                    : ''}`;
                                        }
                                            key = {2};
                                            onClick = {select2} >
                                                                <div className = 'profile-column__text' > Ведомость < /div>
                                                                                 < /div>;
                                        }
                                        </>;
                                    )
                                    ;
                                };
                                src / ui / blocks / search - buttons / search - buttons.tsx;
                                import {
                                    Button,
                                    ButtonGroup,
                                    IconName,
                                    Intent,
                                    Menu,
                                    MenuDivider,
                                    MenuItem,
                                    Popover,
                                    Position,
                                } from '@blueprintjs/core';
                                import React, {FC, useMemo} from 'react';
                                import {Link} from 'react-router-dom';
                                import {CppwApi, formSearchUrl} from 'src/api/api';
                                import {changeUserFormMode} from 'src/store/actions/user-forms.actions';
                                import {Attribute, FormMode, ProfileOrSearchItem, SearchType} from 'src/types';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                import {BACKEND_URL, DEFAULT_CHAT_ID} from 'src/ui/utils/constants';
                                import './search-buttons.styl';

                                enum ButtonType {
                                    Link = 'link',
                                    Button = 'button',
                                    Menu = 'menu',
                                    Divider = 'divider',
                                }

                                type ButtonDescriber =
                                    | {
                                          type: ButtonType.Link;
                                          href: string;
                                          icon: IconName;
                                          title: string;
                                          download?: true;
                                      }
                                    | {
                                          type: ButtonType.Menu,
                                          icon: IconName;
                                          title: string;
                                          items: ButtonDescriber[]
                                      }
                                    | {
                                          type: ButtonType.Button;
                                          onClick: (records: ProfileOrSearchItem[], cppwApi?: CppwApi) => void;
                                          icon: IconName;
                                          title: string;
                                      }
                                    | {
                                          type: ButtonType.Divider,
                                      }

                                export const SEARCH_TYPE_TO_BUTTONS_MAP: { [k in SearchType]?: ButtonDescriber[] } = {
                                    [SearchType.Projects]: [
                                        {
                                            type: ButtonType.Menu,
                                            icon: 'timeline-bar-chart',
                                            title: 'Отчеты',
                                            items: [
                                                {
                                                    type: ButtonType.Link,
                                                    title: 'Скачать описание всех проектов (одним файлом)',
                                                    icon: 'folder-shared',
                                                    href: `${BACKEND_URL}/api/v1/report/project/profile`,
                                                    download: true,
                                                },
                                                {
                                                    type: ButtonType.Link,
                                                    title: 'Скачать описание всех проектов (по файлу на проект)',
                                                    icon: 'folder-shared',
                                                    href: `${BACKEND_URL}/api/v1/report/project/profile`,
                                                    download: true,
                                                },
                                                {
                                                    type: ButtonType.Divider,
                                                },
                                                {
                                                    type: ButtonType.Link,
                                                    title: 'Анализ распределения проектов по компаниям',
                                                    icon: 'folder-shared',
                                                    href: `${BACKEND_URL}/api/v1/report/project/profile`,
                                                    download: true,
                                                },
                                                {
                                                    type: ButtonType.Link,
                                                    title: 'Анализ количества проектов по курсам',
                                                    icon: 'folder-shared',
                                                    href: `${BACKEND_URL}/api/v1/report/project/profile`,
                                                    download: true,
                                                },
                                            ],
                                        },
                                    ],
                                    [SearchType.Students]: [
                                        {
                                            type: ButtonType.Button,
                                            onClick: (records, cppwApi) => {
                                                // TODO добавлять в список чатов в редаксе
                                                cppwApi && cppwApi.saveChat(-1,
                                                                            {id: DEFAULT_CHAT_ID, name: 'Новая группа контактов', users: records},
                                                                            [],
                                                                            () => {
                                                                                cppwApi && cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                                                    {
                                                                                        icon: 'tick',
                                                                                        intent: Intent.SUCCESS,
                                                                                        message: 'Новая группа контактов успешно создана',
                                                                                    },
                                                                                );
                                                                            });
                                            },
                                            icon: 'plus',
                                            title: 'Создать группу контактов',
                                        },
                                    ],
                                    [SearchType.Mentors]: [
                                        {
                                            type: ButtonType.Button,
                                            onClick: (records, cppwApi) => {
                                                // TODO не дать пользователю заспамить нас запросами
                                                // TODO добавлять в список чатов в редаксе
                                                cppwApi && cppwApi.saveChat(-1,
                                                                            {id: DEFAULT_CHAT_ID, name: 'Новая группа контакто', users: records},
                                                                            [],
                                                                            () => {
                                                                                cppwApi && cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                                                    {
                                                                                        icon: 'tick',
                                                                                        intent: Intent.SUCCESS,
                                                                                        message: 'Новая группа контактов успешно создана',
                                                                                    },
                                                                                );
                                                                            });
                                            },
                                            icon: 'plus',
                                            title: 'Создать группу контактов',
                                        },
                                    ],
                                    [SearchType.Questionnaire]: [
                                        {
                                            type: ButtonType.Button,
                                            onClick: (records, cppwApi) => {
                                                if (!cppwApi) {
                                                    return;
                                                }
                                                const state = cppwApi.store.getState();

                                                // TODO костыльненько, выпилить бы
                                                const {id, index} = state.userForms.forms.reduce((currentResult: { id: string, index: number },
                                                                                                  {id, stats},
                                                                                                  index) => {
                                                    if (!stats) {
                                                        return currentResult;
                                                    }
                                                    const {records: formRecords} = stats;
                                                    if (records === formRecords) {
                                                        return {
                                                            index,
                                                            id,
                                                        };
                                                    }
                                                    return currentResult;
                                                }, {id: '', index: -1});

                                                if (id) {
                                                    cppwApi.getFormStats(index, id);
                                                } else {
                                                    cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                        {
                                                            icon: 'error',
                                                            intent: Intent.DANGER,
                                                            message: 'Ошибка!',
                                                        },
                                                    );
                                                }
                                            },
                                            icon: 'refresh',
                                            title: 'Обновить',
                                        },
                                        {
                                            type: ButtonType.Button,
                                            onClick: (records, cppwApi) => {
                                                if (!cppwApi) {
                                                    return;
                                                }
                                                const state = cppwApi.store.getState();

                                                // TODO костыльненько, выпилить бы
                                                const {id, index} = state.userForms.forms.reduce((currentResult: { id: string, index: number },
                                                                                                  {id, stats},
                                                                                                  index) => {
                                                    if (!stats) {
                                                        return currentResult;
                                                    }
                                                    const {records: formRecords} = stats;
                                                    if (records === formRecords) {
                                                        return {
                                                            index,
                                                            id,
                                                        };
                                                    }
                                                    return currentResult;
                                                }, {id: '', index: -1});

                                                if (id) {
                                                    cppwApi.store.dispatch(changeUserFormMode(index, FormMode.View));
                                                } else {
                                                    cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                        {
                                                            icon: 'error',
                                                            intent: Intent.DANGER,
                                                            message: 'Ошибка!',
                                                        },
                                                    );
                                                }
                                            },
                                            icon: 'cross',
                                            title: 'Закрыть',
                                        },
                                    ],
                                };

                                const renderMenu = ({title, icon, items}: { title: string, icon: IconName, items: ButtonDescriber[] },
                                                    ind: number,
                                                    reportParams: string) => {
                                    const menu = (
                                        <Menu key = {ind} >
                                            {
                                                items.map(
                                                    (item: ButtonDescriber, i: number) => {
                                                        switch (item.type) {
                                                            case ButtonType.Link: {
                                                                return <MenuItem text = {item.title};
                                                                key = {i};
                                                                icon = {item.icon};
                                                                href = {`${item.href}${item.download ? reportParams : ''}`;
                                                            }
                                                                download = {item.download};
                                                                />;;
                                                            }
                                                            case ButtonType.Divider: {
                                                                return <MenuDivider key = {i};
                                                                />;;
                                                            }
                                                            default: {
                                                                return null;
                                                            }
                                                        }
                                                    },
                                                ),
                                            }
                                                          < /Menu>
                                    );
                                    return (
                                        <Popover content = {menu}
                                    position = {Position.BOTTOM_LEFT} >
                                                                      <Button rightIcon = 'caret-down';
                                    icon = {icon};
                                    text = {title};
                                    />
                                    < /Popover>;
                                )
                                    ;
                                };

                                type Props = {
                                    searchType: SearchType;
                                    records: ProfileOrSearchItem[];
                                    fields: Attribute[];
                                };
                                export const SearchButtons: FC<Props> = ({searchType, records, fields}) => {
                                    const cppwApi = useCppwApiContext();
                                    const items: ButtonDescriber[] | undefined = SEARCH_TYPE_TO_BUTTONS_MAP[searchType];
                                    const reportParams = useMemo(() => {
                                        return `${formSearchUrl(fields)}&fields=${fields.filter(({isAdded}) => isAdded)
                                                                                        .map(({realName, name}) => realName ? realName : name)
                                                                                        .join(',')}`;
                                    }, [fields]);

                                    if (!items) {
                                        return null;
                                    }

                                    return (
                                        <ButtonGroup className = 'search-buttons' >
                                            {
                                                items.map(
                                                    (item: ButtonDescriber, ind: number) => {
                                                        switch (item.type) {
                                                            case ButtonType.Link: {
                                                                return <Link to = {`${item.href}${item.download ? reportParams : ''}`;
                                                            }
                                                                key = {ind} >
                                                                            <Button icon = {item.icon};
                                                                text = {item.title};
                                                                />
                                                                < /Link>;;
                                                            }
                                                            case ButtonType.Button: {
                                                                return <Button icon = {item.icon};
                                                                key = {ind};
                                                                text = {item.title};
                                                                onClick = {();
                                                            =>
                                                                item.onClick(records, cppwApi);
                                                            }
                                                                />;;
                                                            }
                                                            case ButtonType.Menu: {
                                                                return renderMenu(item, ind, reportParams);
                                                            }
                                                            default: {
                                                                return null;
                                                            }
                                                        }
                                                    },
                                                ),
                                            }
                                                                 < /ButtonGroup>
                                    );
                                };
                                src / ui / blocks / hint - label / hint - label.tsx;
                                import {Icon, Position, Tooltip} from '@blueprintjs/core';

                                import React, {FC, memo} from 'react';
                                import './hint-label.styl';

                                type Props = {
                                    text: string;
                                }

                                export const HintLabel: FC<Props> = memo(({text}) => (
                                    <span style = {
                                {
                                    display: 'inline-block', margin;
                                :
                                    '0px 5px';
                                }
                            }>
                                <Tooltip
                                    content = { < div;
                                className = 'hint-label' > {text} < /div>};
                                position = {Position.RIGHT};
                                usePortal = {false}
                                >
                                <Icon icon = 'help' / >
                                             </Tooltip>
                                             < /span>;
                            ))
                                ;
                                src / ui / blocks / attribute - card / attribute - card.tsx;
                                import {Card, Icon} from '@blueprintjs/core';

                                import React, {FC, memo} from 'react';
                                import './attribute-card.styl';

                                type Props = {
                                    name?: string;
                                    description?: string;
                                    onClick: () => void;
                                    isPlaceholder?: boolean;
                                }
                                export const AttributeCard: FC<Props> = memo(({name, description, onClick, isPlaceholder}) => {
                                    if (isPlaceholder) {
                                        return (
                                            <Card className = 'attribute-card _placeholder'
                                        onClick = {onClick} >
                                                            <Icon icon = 'plus' / >
                                                                         </Card>;
                                    )
                                        ;
                                    }
                                    return (
                                        <Card className = 'attribute-card'
                                    onClick = {onClick} >
                                                        <div className = 'attribute-card__title' > {name} < /div>;
                                    {
                                        description && <div className = 'attribute-card__description' > {description} < /div>}
                                                                        < /Card>;
                                    )
                                    ;
                                });
                                src / ui / blocks / profile / profile.tsx;
                                import {Icon, IconName, Position, Tooltip} from '@blueprintjs/core';
                                import {Intent} from '@blueprintjs/core/lib/esm/common/intent';
                                import React, {FC, useCallback, useEffect, useReducer, useState} from 'react';
                                import {
                                    AsyncStatus,
                                    Attribute,
                                    AttributeValue,
                                    FormMode,
                                    FormType,
                                    ProfileStatus,
                                    ProfileType,
                                    ProjectRequestStatus,
                                    Usage,
                                    UserRole,
                                } from 'src/types';
                                import {FormLayout} from 'src/ui/blocks/form-layout/form-layout';
                                import {HomePageParagraph} from 'src/ui/blocks/home-page-paragraph/home-page-paragraph';
                                import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                                import {ProfileLists} from 'src/ui/blocks/profile-lists/profile-lists';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                import {getFormattedStringOrLinkValue} from 'src/ui/utils/get-formatted-attribute-value';
                                import './profile.styl';

                                const renderTooltip = ({content, intent, icon}: { content: string, intent: Intent, icon: IconName }) => (
                                    <Tooltip content = {content}
                                position = {Position.RIGHT};
                                intent = {intent} >
                                                  <Icon icon = {icon};
                                className = 'profile__title-icon';
                                intent = {intent};
                                iconSize = {30};
                                />
                                < /Tooltip>;
                            )
                                ;
                                const TITLES = {
                                    [ProfileType.User]: 'Профиль пользователя',
                                    [ProfileType.Organisation]: 'Профиль организации',
                                    [ProfileType.Activity]: 'Профиль активности',
                                    [ProfileType.Project]: 'Профиль проекта',
                                    [ProfileType.ProjectRequest]: 'Заявка на проект',
                                };

                                type ProfileState = {
                                    reqStatus: AsyncStatus;
                                    hasWarning: boolean;
                                    role?: UserRole;
                                    status: ProfileStatus;
                                    fields: Attribute[];
                                    // Comments, Stages or Posts
                                    firstList: any[];
                                    fieldsUserId: string;
                                    schemaContentId: string;
                                }
                                const initialState: ProfileState = {
                                    reqStatus: AsyncStatus.Initial,
                                    hasWarning: false,
                                    role: UserRole.Initial,
                                    status: ProfileStatus.Active,
                                    fields: [],
                                    firstList: [],
                                    fieldsUserId: '',
                                    schemaContentId: '',
                                };
                                const SET_NEW_INFO = 'SET_NEW_INFO';
                                const reducer = (state: any, action: { type: string, payload: any }) => {
                                    switch (action.type) {
                                        case SET_NEW_INFO:
                                            return {...state, ...action.payload};
                                        default:
                                            return state;
                                    }
                                };

                                type Props = {
                                    id: string;
                                    profileType: ProfileType;
                                    modifyAllowed: boolean;
                                    setModifyAllowed: (modifyAllowed: boolean) => void;
                                    isEditing: boolean;
                                    setIsEditing: (isEditing: boolean) => void;
                                    isBlocked: boolean;
                                    setIsBlocked: (isBlocked: boolean) => void;
                                };
                                export const Profile: FC<Props> = ({
                                                                       id,
                                                                       profileType,
                                                                       setIsEditing,
                                                                       isEditing,
                                                                       setIsBlocked,
                                                                       isBlocked,
                                                                       modifyAllowed,
                                                                       setModifyAllowed,
                                                                   }) => {
                                    const cppwApi = useCppwApiContext();

                                    const [profileState, dispatch] = useReducer(reducer, initialState);
                                    const {firstList, reqStatus, hasWarning, fields, fieldsUserId, schemaContentId} = profileState;
                                    // для профиля пользователя - роль, для заявки на проект - статус.
                                    const [info, setInfo] = useState<any>('');

                                    const [errors, setErrors] = useState();

                                    const onSave = useCallback((values, attributes) => {
                                        const req = attributes.reduce((res: { [k: string]: AttributeValue }, attribute: Attribute, index: number) => {
                                            const {name, usage, realName} = attribute;
                                            const value = values[index];

                                            if (realName) {
                                                // поле статическое
                                                if (usage === Usage.Number) {
                                                    res[realName] = parseFloat(value);
                                                } else if (usage === Usage.Checkbox) {
                                                    res[realName] = JSON.stringify(value);
                                                } else {
                                                    res[realName] = value;
                                                }
                                                return res;
                                            } else {
                                                // поле динамическое
                                                res.schemaContent[name] = value;
                                                return res;
                                            }
                                        }, {schemaContent: {}});

                                        cppwApi && cppwApi.saveProfile(id, profileType, {...req, schemaContent: JSON.stringify(req.schemaContent)})
                                                          .then(() => {
                                                              dispatch({
                                                                           type: SET_NEW_INFO,
                                                                           payload: {
                                                                               fields: attributes.map((attribute: Attribute, index: number) => ({
                                                                                   ...attribute,
                                                                                   defaultValue: values[index],
                                                                               })),
                                                                               hasWarning: false,
                                                                           },
                                                                       });
                                                              setIsEditing(false);
                                                          })
                                                          .catch(() => {
                                                              cppwApi && cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                                  {
                                                                      icon: 'error',
                                                                      intent: Intent.DANGER,
                                                                      message: 'Ошибка сохранения профиля.',
                                                                  },
                                                              );
                                                          });
                                    }, [id, profileType, cppwApi, setIsEditing]);
                                    const onCancel = useCallback(() => {
                                        setIsEditing(false);
                                    }, [setIsEditing]);

                                    useEffect(() => {
                                        if (reqStatus === AsyncStatus.Initial || (
                                            reqStatus !== AsyncStatus.Pending && fieldsUserId !== id
                                        )) {
                                            cppwApi && cppwApi.getProfile(id,
                                                                          profileType,
                                                                          () => {
                                                                              dispatch({
                                                                                           type: SET_NEW_INFO,
                                                                                           payload: {
                                                                                               hasWarning: false,
                                                                                               reqStatus: AsyncStatus.Pending,
                                                                                               fieldsUserId: id,
                                                                                           },
                                                                                       });
                                                                          },
                                                                          (result,
                                                                           fields,
                                                                           info,
                                                                           firstList,
                                                                           hasWarning,
                                                                           status,
                                                                           schemaContentId,
                                                                           modifyAllowed) => {
                                                                              dispatch({
                                                                                           type: SET_NEW_INFO,
                                                                                           payload: {
                                                                                               hasWarning,
                                                                                               reqStatus: AsyncStatus.Success,
                                                                                               fields,
                                                                                               firstList,
                                                                                               schemaContentId,
                                                                                           },
                                                                                       });
                                                                              setIsBlocked(status === ProfileStatus.Blocked);
                                                                              setModifyAllowed(modifyAllowed);
                                                                              setInfo(info);
                                                                          },
                                                                          () => {
                                                                              dispatch({
                                                                                           type: SET_NEW_INFO,
                                                                                           payload: {
                                                                                               reqStatus: AsyncStatus.Error,
                                                                                           },
                                                                                       });
                                                                          },
                                            );
                                        }
                                    }, [setIsBlocked, hasWarning, cppwApi, id, reqStatus, profileType, fieldsUserId, setModifyAllowed]);

                                    return <LoadableView status = {reqStatus};
                                    errorTitle = {'Ошибка загрузки профиля'};
                                    spinnerClassName = 'spinner-full-height' >
                                                       <div className = 'profile' >
                                        {
                                            isEditing ? (
                                                            <>
                                                                <FormLayout id = {id}
                                                // Ставим какой-то, чтобы удовлетворить TS. Использоваться не будет.
                                                        type = {FormType.Questionnaire}
                                            title = {'Редактирование профиля'}
                                            attributes = {fields.filter(({usage}: Attribute) => !!usage)}
                                            mode = {FormMode.Fill}
                                            buttonName = 'Сохранить'
                                            errors = {errors}
                                            onFormSubmit = {onSave}
                                            onSetError = {setErrors}
                                            handleCancel = {onCancel}
                                            index = { - 1,
                                        };
                                    />
                                    < />;
                                ) :
                                    (
                                        <>
                                            <div className = 'profile__title' >
                                                             <HomePageParagraph title = {TITLES[profileType]}
                                    mode = {1};
                                    />;
                                    {
                                        hasWarning && !isBlocked && <Tooltip content = 'Необходимо отредактировать профиль.';
                                        position = {Position.RIGHT};
                                        intent = {Intent.WARNING} >
                                                                  <Icon icon = 'warning-sign';
                                        className = 'profile__title-icon';
                                        intent = {Intent.WARNING};
                                        iconSize = {30};
                                        />
                                        < /Tooltip>;
                                    }
                                    {
                                        isBlocked ? renderTooltip({content: 'Профиль заблокирован', intent: Intent.DANGER, icon: 'error'}) :
                                        profileType === ProfileType.ProjectRequest && renderTooltip(
                                            {content: 'Заявка подтверждена!', intent: Intent.SUCCESS, icon: 'tick-circle'});
                                    }

                                    </div>;
                                    {
                                        fields.map(({title, defaultValue, usage, name}: Attribute) => {
                                            const value = !defaultValue || usage === Usage.Stage ? '' : getFormattedStringOrLinkValue(defaultValue,
                                                                                                                                      usage);
                                            if (!value) {
                                                return null;
                                            }

                                            return <div className = 'profile__item';
                                            key = {name} >
                                                         <div className = 'profile__item-title' > {title};
                                        :
                                            </div>
                                            < div;
                                            className = 'profile__item-value' > {value} < /div>
                                                        < /div>;;
                                        });
                                    }
                                    <ProfileLists profileType = {profileType};
                                    id = {id};
                                    info = {info};
                                    firstList = {firstList};
                                    setInfo = {setInfo};
                                    schemaContentId = {schemaContentId};
                                    modifyAllowed = {modifyAllowed};
                                    />
                                    < />;
                                )
                                }
                                    </div>
                                    < /LoadableView>;;
                                };
                                src / ui / blocks / table / table.tsx;
                                import {ContextMenu, Intent, Menu, MenuItem} from '@blueprintjs/core';
                                import React, {CSSProperties, FC, memo, MouseEvent, useCallback, useEffect, useMemo, useRef, useState} from 'react';
                                import AutoSizer from 'react-virtualized-auto-sizer';
                                import {VariableSizeGrid as Grid} from 'react-window';
                                import {ColumnHeader, SortKind} from 'src/ui/blocks/table/column-header';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                import {Clipboard} from 'src/ui/utils/clipboard';
                                import {throttle} from 'src/ui/utils/throttle';
                                import './table.styl';

                                const DEFAULT_ROW_HEIGHT = 20;
                                const MIN_COLUMN_WIDTH = 70;

                                type Props = {
                                    columnWidths: number[];
                                    rowCount: number;
                                    getCellData: (columnIndex: number, rowIndex: number) => string
                                    getCellElement: (columnIndex: number, rowIndex: number) => string | JSX.Element;
                                    onColumnsReordered: (oldIndex: number, newIndex: number) => void;
                                    onColumnWidthChange: (columnIndex: number, newWidth: number) => void;
                                    onColumnSorted: (columnIndex: number, ascending: boolean) => void;
                                    className: string;
                                };
                                type SelectedCell = { row: number, column: number };
                                type PortalParams = {
                                    style: CSSProperties;
                                    start: SelectedCell;
                                    end: SelectedCell;
                                }
                                type PartialPortalParams = {
                                    style: CSSProperties;
                                    start: SelectedCell;
                                }
                                export const Table: FC<Props> = memo(({columnWidths, rowCount, getCellElement, getCellData, onColumnsReordered, onColumnWidthChange, className, onColumnSorted}) => {
                                    const cppwApi = useCppwApiContext();
                                    const columnCount = columnWidths.length - 1;

                                    const [portalParams, setPortalParams] = useState<PortalParams>({
                                                                                                       style: {
                                                                                                           top: -10,
                                                                                                           height: 0,
                                                                                                           left: -10,
                                                                                                           width: 0,
                                                                                                       },
                                                                                                       start: {row: -1, column: -1},
                                                                                                       end: {row: -1, column: -1},
                                                                                                   });
                                    const [draggablePortalParams, setDraggablePortalParams] = useState<PartialPortalParams>({
                                                                                                                                style: {
                                                                                                                                    top: 0,
                                                                                                                                    left: 0,
                                                                                                                                },
                                                                                                                                start: {
                                                                                                                                    row: 0,
                                                                                                                                    column: 0,
                                                                                                                                },
                                                                                                                            });
                                    // selected column to drag
                                    const [selectedColumn, setSelectedColumn] = useState(0);

                                    const [sortedColumn, setSortedColumn] = useState(0);  // positive for ascending order, negative for descending

                                    const [, setIsContextMenuOpen] = useState(false);

                                    const [resizingState, setResizingState] = useState({
                                                                                           column: 0,
                                                                                           initialX: 0,
                                                                                           initialPortalPosition: 0,
                                                                                           initialWidth: 0,
                                                                                       });

                                    const gridRef = useRef<any>(null);
                                    const portalParamsRef = useRef<PartialPortalParams | null>(null);

                                    const rowHeights = useMemo(() => ([30, ...new Array(rowCount).fill(DEFAULT_ROW_HEIGHT)]), [rowCount]);
                                    const fullHeight = useMemo(() => rowHeights.reduce((a, b) => a + b), [rowHeights]);
                                    const wrapperStyle = useMemo(() => {
                                        if (window.innerWidth <= 800) {
                                            return {height: Math.min(fullHeight, window.innerHeight)};
                                        }
                                        return undefined;
                                    }, [fullHeight]);

                                    const onCopy = useCallback(() => {
                                        const sparse: string[][] = [];
                                        const firstRow = Math.min(portalParams.start.row, portalParams.end.row);
                                        const lastRow = Math.max(portalParams.start.row, portalParams.end.row);
                                        const firstColumn = Math.min(portalParams.start.column, portalParams.end.column);
                                        const lastColumn = Math.max(portalParams.start.column, portalParams.end.column);
                                        if (firstRow < 0 || firstColumn < 0) {
                                            cppwApi && cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                {
                                                    icon: 'error',
                                                    intent: Intent.WARNING,
                                                    message: 'Необходимо выделить область копирования.',
                                                },
                                            );
                                            return;
                                        }
                                        for (let i = firstRow; i <= lastRow; i++) {
                                            sparse.push([]);
                                            for (let j = firstColumn; j <= lastColumn; j++) {
                                                if (j === 0) {
                                                    continue;
                                                }
                                                sparse[sparse.length - 1].push(getCellData(j, i));
                                            }
                                        }
                                        const success = Clipboard.copyCells(sparse);
                                        if (!success) {
                                            cppwApi && cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                {
                                                    icon: 'error',
                                                    intent: Intent.DANGER,
                                                    message: 'Ошибка копирования.',
                                                },
                                            );
                                        } else {
                                            cppwApi && cppwApi.toaster.current && cppwApi.toaster.current.show(
                                                {
                                                    icon: 'tick',
                                                    intent: Intent.SUCCESS,
                                                    message: 'Копирование выполнено успешно!',
                                                },
                                            );
                                        }
                                    }, [cppwApi, getCellData, portalParams]);
                                    const showContextMenu = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
                                        e.preventDefault();
                                        ContextMenu.show(
                                            <Menu>
                                                <MenuItem text = 'Копировать'
                                        onClick = {onCopy};
                                        />
                                        < /Menu>,;
                                        {
                                            left: e.clientX, top;
                                        :
                                            e.clientY;
                                        }
                                    ,
                                        () => setIsContextMenuOpen(false),
                                    )
                                        ;
                                        setIsContextMenuOpen(true);
                                    }, [onCopy, setIsContextMenuOpen]);
                                    const setDragDestination = useCallback((columnIndex: number) => {
                                        if (columnIndex > selectedColumn) {
                                            columnIndex--;
                                        }
                                        if (selectedColumn && columnIndex !== draggablePortalParams.start.column) {
                                            setDraggablePortalParams({
                                                                         style: {
                                                                             top: 0,
                                                                             left: columnWidths.slice(0,
                                                                                                      columnIndex + (columnIndex > selectedColumn
                                                                                                                     ? 1
                                                                                                                     : 0)).reduce((a: number,
                                                                                                                                   b: number) => a + b),
                                                                             width: 0,
                                                                             height: fullHeight,
                                                                         },
                                                                         start: {
                                                                             row: 0,
                                                                             column: columnIndex,
                                                                         },
                                                                     });
                                        }
                                    }, [columnWidths, setDraggablePortalParams, selectedColumn, draggablePortalParams.start.column, fullHeight]);
                                    const Cell = useCallback(({columnIndex, rowIndex, style}: { columnIndex: number, rowIndex: number, style: CSSProperties }) => {
                                                                 const reorder = () => {
                                                                     if (selectedColumn) {
                                                                         const nextColumn = draggablePortalParams.start.column;
                                                                         onColumnsReordered(selectedColumn, nextColumn);
                                                                         let newLeft = 0;
                                                                         for (let i = 0; i <= nextColumn; i++) {
                                                                             newLeft += (i === selectedColumn) ? 0 : columnWidths[i];
                                                                         }

                                                                         setPortalParams({
                                                                                             style: {
                                                                                                 ...portalParams.style,
                                                                                                 left: (selectedColumn < nextColumn)
                                                                                                       ? newLeft
                                                                                                       : draggablePortalParams.style.left,
                                                                                             },
                                                                                             start: {
                                                                                                 row: 0,
                                                                                                 column: nextColumn,
                                                                                             },
                                                                                             end: {
                                                                                                 row: rowCount,
                                                                                                 column: nextColumn,
                                                                                             },
                                                                                         });
                                                                         setSelectedColumn(0);
                                                                     }
                                                                 };
                                                                 const onMouseMove = (e: MouseEvent<HTMLDivElement, any>) => {
                                                                     const columnToInsert = columnIndex + (
                                                                         e.nativeEvent.offsetX > columnWidths[columnIndex] / 2 ? 1 : 0);
                                                                     setDragDestination(columnToInsert);
                                                                 };
                                                                 const reshapePortal = (e: MouseEvent<HTMLDivElement, any>, shouldStop: boolean = false) => {
                                                                     if (e.button !== 0 || !portalParamsRef.current) {  // if user has already started selecting an area, do not start over
                                                                         return;
                                                                     }

                                                                     let {top, left, width, height} = e.currentTarget.style;
                                                                     setTimeout(() => {
                                                                         if (!portalParamsRef.current) {
                                                                             return;
                                                                         }
                                                                         const startTop = Number(portalParamsRef.current.style.top);
                                                                         const startLeft = Number(portalParamsRef.current.style.left);
                                                                         const startWidth = Number(portalParamsRef.current.style.width);
                                                                         const startHeight = Number(portalParamsRef.current.style.height);

                                                                         const start = portalParamsRef.current.start;
                                                                         if (shouldStop) {
                                                                             portalParamsRef.current = null;
                                                                         }
                                                                         setPortalParams({
                                                                                             style: {
                                                                                                 top: Math.min(startTop, parseFloat(top)),
                                                                                                 left: Math.min(startLeft, parseFloat(left)),
                                                                                                 width: Math.abs(startLeft - parseFloat(left)) + (parseFloat(left) > startLeft
                                                                                                                                                  ? parseFloat(width)
                                                                                                                                                  : startWidth),
                                                                                                 height: Math.abs(startTop - parseFloat(top)) + (parseFloat(top) > startTop
                                                                                                                                                 ? parseFloat(height)
                                                                                                                                                 : startHeight),
                                                                                             },
                                                                                             start: start,
                                                                                             end: {
                                                                                                 row: rowIndex,
                                                                                                 column: columnIndex,
                                                                                             },
                                                                                         });
                                                                     }, 0);
                                                                 };

                                                                 // Это хедер ряда
                                                                 if (!columnIndex) {
                                                                     return (
                                                                         <div style = {style}
                                                                     className = {`table__header ${rowIndex ? 'table__row-header' : 'table__common-header'}`;
                                                                 }
                                                                     onMouseDown = {(e);
                                                                 =>
                                                                     {
                                                                         e.preventDefault();
                                                                     }
                                                                 }
                                                                     onClick = {(e);
                                                                 =>
                                                                     {
                                                                         reorder();
                                                                         const {top, left} = e.currentTarget.style;
                                                                         if (rowIndex) {
                                                                             // Выделяем ряд
                                                                             setPortalParams({
                                                                                                 style: {
                                                                                                     top: parseFloat(top),
                                                                                                     left: parseFloat(left),
                                                                                                     width: columnWidths.reduce((a: number, b: number) => a + b),
                                                                                                     height: rowHeights[rowIndex],
                                                                                                 },
                                                                                                 start: {
                                                                                                     row: rowIndex,
                                                                                                     column: 0,
                                                                                                 },
                                                                                                 end: {
                                                                                                     row: rowIndex,
                                                                                                     column: columnCount,
                                                                                                 },
                                                                                             });
                                                                         } else {
                                                                             // Выделяем всю таблицу
                                                                             setPortalParams({
                                                                                                 style: {
                                                                                                     top: parseFloat(top),
                                                                                                     left: parseFloat(left),
                                                                                                     width: columnWidths.reduce((a: number, b: number) => a + b),
                                                                                                     height: rowHeights.reduce((a: number, b: number) => a + b),
                                                                                                 },
                                                                                                 start: {
                                                                                                     row: rowIndex,
                                                                                                     column: 0,
                                                                                                 },
                                                                                                 end: {
                                                                                                     row: rowCount,
                                                                                                     column: columnCount,
                                                                                                 },
                                                                                             });
                                                                         }
                                                                     }
                                                                 }
                                                                 >
                                                                     {
                                                                         rowIndex || <>
                                                                             <div className = 'table__portal';
                                                                         style = {portalParams.style};
                                                                         />;
                                                                         {
                                                                             (Boolean(selectedColumn) || Boolean(resizingState.column)) && <div className = 'table__portal';
                                                                             style = {draggablePortalParams.style};
                                                                             />}
                                                                             < />}
                                                                             < /div>;
                                                                         )
                                                                     ;
                                                                 }
                                                                 if (!rowIndex) {
                                                                     return (
                                                                         <ColumnHeader style = {style}
                                                                     onClick = {();
                                                                 =>
                                                                     {
                                                                         const {top, left} = style;
                                                                         setTimeout(() => {
                                                                             setPortalParams({
                                                                                                 style: {
                                                                                                     // @ts-ignore
                                                                                                     top: parseFloat(top),
                                                                                                     // @ts-ignore
                                                                                                     left: parseFloat(left),
                                                                                                     width: columnWidths[columnIndex],
                                                                                                     height: rowHeights.reduce((a: number, b: number) => a + b),
                                                                                                 },
                                                                                                 start: {
                                                                                                     row: 0,
                                                                                                     column: columnIndex,
                                                                                                 },
                                                                                                 end: {
                                                                                                     row: rowCount,
                                                                                                     column: columnIndex,
                                                                                                 },
                                                                                             });
                                                                         }, 0);
                                                                     }
                                                                 }
                                                                     startDrag = {();
                                                                 =>
                                                                     {
                                                                         setDraggablePortalParams({
                                                                                                      style: {
                                                                                                          top: 0,
                                                                                                          // @ts-ignore
                                                                                                          left: parseFloat(style.left),
                                                                                                          width: 0,
                                                                                                          height: rowHeights.reduce((a: number,
                                                                                                                                     b: number) => a + b),
                                                                                                      },
                                                                                                      start: {
                                                                                                          row: rowIndex,
                                                                                                          column: columnIndex,
                                                                                                      },
                                                                                                  });
                                                                         setSelectedColumn(columnIndex);
                                                                     }
                                                                 }
                                                                     startResizing = {(x);
                                                                 =>
                                                                     {
                                                                         const initialPortalPosition = columnWidths
                                                                             .slice(0, columnIndex + 1)
                                                                             .reduce((a: number, b: number) => a + b);
                                                                         setResizingState({
                                                                                              column: columnIndex,
                                                                                              initialX: x,
                                                                                              initialPortalPosition,
                                                                                              initialWidth: columnWidths[columnIndex],
                                                                                          });

                                                                         setDraggablePortalParams({
                                                                                                      style: {
                                                                                                          top: 0,
                                                                                                          left: initialPortalPosition,
                                                                                                          width: 0,
                                                                                                          height: fullHeight,
                                                                                                      },
                                                                                                      start: {
                                                                                                          row: 0,
                                                                                                          column: columnIndex,
                                                                                                      },
                                                                                                  });
                                                                     }
                                                                 }
                                                                     onMouseMove = {onMouseMove};
                                                                     onMouseUp = {reorder};
                                                                     onSortChanged = {();
                                                                 =>
                                                                     {
                                                                         const wasAscending = sortedColumn === columnIndex;

                                                                         onColumnSorted(columnIndex, !wasAscending);
                                                                         setSortedColumn(columnIndex * (wasAscending ? -1 : 1));
                                                                     }
                                                                 }
                                                                     sortKind = {sortedColumn === columnIndex ? SortKind.ASCENDING : sortedColumn === -columnIndex
                                                                                                                                     ? SortKind.DESCENDING
                                                                                                                                     : SortKind.NONE;
                                                                 }
                                                                 >
                                                                     {
                                                                         getCellElement(columnIndex, rowIndex);
                                                                     }
                                                                     </ColumnHeader>;
                                                                 )
                                                                     ;
                                                                 }
                                                                 return (
                                                                     <div style = {style}
                                                                 className = 'table__cell';
                                                                 onMouseDown = {(e);
                                                             =>
                                                                 {
                                                                     if (e.button !== 0 || portalParamsRef.current) {
                                                                         return;
                                                                     }

                                                                     const {top, left, width, height} = e.currentTarget.style;
                                                                     portalParamsRef.current = {
                                                                         style: {
                                                                             top: parseFloat(top), left: parseFloat(left),
                                                                             width: parseFloat(width), height: parseFloat(height),
                                                                         },
                                                                         start: {row: rowIndex, column: columnIndex},
                                                                     };
                                                                 }
                                                             }
                                                                 onMouseUp = {(e);
                                                             =>
                                                                 {
                                                                     if (selectedColumn) {
                                                                         reorder();
                                                                     } else {
                                                                         reshapePortal(e, true);  // in case onMouseEnter was not fired after onMouseDown
                                                                     }
                                                                 }
                                                             }
                                                                 onMouseEnter = {reshapePortal};
                                                                 onMouseMove = {onMouseMove};
                                                                 onContextMenu = {showContextMenu}
                                                                     >
                                                                     {getCellElement(columnIndex, rowIndex)}
                                                                     < /div>;
                                                             )
                                                                 ;
                                                             },
                                                             [
                                                                 setDragDestination,
                                                                 onColumnsReordered,
                                                                 selectedColumn,
                                                                 columnCount,
                                                                 rowCount,
                                                                 setDraggablePortalParams,
                                                                 getCellElement,
                                                                 showContextMenu,
                                                                 rowHeights,
                                                                 setPortalParams,
                                                                 columnWidths,
                                                                 fullHeight,
                                                                 sortedColumn,
                                                                 onColumnSorted,
                                                                 draggablePortalParams.start.column,
                                                                 draggablePortalParams.style.left,
                                                                 portalParams,
                                                                 resizingState,
                                                             ]);
                                    const getColumnWidth = useCallback(index => columnWidths[index], [columnWidths]);
                                    const getRawHeight = useCallback(index => rowHeights[index], [rowHeights]);
                                    const finishResizing = useCallback((e: MouseEvent<HTMLDivElement, any>) => {
                                        if (resizingState.column) {
                                            const deltaX = e.pageX - resizingState.initialX;
                                            const newWidth = Math.max(resizingState.initialWidth + deltaX, MIN_COLUMN_WIDTH);
                                            onColumnWidthChange(resizingState.column - 1, newWidth);
                                            gridRef.current.resetAfterColumnIndex(resizingState.column);
                                            setResizingState({column: 0, initialX: 0, initialPortalPosition: 0, initialWidth: 0});
                                            setPortalParams({
                                                                ...portalParams,
                                                                style: {
                                                                    ...portalParams.style,
                                                                    width: newWidth,
                                                                },
                                                            });
                                        }
                                    }, [portalParams, onColumnWidthChange, resizingState]);
                                    const handleMouseMoveThrottled = useCallback(throttle((newX: number) => {
                                        if (resizingState.column) {

                                            let deltaX = newX - resizingState.initialX;
                                            if (-deltaX > resizingState.initialWidth - MIN_COLUMN_WIDTH) {
                                                deltaX = MIN_COLUMN_WIDTH - resizingState.initialWidth;
                                            }

                                            setDraggablePortalParams({
                                                                         style: {
                                                                             top: 0,
                                                                             left: resizingState.initialPortalPosition + deltaX,
                                                                             width: 0,
                                                                             height: fullHeight,
                                                                         },
                                                                         start: {
                                                                             row: 0,
                                                                             column: resizingState.column,
                                                                         },
                                                                     });
                                        }
                                    }, 10), [resizingState, fullHeight]);
                                    const handleMouseMove = useCallback((e: MouseEvent<HTMLDivElement, any>) => handleMouseMoveThrottled(e.pageX),
                                                                        [handleMouseMoveThrottled]);

                                    useEffect(() => {
                                        gridRef.current && gridRef.current.resetAfterColumnIndex(0);
                                    }, [columnWidths]);

                                    return (
                                        <div className = {'table-wrapper ' +className}
                                    onMouseLeave = {finishResizing};
                                    onMouseUp = {finishResizing};
                                    onMouseMove = {handleMouseMove};
                                    style = {wrapperStyle} >
                                                           <AutoSizer className = {`table ${selectedColumn ? '_draggable' : ''} ${resizingState.column
                                                                                                                                  ? '_resizing'
                                                                                                                                  : ''}`;
                                }>
                                    {
                                        ({height, width}) => (
                                            <Grid
                                                ref = {gridRef}
                                        columnCount = {columnCount +1};
                                        columnWidth = {getColumnWidth};
                                        rowCount = {rowCount +1};
                                        rowHeight = {getRawHeight};
                                        height = {height};
                                        width = {width};
                                        overscanRowCount = {100};
                                        overscanColumnCount = {columnCount}
                                            >
                                            {Cell}
                                            < /Grid>;
                                    )
                                    }
                                    </AutoSizer>
                                    < /div>;
                                )
                                    ;
                                });
                                src / ui / blocks / table / column - header.tsx;
                                import {Icon, Intent} from '@blueprintjs/core';
                                import React, {CSSProperties, FC, memo, MouseEvent, useCallback} from 'react';

                                export enum SortKind {
                                    NONE,
                                    ASCENDING,
                                    DESCENDING
                                }

                                type Props = {
                                    style: CSSProperties;
                                    sortKind: SortKind;
                                    onClick: () => void;
                                    onMouseMove: (e: MouseEvent<HTMLDivElement, any>) => void;
                                    onMouseUp: (e: MouseEvent<HTMLDivElement, any>) => void;
                                    startResizing: (pageX: number) => void;
                                    onSortChanged: () => void;
                                    startDrag: () => void;
                                };

                                export const ColumnHeader: FC<Props> = memo(({style, onClick, onMouseMove, startDrag, startResizing, onMouseUp, children, sortKind, onSortChanged}) => {
                                    const onMouseDown = useCallback((e) => {e.preventDefault();}, []);
                                    const clickAndStartDrag = useCallback((e: MouseEvent<HTMLDivElement, any>) => {
                                        onClick();
                                        startDrag();
                                    }, [onClick, startDrag]);
                                    const handleStartResize = useCallback((e: MouseEvent<HTMLDivElement, any>) => {
                                        onClick();
                                        startResizing(e.pageX);
                                    }, [onClick, startResizing]);

                                    return (
                                        <div style = {style}
                                    className = 'table__header table__column-header';
                                    onMouseDown = {onMouseDown};
                                    onMouseMove = {onMouseMove};
                                    onMouseUp = {onMouseUp};
                                    onClick = {onClick}
                                    >
                                    <Icon
                                        className = 'column-header__draggable';
                                    icon = {'drag-handle-vertical'};
                                    onMouseDown = {clickAndStartDrag};
                                    />
                                    < div;
                                    className = 'column-header__title' >
                                        {children}
                                                < /div>
                                                < Icon;
                                    className = 'column-header__sort-button';
                                    icon = {sortKind === SortKind.DESCENDING ? 'chevron-up' : 'chevron-down';
                                }
                                    intent = {sortKind === SortKind.NONE ? Intent.NONE : Intent.PRIMARY;
                                }
                                    onClick = {onSortChanged};
                                    />
                                    < div;
                                    className = 'column-header__resize-handle';
                                    onMouseDown = {handleStartResize};
                                    />
                                    < /div>;
                                )
                                    ;
                                });
                                src / ui / blocks / chat - card / chat - card.tsx;
                                import {Icon} from '@blueprintjs/core';
                                import React, {FC, memo, useCallback, useEffect, useMemo, useState} from 'react';
                                import {editChat} from 'src/store/actions/chats.actions';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                import './chat-card.styl';

                                type Props = {
                                    title: string;
                                    onClick: () => void;
                                    chatIndex: number;
                                    isActive: boolean;
                                    isEditing: boolean;
                                    chatId: string;
                                }

                                export const ChatCard: FC<Props> = memo(({title, onClick, isActive, isEditing, chatIndex, chatId}) => {
                                    const cppwApi = useCppwApiContext();
                                    const [isMenuOpen, setIsMenuOpen] = useState(false);
                                    const onIconClick = useCallback(() => {
                                        setIsMenuOpen(!isMenuOpen);
                                    }, [isMenuOpen]);
                                    const options: ({ name: string; onClick: () => void })[] = useMemo(() => [
                                        {
                                            name: 'Редактировать',
                                            onClick: () => {cppwApi && cppwApi.store.dispatch(editChat(chatIndex, {isEditing: true}));},
                                        },
                                        {
                                            name: 'Удалить',
                                            onClick: () => {cppwApi && cppwApi.deleteChat(chatIndex, chatId);},
                                        },
                                    ], [cppwApi, chatIndex]);

                                    useEffect(() => {
                                        if (!isActive) {
                                            setIsMenuOpen(false);
                                        }
                                    }, [isActive]);

                                    return (
                                        <>
                                            <div className = {`chat-card ${isActive ? '_is-active' : ''} ${isEditing ? '_is-editing' : ''}`
                                }
                                    onClick = {onClick} >
                                                        <div className = 'chat-card__text' > {title} < /div>
                                                                         < Icon;
                                    icon = 'chevron-down';
                                    className = 'chat-card__right-icon';
                                    onClick = {onIconClick};
                                    />
                                    < /div>
                                    < div;
                                    className = {`chat-card__menu ${isMenuOpen ? '_opened' : ''}`;
                                }>
                                    {
                                        options.map(({name, onClick}) => <div key = {`${name} ${title}`
                                    }
                                        className = 'chat-card__menu-item';
                                        onClick = {onClick} > {name} < /div>,;
                                    )
                                    }
                                    </div>
                                    < />;
                                )
                                    ;
                                });
                                src / ui / blocks / search - column / search - column.tsx;
                                import {Button, Classes} from '@blueprintjs/core';

                                import React, {FC, useCallback, useMemo, useRef} from 'react';
                                import {useDispatch} from 'react-redux';
                                import {selectSearchType, setFilter} from 'src/store/actions/search.actions';

                                import {AsyncStatus, Attribute, AttributeRef, SearchType, Usage} from 'src/types';
                                import {FormInput} from 'src/ui/blocks/form-input/form-input';
                                import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                import './search-column.styl';

                                type Props = {
                                    status: AsyncStatus;
                                    fields: Attribute[];
                                    searchType: SearchType;
                                    handleSearch?: (filter: Attribute[]) => void;
                                    isColumnsUpdateDisabled?: boolean;
                                }

                                export const SearchColumn: FC<Props> = ({status, fields, searchType, handleSearch, isColumnsUpdateDisabled}) => {
                                    const cppwApi = useCppwApiContext();
                                    const dispatch = useDispatch();
                                    const searchTypeRef = useRef<HTMLSelectElement>(null);

                                    const isAddedArray = useMemo(() => fields.map(({isAdded}) => isAdded), [fields]);
                                    const refs = useMemo<(null | AttributeRef)[]>(() => fields.map(() => (
                                        null
                                    )), [fields]);
                                    const setInputRefs = useMemo(() => fields.map((
                                                                                      val,
                                                                                      index,
                                                                                  ) => (elem: AttributeRef) => {
                                        refs[index] = elem;
                                    }), [refs, fields]);

                                    const onChangeSearchType = useCallback(() => {
                                        searchTypeRef.current && dispatch(selectSearchType(searchTypeRef.current.value as SearchType));
                                        searchTypeRef.current && cppwApi && cppwApi.search();
                                    }, [dispatch, searchTypeRef, cppwApi]);
                                    const baseSearch = SearchType.Questionnaire === searchType ? null : (
                                        <>
                                            <div className = 'bp3-select bp3-fill search-column__select' >
                                                             <select defaultValue = {searchType}
                                    ref = {searchTypeRef};
                                    onChange = {onChangeSearchType} >
                                                                    <option value = {SearchType.Initial};
                                    disabled > Поиск;
                                    по;
                                ...
                                    </option>
                                    < option;
                                    value = {SearchType.Students} > Студенты < /option>
                                                                  < option;
                                    value = {SearchType.Mentors} > Менторы < /option>
                                                                 < option;
                                    value = {SearchType.Activities} > Активности < /option>
                                                                    < option;
                                    value = {SearchType.Projects} > Проекты < /option>
                                                                  < option;
                                    value = {SearchType.ProjectRequests} > Заявки;
                                    на;
                                    проекты < /option>
                                    < option;
                                    value = {SearchType.Organisations} > Организации < /option>
                                                                       < /select>
                                                                       < /div>
                                                                       < />;
                                )
                                    ;

                                    const onSearch = useCallback(() => {
                                        const filter: Attribute[] = fields.map((item, index) => (
                                            {...item, defaultValue: refs[index] ? refs[index]?.value : ''}
                                        ));
                                        if (handleSearch) {
                                            handleSearch(filter);
                                        } else {
                                            dispatch(setFilter(filter));
                                            searchTypeRef.current && cppwApi && cppwApi.fullSearch();
                                        }
                                    }, [dispatch, cppwApi, fields, refs]);
                                    const onColumnsUpdate = useCallback(() => {
                                        const filter: Attribute[] = fields.map((item, index) => (
                                            {...item, isAdded: isAddedArray[index]}
                                        ));
                                        dispatch(setFilter(filter));
                                    }, [isAddedArray, dispatch, fields]);

                                    return (
                                        <div className = {'search-column'} >
                                            {baseSearch}
                                                                           < LoadableView
                                    status = {status};
                                    errorSubtitle = 'Ошибка загрузки параметров поиска' >
                                                    <div className = 'scrollable-tabs' >
                                        {
                                            fields.map(({name, title, usage, defaultValue, variants, isAdded}, index) => {
                                                return <FormInput
                                                    key = {name};
                                                title = {title};
                                                name = {name};
                                                id = {name};
                                                mandatory = {false};
                                                validators = {[]};
                                                defaultValue = {defaultValue};
                                                usage = {usage || Usage.ShortText;
                                            }
                                                inputRef = {setInputRefs[index]};
                                                variants = {variants};
                                                formIndex = { - 1;
                                            }
                                                index = { - 1;
                                            }
                                                isAddable = {!;
                                                isColumnsUpdateDisabled;
                                            }
                                                isAdded = {isAdded};
                                                triggerIsAdded = {();
                                            =>
                                                {
                                                    isAddedArray[index] = !isAddedArray[index];
                                                }
                                            }
                                                />;;
                                            }),
                                        }
                                                                     < /div>
                                                                     < /LoadableView>
                                                                     < Button;
                                    className = {`${Classes.FILL}`;
                                }
                                    text = 'Найти';
                                    onClick = {onSearch};
                                    />;
                                    {
                                        !isColumnsUpdateDisabled && <Button
                                            className = {`${Classes.FILL} search-column__button`;
                                    }
                                        text = 'Обновить состав столбцов';
                                        onClick = {onColumnsUpdate};
                                        />;
                                    }
                                    </div>;
                                )
                                    ;
                                };
                                src / ui / blocks / partners / partners.tsx;
                                import React, {FC} from 'react';
                                import {HomePageParagraph} from 'src/ui/blocks/home-page-paragraph/home-page-paragraph';

                                const info = [
                                    {
                                        title: 'Компаниям-партнерам',
                                        mode: 1,
                                        description: 'Приглашаем компании предложить свой проект для командной и/или индивидуальной работы студентов бакалавриата и магистратуры факультета компьютерных наук НИУ ВШЭ.',
                                    },
                                    {
                                        title: 'Формы сотрудничества с компаниями:',
                                        mode: 2,
                                        description: '',
                                    },
                                    {
                                        title: 'Практика студентов',
                                        mode: 3,
                                        description: [
                                            {
                                                text: 'Еел возможность проходить практику в компании необходимо заключить договор с НИУ ВШЭ, ',
                                            },
                                            {
                                                text: 'шаблон договора на практику',
                                                link: 'https://cs.hse.ru/data/2019/06/01/1496962149/Шаблон%20договора%20на%20практику%20ФКН%20НИУ%20ВШЭ%202019_v2.pdf',
                                            },
                                            {
                                                text: '. В апреле и мае проходят собрания студентов, на которых представители компаний рассказывают о возможностях прохождения практики в их организации.',
                                            },
                                        ],
                                    },
                                    {
                                        title: '',
                                        mode: 3,
                                        description: 'Во время прохождения стажировки/практики к студенту нужно назначить куратора из числа сотрудников компании, который также разработает индивидуальное задание и составит календарный план-график. По окончанию практики студент составляет отчет, в котором рассказывает о том, какую задачу он решал и какой стек технологий использовал. Отчет студента подписывает руководитель практики от компании, также он составляет отзыв о работе студента и выставляет оценку по 10 бальной шкале. ',
                                    },
                                    {
                                        title: 'Проектная работа на бакалаврских программах ФКН',
                                        mode: 3,
                                        description: [
                                            {
                                                text: 'На ФКН большое внимание уделяется проектной работе. Она включена в учебные планы всех образовательных программ.  В сентябре и октябре компании представляют студентам идеи своих проектов, основанных на реальных задачах, которые студенты могут выбрать в качестве проектной работы. Если спрос будет высокий, то компания может провести дополнительный отбор. После Центр Практик и Проектной Работы собирает заявки на проекты.',
                                            },
                                        ],
                                    },
                                    {
                                        title: '',
                                        mode: 3,
                                        description: 'Если у вашей компании есть сформулированная задача или новое направление, на которые не хватает людей или времени, наши студенты могут помочь решить эту проблему. Студенты работают над проектами в рамках образовательной деятельности и получают после защиты оценку в зачетку (компании не обязано оплачивать работу студентов). Pабота студентов над проектом должна способствовать формированию профессиональных компетенций. Для работы со студентами компании необходимо выделить менторов на время выполнения всего проекта.',
                                    },
                                    {
                                        title: '',
                                        mode: 3,
                                        description: 'Если Вы заинтересованы в такой форме сотрудничества, у вас остались вопросы о темах проектов, компетенциях студентов разных образовательных программ и курсов, организации работы над проектами или какие-то другие вопросы, мы с удовольствием на них ответим.',
                                    },
                                ];

                                export const Partners: FC = () => (
                                    <>
                                        {
                                            info.map((elem, ind) => {
                                                return <HomePageParagraph key = {ind};
                                                {...
                                                    elem;
                                                }
                                                />;;
                                            }),
                                        }
                                    < />
                                );
                                src / ui / blocks / attribute - creator / attribute - creator.tsx;
                                import {Card, H3} from '@blueprintjs/core';
                                import React, {FC, memo, useCallback, useMemo, useState} from 'react';
                                import {useDispatch, useSelector} from 'react-redux';
                                import {addDraftFormAttributes} from 'src/store/actions/user-forms.actions';
                                import {State} from 'src/store/reducers';
                                import {AsyncStatus, Attribute, Usage} from 'src/types';
                                import {AttributeCard} from 'src/ui/blocks/attribute-card/attribute-card';
                                import {Search} from 'src/ui/blocks/search/search';
                                import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                import './attribute-creator.styl';

                                type Props = {
                                    className?: string;
                                    formIndex: number;
                                }
                                export const DEFAULT_ATTRIBUTE_ID = 'ididid';

                                const newAttributes: { [K in Usage]: Attribute | undefined } = {
                                    [Usage.ShortText]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.ShortText,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.Email]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.Email,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.Password]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.Password,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.Number]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.Number,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.LongText]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.LongText,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.Date]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.Date,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.File]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.File,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.Checkbox]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.Checkbox,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        variants: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.Radio]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.Radio,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        variants: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.Mentor]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.Mentor,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.Switch]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.Switch,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.Organisation]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.Organisation,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },
                                    [Usage.Student]: {
                                        id: DEFAULT_ATTRIBUTE_ID,
                                        name: '',
                                        usage: Usage.Student,
                                        title: '',
                                        mandatory: false,
                                        validators: [],
                                        isPlaceholder: true,
                                    },

                                    // Не имеют возможности создания нового поля.
                                    [Usage.StudentGroup]: undefined,
                                    [Usage.Activity]: undefined,
                                    [Usage.Stage]: undefined,
                                    [Usage.Task]: undefined,
                                    [Usage.Variants]: undefined,
                                    [Usage.Validator]: undefined,

                                    // [Usage.Url]: undefined,
                                    // [Usage.Time]: undefined,
                                    // [Usage.Tel]: undefined,
                                };

                                export const AttributeCreator: FC<Props> = memo(({className, formIndex}) => {
                                    const dispatch = useDispatch();
                                    const cppwApi = useCppwApiContext();
                                    const attributes = useSelector((state: State) => state.attributes);
                                    const [usage, setUsage] = useState<Usage | ''>('');
                                    // @ts-ignore
                                    const items: any = useMemo(() => usage && attributes[usage] && attributes[usage]?.attributes
                                                                     ? attributes[usage].attributes.map(
                                            (attribute: Attribute) => ({
                                                ...attribute,
                                                onClick: () => {
                                                    dispatch(
                                                        addDraftFormAttributes(
                                                            formIndex,
                                                            [attribute]));
                                                },
                                            }))
                                                                     : [], [usage, attributes, dispatch, formIndex]);
                                    const onUsageSelected = useCallback((e) => {
                                        if (e.target && e.target.value && e.target.value !== usage) {
                                            cppwApi && cppwApi.getAttributesByUsage(e.target.value as Usage);
                                            setUsage(e.target.value as Usage);
                                        }
                                    }, [cppwApi, setUsage, usage]);

                                    return (
                                        <Card className = {className} >
                                                                      <H3 className = 'form-layout__title' > Добавление
                                    поля < /H3>
                                    < div;
                                    className = 'bp3-select bp3-fill' >
                                                <select onChange = {onUsageSelected};
                                    value = {usage} >
                                                    <option value = '' > Выберите;
                                    тип;
                                    поля < /option>
                                    < option;
                                    value = {Usage.ShortText} > Короткий;
                                    текст < /option>
                                    < option;
                                    value = {Usage.LongText} > Длинный;
                                    текст < /option>
                                    < option;
                                    value = {Usage.Email} > E - mail < /option>
                                                          < option;
                                    value = {Usage.Password} > Пароль < /option>
                                                             < option;
                                    value = {Usage.Number} > Число < /option>
                                                           < option;
                                    value = {Usage.File} > Файл < /option>
                                                         < option;
                                    value = {Usage.Checkbox} > Множественный;
                                    выбор < /option>
                                    < option;
                                    value = {Usage.Radio} > Единичный;
                                    выбор < /option>
                                    < option;
                                    value = {Usage.Date} > Дата < /option>

                                                         < option;
                                    value = {Usage.Switch} > Да / Нет < /option>
                                                           < option;
                                    value = {Usage.StudentGroup} > Группа < /option>
                                                                 < option;
                                    value = {Usage.Mentor} > Ментор < /option>
                                                           < option;
                                    value = {Usage.Activity} > Активность < /option>
                                                             < option;
                                    value = {Usage.Organisation} > Организация < /option>
                                                                 < /select>
                                                                 < /div>;
                                    {
                                        <div className = 'attribute-creator__scrollable' >
                                        {
                                            usage && attributes[usage]?.status === AsyncStatus.Success && attributes[usage]
                                                         && <Search component = {AttributeCard};
                                        searchPropertyName = 'name';
                                        items = {items};
                                        className = 'side-margin-search' / >
                                    }

                                        {
                                            usage && newAttributes[usage] && (
                                                <AttributeCard {...newAttributes[usage]}
                                            onClick = {();
                                        =>
                                            {
                                                const newAttribute = newAttributes[usage];
                                                newAttribute && dispatch(addDraftFormAttributes(formIndex, [newAttribute]));
                                            }
                                        }
                                            />;
                                        )
                                        }
                                        </div>;
                                    }
                                    </Card>;
                                )
                                    ;
                                });
                                src / ui / blocks / form - input / form - checkbox - input.tsx;
                                import {Checkbox} from '@blueprintjs/core';
                                import React, {FC, memo, useCallback, useEffect, useState} from 'react';

                                type Props = {
                                    inputRef: (ref: { value: string[] } | null) => void;
                                    defaultValue?: string[];
                                    disabled?: boolean;
                                    variants?: string[]
                                }

                                export const CheckboxInputView: FC<Props> = memo(({
                                                                                      inputRef,
                                                                                      disabled,
                                                                                      defaultValue,
                                                                                      variants = [],
                                                                                  }) => {
                                    const [values, setValues] = useState<string[]>(defaultValue || []);
                                    const onSelect = useCallback((label) => () => {
                                        if (!values.includes(label)) {
                                            values.push(label);
                                            setValues([...values]);
                                        } else {
                                            setValues(values.filter((variant) => variant !== label));
                                        }

                                    }, [values, setValues]);
                                    useEffect(() => {
                                        inputRef && inputRef({value: values});
                                    }, [inputRef, values]);

                                    return (
                                        <>
                                            {
                                                variants.map((variant, index) => <Checkbox key = {index}
                                                checked = {values.includes(variant)}
                                                disabled = {disabled}
                                                label = {variant}
                                                onChange = {onSelect(variant)}
                                    />)}
                                    < />;
                                )
                                    ;
                                })
                                    ;src / ui / blocks / form - input / form - number - input.tsx;
                                    import {Intent, NumericInput} from '@blueprintjs/core';
                                    import React, {FC, memo, useCallback, useEffect, useState} from 'react';

                                    type Props = {
                                        intent: Intent;
                                        inputRef: (ref: HTMLInputElement | null) => void;
                                        placeholder?: string;
                                        defaultValue?: string;
                                        disabled?: boolean;
                                        max?: number;
                                        min?: number;
                                    }

                                    export const NumberInputView: FC<Props> = memo(({
                                                                                        placeholder,
                                                                                        intent,
                                                                                        inputRef,
                                                                                        defaultValue,
                                                                                        max,
                                                                                        min,
                                                                                        disabled,
                                                                                    }) => {
                                        const [value, setValue] = useState(defaultValue || '');
                                        const handleChange = useCallback((val, textContent: string) => setValue(textContent), [setValue]);

                                        useEffect(() => {
                                            // @ts-ignore
                                            inputRef && inputRef({value});
                                        }, [inputRef, value]);
                                        return (
                                            <NumericInput
                                                placeholder = {placeholder}
                                        inputRef = {inputRef};
                                        intent = {intent};
                                        disabled = {disabled};
                                        fill = {true};
                                        buttonPosition = 'right';
                                        value = {value};
                                        onValueChange = {handleChange};
                                        max = {max};
                                        min = {min};
                                        />;
                                    )
                                        ;
                                    });
                                    src / ui / blocks / form - input / form - radio - input.tsx;
                                    import {Intent, Radio, RadioGroup} from '@blueprintjs/core';
                                    import {handleStringChange} from '@blueprintjs/docs-theme';
                                    import React, {FC, memo, useCallback, useEffect, useState} from 'react';

                                    type Props = {
                                        intent: Intent;
                                        inputRef: (ref: { value: string } | null) => void;
                                        placeholder?: string;
                                        defaultValue?: string;
                                        disabled?: boolean;
                                        variants?: string[]
                                    }

                                    export const RadioInputView: FC<Props> = memo((
                                                                                      {
                                                                                          variants = [],
                                                                                          placeholder,
                                                                                          intent,
                                                                                          inputRef,
                                                                                          defaultValue,
                                                                                          disabled,
                                                                                      },
                                                                                  ) => {
                                        const [value, setValue] = useState(defaultValue);
                                        const onChange = useCallback(handleStringChange(val => {
                                            setValue(val);
                                        }), [setValue]);
                                        useEffect(() => {inputRef && inputRef({value: value || ''});}, [inputRef, value]);

                                        return (
                                            <RadioGroup
                                                inline = {false}
                                        onChange = {onChange};
                                        selectedValue = {value}
                                            >
                                            {
                                                variants.map((str, ind) => <Radio disabled = {disabled}
                                                label = {str}
                                                value = {str}
                                                key = {ind}
                                        />);
                                    }
                                        </RadioGroup>;
                                    )
                                        ;
                                    });
                                    src / ui / blocks / form - input / form - date - input.tsx;
                                    import {Intent, Position} from '@blueprintjs/core';
                                    import {DateInput} from '@blueprintjs/datetime';
                                    import '@blueprintjs/datetime/lib/css/blueprint-datetime.css';
                                    import moment from 'moment';

                                    import React, {FC, memo, useCallback, useEffect, useMemo, useState} from 'react';

                                    type Props = {
                                        intent: Intent;
                                        inputRef: (ref: { value: string | null }) => void;
                                        placeholder?: string;
                                        defaultValue?: string;
                                        disabled?: boolean;
                                    }

                                    const FORMAT = 'DD-MM-YYYY';
                                    const formatDate = (date: Date) => moment(date).format(FORMAT);
                                    const parseDate = (str: string) => moment(str, FORMAT).toDate();

                                    export const DateInputView: FC<Props> = memo(({placeholder, inputRef, disabled, defaultValue}) => {
                                        const defVal = useMemo(() => defaultValue ? new Date(defaultValue) : undefined, [defaultValue]);
                                        const [date, setDate] = useState<Date | undefined>(defVal);
                                        const onChange = useCallback((date: Date) => setDate(date), [setDate]);
                                        const popoverProps = useMemo(() => (
                                            {position: Position.BOTTOM}
                                        ), []);

                                        useEffect(() => {
                                            inputRef && inputRef({value: date ? date.toISOString() : null});
                                        }, [inputRef, date]);

                                        return (
                                            <>
                                                <DateInput
                                                    formatDate = {formatDate}
                                        parseDate = {parseDate};
                                        placeholder = {`${FORMAT}`;
                                    }
                                        disabled = {disabled};
                                        fill = {true};
                                        closeOnSelection = {true};
                                        defaultValue = {defVal};
                                        onChange = {onChange};
                                        popoverProps = {popoverProps};
                                        />
                                        < />;
                                    )
                                        ;
                                    });
                                    src / ui / blocks / form - input / form - select - input.tsx;
                                    import {Intent} from '@blueprintjs/core';
                                    import React, {FC, memo, useEffect, useState} from 'react';
                                    import {ApiResponse, AsyncStatus} from 'src/types';

                                    type Props = {
                                        intent: Intent;
                                        inputRef: (ref: HTMLSelectElement | null) => void;
                                        defaultValue?: string;
                                        requestVariants?: () => Promise<ApiResponse>;
                                        disabled?: boolean;
                                        variants?: string[];
                                    }

                                    export const SelectInputView: FC<Props> = memo(({variants = [], inputRef, intent, requestVariants, disabled, defaultValue}) => {
                                        const [vars, setVars] = useState(variants);
                                        const [status, setStatus] = useState(AsyncStatus.Initial);
                                        useEffect(() => {
                                            if (requestVariants && (status === AsyncStatus.Initial)) {
                                                setStatus(AsyncStatus.Pending);
                                                requestVariants().then((res: ApiResponse) => {
                                                                     setVars(res.map(({name}: ApiResponse) => name));
                                                                     setStatus(AsyncStatus.Success);
                                                                 })
                                                                 .catch(() => {
                                                                     setStatus(AsyncStatus.Error);
                                                                 });
                                            }
                                        });
                                        return (
                                            <div className = 'bp3-select bp3-fill' >
                                                             <select ref = {inputRef}
                                        disabled = {disabled};
                                        defaultValue = {defaultValue} >
                                                                      <option value = {''} >
                                    ...
                                        </option>;
                                        {
                                            vars && vars.map((value: string, ind: number) => (
                                                <option key = {ind}
                                            value = {value} > {value} < /option>;
                                        ))
                                        }
                                        </select>
                                        < /div>;
                                    )
                                        ;
                                    });
                                    src / ui / blocks / form - input / form - mentor - suggest - input.tsx;
                                    import {Intent, MenuItem} from '@blueprintjs/core';
                                    import {Suggest} from '@blueprintjs/select';
                                    import React, {FC, memo, MouseEventHandler, useCallback, useEffect, useState} from 'react';
                                    import {ApiResponse, AsyncStatus} from 'src/types';
                                    import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                                    import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                    type Props = {
                                        path?: string;
                                        intent: Intent;
                                        inputRef?: (ref: { value: { id: string, name: string } } | null) => void;
                                        placeholder?: string;
                                        onChange?: (val: IMentor) => void;
                                        defaultValue?: { id: string, name: string };
                                        disabled?: boolean;
                                    }

                                    const filterMentor = (query: string, mentor: IMentor, _index?: number, exactMatch?: boolean) => {
                                        const normalizedTitle = mentor.name.toLowerCase();
                                        const normalizedQuery = query.toLowerCase();

                                        if (exactMatch) {
                                            return normalizedTitle === normalizedQuery;
                                        } else {
                                            return `${normalizedTitle} ${mentor.id}`.indexOf(normalizedQuery) >= 0;
                                        }
                                    };

                                    const escapeRegExpChars = (text: string) => {
                                        return text.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1');
                                    };

                                    const highlightText = (text: string, query: string) => {
                                        let lastIndex = 0;
                                        const words = query
                                            .split(/\s+/)
                                            .filter(word => word.length > 0)
                                            .map(escapeRegExpChars);
                                        if (words.length === 0) {
                                            return [text];
                                        }
                                        const regexp = new RegExp(words.join('|'), 'gi');
                                        const tokens: React.ReactNode[] = [];
                                        while (true) {
                                            const match = regexp.exec(text);
                                            if (!match) {
                                                break;
                                            }
                                            const length = match[0].length;
                                            const before = text.slice(lastIndex, regexp.lastIndex - length);
                                            if (before.length > 0) {
                                                tokens.push(before);
                                            }
                                            lastIndex = regexp.lastIndex;
                                            tokens.push(<strong key = {lastIndex} > {match[0]} < /strong>);
                                        }
                                        const rest = text.slice(lastIndex);
                                        if (rest.length > 0) {
                                            tokens.push(rest);
                                        }
                                        return tokens;
                                    };

                                    export const renderItem = (mentor: IMentor,
                                                               {handleClick, modifiers, query}: { handleClick: MouseEventHandler<HTMLElement>; index?: number; modifiers: { active: boolean; disabled: boolean; matchesPredicate: boolean; }; query: string; }) => {
                                        if (!modifiers.matchesPredicate) {
                                            return null;
                                        }
                                        const text = `${mentor.name}`;
                                        return (
                                            <MenuItem
                                                active = {modifiers.active}
                                        disabled = {modifiers.disabled};
                                        labelElement = { < a;
                                        href = {`/user/${mentor.id}`;
                                    }
                                        target = '_blank';
                                        onClick = {(e);
                                    =>
                                        {
                                            e.stopPropagation();
                                        }
                                    }>
                                        Подробнее;
                                    ...
                                        </a>};
                                        key = {mentor.id};
                                        onClick = {handleClick};
                                        text = {highlightText(text, query)};
                                        />;
                                    )
                                        ;
                                    };

                                    export interface IMentor {
                                        name: string;
                                        id: string;
                                    }

                                    const renderInputValue = (mentor: IMentor) => mentor.name;

                                    export function areFilmsEqual(mentorA: IMentor, mentorB: IMentor) {
                                        return mentorA.name.toLowerCase() === mentorB.name.toLowerCase();
                                    }

                                    const MentorSuggest = Suggest.ofType<IMentor>();
                                    export const SearchInputView: FC<Props> = memo((
                                                                                       {
                                                                                           onChange,
                                                                                           placeholder,
                                                                                           inputRef,
                                                                                           defaultValue,
                                                                                           disabled,
                                                                                           path,
                                                                                       },
                                                                                   ) => {
                                        const cppwApi = useCppwApiContext();
                                        const [vars, setVars] = useState<IMentor[]>([]);
                                        const [selectedValue, setSelectedValue] = useState();
                                        const [status, setStatus] = useState(AsyncStatus.Initial);
                                        const onSelect = useCallback((val) => {
                                            setSelectedValue(val);
                                            onChange && onChange(val);
                                        }, [onChange, setSelectedValue]);
                                        const onRetry = useCallback(() => {
                                            if (cppwApi) {
                                                setStatus(AsyncStatus.Pending);
                                                cppwApi.get(path ? path : 'utils/mentors?name=').then((res: ApiResponse) => {
                                                    setVars(res);
                                                    setStatus(AsyncStatus.Success);
                                                }).catch(() => {
                                                    setStatus(AsyncStatus.Error);
                                                });
                                            }
                                        }, [path, cppwApi]);
                                        useEffect(() => {
                                            if (status === AsyncStatus.Initial) {
                                                onRetry();
                                            }
                                        }, [status, onRetry]);
                                        useEffect(() => {
                                            inputRef && inputRef({value: selectedValue});
                                        }, [inputRef, selectedValue]);

                                        return (
                                            <LoadableView status = {status}
                                        errorSubtitle = 'Список вариантов не загрузился';
                                        onRetry = {onRetry} >
                                                            <MentorSuggest
                                                                itemPredicate = {filterMentor};
                                        itemRenderer = {renderItem};
                                        items = {vars};
                                        closeOnSelect = {true};
                                        fill = {true};
                                        disabled = {disabled};
                                        defaultSelectedItem = {defaultValue};
                                        inputValueRenderer = {renderInputValue};
                                        itemsEqual = {areFilmsEqual};
                                        noResults = { < MenuItem;
                                        disabled = {true};
                                        text = 'Ничего не найдено.' / >
                                    }
                                        onItemSelect = {onSelect};
                                        popoverProps = {
                                        {
                                            minimal: true, position;
                                        :
                                            'bottom', popoverClassName;
                                        :
                                            'form-input-mentor';
                                        }
                                    }
                                        inputProps = {
                                        {
                                            placeholder: placeholder || 'Начните вводить ФИО...';
                                        }
                                    }
                                        />
                                        < /LoadableView>;
                                    )
                                        ;
                                    });
                                    src / ui / blocks / form - input / form - organisation - input.tsx;
                                    import {Intent} from '@blueprintjs/core';
                                    import React, {FC, memo, useCallback, useEffect, useState} from 'react';
                                    import {SearchInputView} from 'src/ui/blocks/form-input/form-mentor-suggest-input';

                                    type Organisation = {
                                        name: string;
                                        id: string;
                                    }

                                    const getDefaultState = (defaultValue?: Organisation | Organisation[]): InputState[] => {
                                        if (!defaultValue) {
                                            return [{query: ''}];
                                        }

                                        if (Array.isArray(defaultValue)) {
                                            const state: InputState[] = defaultValue.map(
                                                (val, index) => {
                                                    return {query: (index === 0 ? '' : defaultValue[index - 1].id), defaultValue: val};
                                                });
                                            state.push({query: defaultValue[defaultValue.length - 1].id});
                                            return state;
                                        }
                                        return [{query: '', defaultValue: defaultValue}];
                                    };

                                    type InputState = {
                                        query: string;
                                        defaultValue?: Organisation;
                                    }
                                    type Props = {
                                        intent: Intent;
                                        inputRef: (ref: { value: Organisation } | null) => void;
                                        placeholder?: string;
                                        onChange?: () => void;
                                        defaultValue?: Organisation | Organisation[];
                                        disabled?: boolean;
                                    }
                                    export const OrganisationInputView: FC<Props> = memo((
                                                                                             {
                                                                                                 intent,
                                                                                                 inputRef,
                                                                                                 defaultValue,
                                                                                                 disabled,
                                                                                             },
                                                                                         ) => {
                                        const [inputStates, setInputStates] = useState<InputState[]>(getDefaultState(defaultValue));
                                        const onSelect = useCallback((index: number) => (val: Organisation) => {
                                            inputRef({value: val});
                                            const newInputStates = [];
                                            for (let i = 0; i <= index; i++) {
                                                newInputStates.push(inputStates[i]);
                                            }
                                            newInputStates[index].defaultValue = val;
                                            newInputStates.push({query: val.id});
                                            setInputStates(newInputStates);
                                        }, [inputRef, setInputStates, inputStates]);

                                        useEffect(() => {
                                            if (defaultValue) {
                                                if (Array.isArray(defaultValue)) {
                                                    inputRef({value: defaultValue[defaultValue.length - 1]});
                                                } else {
                                                    inputRef({value: defaultValue});
                                                }
                                            }
                                        }, [defaultValue, inputRef]);
                                        // TODO: как появится ручка - пофиксить path
                                        return (
                                            <>
                                                {
                                                    inputStates.map(({query, defaultValue}, ind) => (<SearchInputView onChange = {onSelect(ind)}
                                                    key = {query}
                                                    intent = {intent}
                                                    path = {''}
                                                    defaultValue = {defaultValue}
                                                    disabled = {disabled}
                                                    placeholder = {`Начните вводить наименование ${ind
                                                                                                   ? 'под'
                                                                                                   : ''}организации...`,
                                                }
                                        />));
                                    }
                                        </>;
                                    )
                                        ;
                                    });
                                    src / ui / blocks / form - input / constants / usage - to - schema - map.tsx;
                                    import {Form, FormMode, FormType, Usage} from 'src/types';

                                    const NAME = 'name';
                                    const DESCRIPTION = 'description';
                                    const TITLE = 'title';
                                    const PLACEHOLDER = 'placeholder';
                                    const HINT = 'hint';
                                    const MANDATORY = 'mandatory';

                                    const MIN = 'min';
                                    const MAX = 'max';
                                    const MIN_NUMBER = 'min_number';
                                    const MAX_NUMBER = 'max_number';

                                    const VARIANTS = 'variants';

                                    const VALIDATORS = 'validators';

                                    const schemaCreator = (usage: Usage, title: string, attributeNames: string[]): Form => (
                                        {
                                            id: usage,
                                            type: FormType.AttributeCreator,
                                            title,
                                            attributes: attributeNames.map((name) => attributesCreator(name, usage)),
                                            buttonName: 'Сохранить',
                                            mode: FormMode.Fill,
                                        }
                                    );
                                    const nameAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${NAME}`,
                                            name: NAME,
                                            usage: Usage.ShortText,
                                            title: 'Наименование данного поля',
                                            mandatory: true,
                                            hint: 'Должно быть уникальным для системы и отражать сущность поля.',
                                            validators: [],
                                        }
                                    );
                                    const descriptionAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${DESCRIPTION}`,
                                            name: DESCRIPTION,
                                            usage: Usage.ShortText,
                                            title: 'Описание данного поля',
                                            mandatory: false,
                                            hint: 'Видно только при создании/редактировании форм. Должно отражать смысл поля.',
                                            validators: [],
                                        }
                                    );
                                    const titleAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${TITLE}`,
                                            name: TITLE,
                                            usage: Usage.ShortText,
                                            title: 'Заголовок поля',
                                            mandatory: true,
                                            validators: [],
                                        }
                                    );
                                    const placeholderAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${PLACEHOLDER}`,
                                            name: PLACEHOLDER,
                                            usage: Usage.ShortText,
                                            title: 'Пример вводимого значения',
                                            mandatory: false,
                                            hint: 'Будет отображен как плейсхолдер в строке ввода.',
                                            validators: [],
                                        }
                                    );
                                    const hintAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${HINT}`,
                                            name: HINT,
                                            usage: Usage.ShortText,
                                            title: 'Текст подсказки',
                                            mandatory: false,
                                            hint: 'Этот текст будет отображаться при наведении на иконку ?.',
                                            validators: [],
                                        }
                                    );
                                    const mandatoryAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${MANDATORY}`,
                                            name: MANDATORY,
                                            usage: Usage.Switch,
                                            title: 'Обязательное ли поле',
                                            mandatory: true,
                                            validators: [],
                                        }
                                    );
                                    const minAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${MIN}`,
                                            name: MIN,
                                            usage: Usage.Number,
                                            title: 'Минимальное кол-во символов во вводимой строке',
                                            mandatory: false,
                                            validators: [],
                                        }
                                    );
                                    const minNumberAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${MIN}`,
                                            name: MIN,
                                            usage: Usage.Number,
                                            title: 'Минимальное вводимое значение',
                                            mandatory: false,
                                            validators: [],
                                        }
                                    );
                                    const maxAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${MAX}`,
                                            name: MAX,
                                            usage: Usage.Number,
                                            title: 'Максимальное кол-во символов во вводимой строке',
                                            mandatory: false,
                                            validators: [],
                                        }
                                    );
                                    const maxNumberAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${MAX}`,
                                            name: MAX,
                                            usage: Usage.Number,
                                            title: 'Максимальное значение значение',
                                            mandatory: false,
                                            validators: [],
                                        }
                                    );
                                    const variantsAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${VARIANTS}`,
                                            name: VARIANTS,
                                            usage: Usage.Variants,
                                            title: 'Варианты ответа',
                                            mandatory: true,
                                            validators: [],
                                        }
                                    );
                                    const validatorsAttributeCreator = (usage: Usage) => (
                                        {
                                            id: `${usage}-${VALIDATORS}`,
                                            name: VALIDATORS,
                                            usage: Usage.Validator,
                                            title: 'Валидаторы',
                                            mandatory: false,
                                            validators: [],
                                        }
                                    );

                                    const attributesCreator = (name: string, usage: Usage) => {
                                        switch (name) {
                                            case NAME: {
                                                return nameAttributeCreator(usage);
                                            }
                                            case DESCRIPTION: {
                                                return descriptionAttributeCreator(usage);
                                            }
                                            case TITLE: {
                                                return titleAttributeCreator(usage);
                                            }
                                            case PLACEHOLDER: {
                                                return placeholderAttributeCreator(usage);
                                            }
                                            case MANDATORY: {
                                                return mandatoryAttributeCreator(usage);
                                            }
                                            case HINT: {
                                                return hintAttributeCreator(usage);
                                            }
                                            case MIN: {
                                                return minAttributeCreator(usage);
                                            }
                                            case MAX: {
                                                return maxAttributeCreator(usage);
                                            }
                                            case MIN_NUMBER: {
                                                return minNumberAttributeCreator(usage);
                                            }
                                            case MAX_NUMBER: {
                                                return maxNumberAttributeCreator(usage);
                                            }
                                            case VARIANTS: {
                                                return variantsAttributeCreator(usage);
                                            }
                                            case VALIDATORS: {
                                                return validatorsAttributeCreator(usage);
                                            }
                                            default: {
                                                return nameAttributeCreator(usage);
                                            }
                                        }
                                    };

                                    // name совпадает с НАЗВАНИЕМ ИТОГОВОГО ПОЛЯ
                                    export const USAGE_TO_FORM_MAP: { [k in Usage]: Form | undefined } = {
                                        [Usage.Email]: schemaCreator(Usage.Email, 'Редактирование поля E-mail', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, PLACEHOLDER, HINT,
                                            VALIDATORS,
                                        ]),
                                        [Usage.ShortText]: schemaCreator(Usage.ShortText, 'Редактирование поля Короткий текст', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, PLACEHOLDER, HINT,
                                            MIN, MAX,
                                            VALIDATORS,
                                        ]),
                                        [Usage.Number]: schemaCreator(Usage.Number, 'Редактирование числового поля', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, PLACEHOLDER, HINT,
                                            MIN_NUMBER, MAX_NUMBER,
                                        ]),
                                        [Usage.Checkbox]: schemaCreator(Usage.Checkbox, 'Редактирование поля с множественным выбором', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT,
                                            VARIANTS,
                                        ]),
                                        [Usage.Password]: schemaCreator(Usage.Password, 'Редактирование поля c паролем', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT, PLACEHOLDER,
                                            MIN, MAX,
                                            VALIDATORS,
                                        ]),
                                        [Usage.LongText]: schemaCreator(Usage.LongText, 'Редактирование поля Длинный текст', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT, PLACEHOLDER,
                                            MIN, MAX,
                                            VALIDATORS,
                                        ]),
                                        [Usage.File]: schemaCreator(Usage.File, 'Редактирование файлового поля', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT, PLACEHOLDER,
                                        ]),
                                        [Usage.Radio]: schemaCreator(Usage.Radio, 'Редактирование поля с единичным выбором', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT,
                                            VARIANTS,
                                        ]),
                                        [Usage.Date]: schemaCreator(Usage.Date, 'Редактирование поля с датой', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT,
                                        ]),
                                        [Usage.Switch]: schemaCreator(Usage.Switch, 'Редактирование поля с выбором Да/Нет', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT,
                                        ]),
                                        [Usage.Mentor]: schemaCreator(Usage.Mentor, 'Редактирование поля с выбором ментора', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT, PLACEHOLDER,
                                        ]),
                                        [Usage.Activity]: schemaCreator(Usage.Activity, 'Редактирование поля с выбором активности', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT,
                                        ]),
                                        [Usage.StudentGroup]: schemaCreator(Usage.StudentGroup, 'Редактирование поля с группы студента', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT, PLACEHOLDER,
                                        ]),
                                        [Usage.Stage]: schemaCreator(Usage.Stage, 'Редактирование поля создания этапов', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT,
                                        ]),
                                        [Usage.Organisation]: schemaCreator(Usage.Stage, 'Редактирование поля ввода организации', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT,
                                        ]),
                                        [Usage.Student]: schemaCreator(Usage.Stage, 'Редактирование поля ввода организации', [
                                            NAME, DESCRIPTION, TITLE,
                                            MANDATORY, HINT,
                                        ]),

                                        // Мои системные
                                        [Usage.Task]: undefined,
                                        [Usage.Variants]: undefined,
                                        [Usage.Validator]: undefined,
                                    };
                                    src / ui / blocks / form - input / form - long - text - input.tsx;
                                    import {Intent, TextArea} from '@blueprintjs/core';
                                    import {handleStringChange} from '@blueprintjs/docs-theme';
                                    import React, {FC, memo, useCallback, useEffect, useState} from 'react';

                                    type Props = {
                                        intent: Intent;
                                        inputRef: (ref: HTMLTextAreaElement | null) => void;
                                        placeholder?: string;
                                        defaultValue?: string;
                                        onBlur?: () => void;
                                        disabled?: boolean;
                                    }

                                    export const LongTextInputView: FC<Props> = memo(({
                                                                                          placeholder,
                                                                                          intent,
                                                                                          inputRef,
                                                                                          defaultValue,
                                                                                          onBlur,
                                                                                          disabled,
                                                                                      }) => {
                                        const [value, setValue] = useState(defaultValue || '');
                                        const handleChange = useCallback(handleStringChange((textContent: string) => setValue(textContent)),
                                                                         [setValue]);

                                        useEffect(() => {
                                            // @ts-ignore
                                            inputRef && inputRef({value});
                                        }, [inputRef, value]);
                                        return (
                                            <TextArea
                                                placeholder = {placeholder}
                                        intent = {intent};
                                        fill = {true};
                                        disabled = {disabled};
                                        growVertically = {true};
                                        onChange = {handleChange};
                                        value = {value};
                                        onBlur = {onBlur};
                                        />;
                                    )
                                        ;
                                    });
                                    src / ui / blocks / form - input / form - addable - input.tsx;
                                    import {Card, EditableText, Icon, Intent} from '@blueprintjs/core';
                                    import React, {FC, memo, useCallback, useEffect, useState} from 'react';

                                    type Props = {
                                        intent: Intent;
                                        inputRef: (ref: { value: string[] } | null) => void;
                                        defaultValue?: string[];
                                    }

                                    export const AddableInputView: FC<Props> = memo((
                                                                                        {
                                                                                            intent,
                                                                                            inputRef,
                                                                                            defaultValue = [],
                                                                                        },
                                                                                    ) => {
                                        const [variants, seVariants] = useState(defaultValue);
                                        const addVariant = useCallback(() => seVariants([...variants, 'Новый вариант']), [seVariants, variants]);
                                        const deleteVariant = useCallback(
                                            (index: number) => {
                                                const newVariants = variants.filter((val: string, ind: number) => ind !== index);
                                                seVariants(newVariants);
                                            },
                                            [seVariants, variants],
                                        );

                                        useEffect(() => {
                                            inputRef && inputRef({value: variants});
                                        }, [inputRef, variants]);
                                        return (
                                            <>
                                                {
                                                    variants.map((variant: string, index: number) =>
                                                                     <>
                                                                         <EditableText
                                                                             key = {variant}
                                                    className = {'addable-input__text'}
                                                    onChange = {(value)
                                    =>
                                        {
                                            variants[index] = value;
                                        }
                                    }
                                        defaultValue = {variant};
                                        minWidth = {100};
                                        placeholder = 'Вариант ответа...'
                                                      / >
                                                      <Icon className = 'addable-input__cross';
                                        icon = 'cross';
                                        key = {`${variant}__cross`;
                                    }
                                        onClick = {();
                                    =>
                                        {
                                            deleteVariant(index);
                                        }
                                    }
                                        />
                                        < />);
                                    }
                                        <Card className = 'addable-input__plus';
                                        onClick = {addVariant} >
                                                               <Icon icon = 'plus' / >
                                                                            </Card>
                                                                            < />;
                                    )
                                        ;
                                    });
                                    src / ui / blocks / form - input / form - email - input.tsx;
                                    import {InputGroup, Intent} from '@blueprintjs/core';
                                    import React, {FC, memo} from 'react';

                                    type Props = {
                                        intent: Intent;
                                        inputRef: (ref: HTMLInputElement | null) => void;
                                        placeholder?: string;
                                        defaultValue?: string;
                                        disabled?: boolean;
                                    }

                                    export const EmailInputView: FC<Props> = memo(({
                                                                                       placeholder,
                                                                                       inputRef,
                                                                                       intent,
                                                                                       disabled,
                                                                                       defaultValue,
                                                                                   }) => {
                                        return (
                                            <InputGroup
                                                type = 'email'
                                        placeholder = {placeholder};
                                        inputRef = {inputRef};
                                        disabled = {disabled};
                                        intent = {intent};
                                        defaultValue = {defaultValue};
                                        />;
                                    )
                                        ;
                                    });
                                    src / ui / blocks / form - input / form -
                                    switch-input.tsx
                                        import
                                        {
                                            Switch;
                                        }
                                            from;
                                            '@blueprintjs/core';
                                        import {Alignment} from '@blueprintjs/core/lib/esm/common/alignment';
                                        import React, {FC, memo, useCallback, useEffect, useState} from 'react';

                                        type Props = {
                                            inputRef: (ref: { value: boolean } | null) => void;
                                            placeholder?: string;
                                            defaultValue?: boolean;
                                            disabled?: boolean;
                                        }

                                            export const SwitchInputView: FC<Props> = memo(({
                                                                                                placeholder,
                                                                                                inputRef,
                                                                                                defaultValue = false,
                                                                                                disabled,
                                                                                            }) => {
                                                const [value, setValue] = useState(defaultValue);
                                                const handleChange = useCallback(() => setValue(!value), [setValue, value]);
                                                useEffect(() => {inputRef && inputRef({value});}, [inputRef, value]);
                                                return (
                                                    <Switch alignIndicator = {Alignment.LEFT}
                                                disabled = {disabled};
                                                innerLabelChecked = 'да';
                                                innerLabel = 'нет';
                                                checked = {value};
                                                onChange = {handleChange};

                                                />;
                                            )
                                                ;
                                            });
                                            src / ui / blocks / form - input / form - short - text - input.tsx;
                                        import {InputGroup, Intent} from '@blueprintjs/core';
                                        import React, {FC, memo} from 'react';

                                        type Props = {
                                            intent: Intent;
                                            inputRef: (ref: HTMLInputElement | null) => void;
                                            onChange?: () => void;
                                            placeholder?: string;
                                            large?: boolean;
                                            onBlur?: () => void;
                                            defaultValue?: string;
                                            disabled?: boolean;
                                        }

                                            export const ShortTextInputView: FC<Props> = memo((
                                                                                                  {
                                                                                                      onChange,
                                                                                                      placeholder,
                                                                                                      onBlur,
                                                                                                      intent,
                                                                                                      inputRef,
                                                                                                      large,
                                                                                                      defaultValue,
                                                                                                      disabled,
                                                                                                  },
                                                                                              ) => {
                                                return (
                                                    <InputGroup
                                                        placeholder = {placeholder}
                                                inputRef = {inputRef};
                                                intent = {intent};
                                                large = {large};
                                                defaultValue = {defaultValue};
                                                onBlur = {onBlur};
                                                onChange = {onChange};
                                                disabled = {disabled};
                                                />;
                                            )
                                                ;
                                            });
                                            src / ui / blocks / form - input / form - file - input.tsx;
                                        import {FileInput, Icon, Intent, ProgressBar} from '@blueprintjs/core';
                                        import React, {FC, memo, useCallback, useEffect, useState} from 'react';
                                        import {useUpload} from 'react-use-upload';
                                        import {STUDENT_ID} from 'src/api/api';
                                        import {BACKEND_URL} from 'src/ui/utils/constants';

                                        type Props = {
                                            inputRef: (ref: any) => void;
                                            placeholder?: string;
                                            defaultValue?: { name: string, id: string, type: 'file' };
                                            disabled?: boolean;
                                            isMultiple?: boolean;
                                            clearRef?: (handleDelete: () => void) => void;
                                            taskId?: string;
                                        }

                                            export const FileInputView: FC<Props> = memo(({
                                                                                              placeholder,
                                                                                              inputRef,
                                                                                              disabled,
                                                                                              defaultValue,
                                                                                              clearRef,
                                                                                              taskId,
                                                                                              isMultiple = false,
                                                                                          }) => {
                                                const [files, setFiles] = useState();
                                                const [shouldIgnoreDefault, setShouldIgnoreDefault] = useState(false);
                                                const onRestart = useCallback(() => {
                                                    setFiles(undefined);
                                                }, [setFiles]);
                                                const onDeleteDefault = useCallback(() => {
                                                    setShouldIgnoreDefault(true);
                                                }, [setShouldIgnoreDefault]);
                                                const {loading, progress, error, response, done} = useUpload(files, {
                                                    // TODO выпилить uploaderId с началом работы токена
                                                    path: taskId ? `/api/v1/upload?taskId=${taskId}&uploaderId=${STUDENT_ID}` : '/api/v1/upload',
                                                    method: 'POST',
                                                    name: 'file',
                                                    fields: {name: files && files[0]?.name},
                                                });

                                                useEffect(() => {
                                                    if (done && files && !error && response.status === 200) {
                                                        inputRef({value: {name: files[0].name, id: response.response, type: 'file'}});
                                                    } else {
                                                        inputRef({value: shouldIgnoreDefault ? null : defaultValue || null});
                                                    }
                                                }, [response, defaultValue, shouldIgnoreDefault, inputRef, done, files, error]);
                                                useEffect(() => {
                                                    clearRef && clearRef(onRestart);
                                                }, [clearRef, onRestart]);

                                                if (loading && files) {
                                                    return <ProgressBar intent = {Intent.PRIMARY};
                                                    value = {progress ? progress / 100 : 0};
                                                    />;;
                                                }

                                                if (done && files && response.status === 200) {
                                                    if (error) {
                                                        return <div>
                                                            <Icon className = 'file-input__control';
                                                        icon = {'refresh'};
                                                        intent = {Intent.DANGER};
                                                        onClick = {onRestart};
                                                        /> Ошибка загрузки файла.
                                                        < /div>;;
                                                    }
                                                    return <div>
                                                        <a href = {`${BACKEND_URL}/api/v1/file/${response.response}`;
                                                }
                                                    download = {true} > {files[0].name} < /a>
                                                                      &
                                                #
                                                    160;
                                                    <Icon icon = {'cross'};
                                                    className = 'file-input__control';
                                                    onClick = {onRestart};
                                                    />
                                                    < /div>;;
                                                }

                                                if (!files && !done && !loading && !response && defaultValue && !shouldIgnoreDefault) {
                                                    return <div>
                                                        <a href = {`/${defaultValue.type}/${defaultValue.id}`;
                                                }
                                                    download = {true} > {defaultValue.name} < /a>
                                                                      &
                                                #
                                                    160;
                                                    <Icon icon = {'cross'};
                                                    className = 'file-input__control';
                                                    onClick = {onDeleteDefault};
                                                    />
                                                    < /div>;;
                                                }

                                                return (
                                                    <FileInput
                                                        text = {placeholder}
                                                buttonText = {'Выберите файл'};
                                                fill = {true};
                                                disabled = {disabled};
                                                // @ts-ignore
                                                onChange = {e
                                            =>
                                                setFiles(e.target.files);
                                            }
                                                />;
                                            )
                                                ;
                                            });
                                            src / ui / blocks / form - input / form - input.tsx;
                                        import {Card, FormGroup, H3, Icon, Intent} from '@blueprintjs/core';
                                        import React, {FC, memo, useCallback, useMemo, useState} from 'react';
                                        import {useDispatch} from 'react-redux';
                                        import {
                                            addDraftFormAttributeProperties,
                                            deleteDraftFormAttribute,
                                        } from 'src/store/actions/user-forms.actions';
                                        import {ApiResponse, Attribute, AttributeRef, AttributeValue, Form, FormMode, Usage} from 'src/types';
                                        import {OrganisationInputView} from 'src/ui/blocks/form-input/form-organisation-input';
                                        import {StageInputView} from 'src/ui/blocks/form-input/form-stage-input/form-stage-input';
                                        import {TaskInputView} from 'src/ui/blocks/form-input/form-stage-input/form-task-input';
                                        import {StudentInputView} from 'src/ui/blocks/form-input/form-student-suggest-input';
                                        import {ValidatorInputView} from 'src/ui/blocks/form-input/form-validator-input';
                                        import {FormLayout} from 'src/ui/blocks/form-layout/form-layout';
                                        import {HintLabel} from 'src/ui/blocks/hint-label/hint-label';
                                        import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                        import {USAGE_TO_FORM_MAP} from './constants/usage-to-schema-map';
                                        import {AddableInputView} from './form-addable-input';
                                        import {CheckboxInputView} from './form-checkbox-input';
                                        import {DateInputView} from './form-date-input';
                                        import {EmailInputView} from './form-email-input';
                                        import {FileInputView} from './form-file-input';
                                        import './form-input.styl';
                                        import {LongTextInputView} from './form-long-text-input';
                                        import {SearchInputView} from './form-mentor-suggest-input';
                                        import {NumberInputView} from './form-number-input';
                                        import {PasswordInputView} from './form-password-input';
                                        import {RadioInputView} from './form-radio-input';
                                        import {SelectInputView} from './form-select-input';
                                        import {ShortTextInputView} from './form-short-text-input';
                                        import {SwitchInputView} from './form-switch-input';

                                            const USAGE_TO_INPUT_MAP: {
                                                [k in Usage]: FC<{
                                                    inputRef: (ref: AttributeValue) => void;
                                                    intent: Intent;
                                                    requestVariants?: () => Promise<ApiResponse>;
                                                    placeholder?: string;
                                                    defaultValue?: AttributeValue;
                                                    disabled?: boolean;
                                                    variants?: string[]
                                                    max?: number;
                                                    min?: number;
                                                }>
                                            } = {
                                                [Usage.ShortText]: ShortTextInputView,
                                                [Usage.Email]: EmailInputView,
                                                [Usage.Password]: PasswordInputView,
                                                [Usage.Number]: NumberInputView,
                                                [Usage.LongText]: LongTextInputView,
                                                [Usage.File]: FileInputView,
                                                [Usage.Checkbox]: CheckboxInputView,
                                                [Usage.Date]: DateInputView,
                                                [Usage.Radio]: RadioInputView,
                                                [Usage.StudentGroup]: SelectInputView,
                                                [Usage.Activity]: SelectInputView,
                                                [Usage.Stage]: StageInputView,
                                                // @ts-ignore
                                                [Usage.Mentor]: SearchInputView,
                                                [Usage.Student]: StudentInputView,
                                                [Usage.Switch]: SwitchInputView,
                                                [Usage.Variants]: AddableInputView,
                                                [Usage.Validator]: ValidatorInputView,
                                                [Usage.Task]: TaskInputView,
                                                [Usage.Organisation]: OrganisationInputView,
                                            };

                                            const addDefaultValuesToForm = (form: Form, values: { [k: string]: AttributeValue }) => {
                                                form.attributes.forEach((attr: Attribute, index: number) => {
                                                    if (attr.name in values) {
                                                        form.attributes[index].defaultValue = values[attr.name];
                                                    }
                                                });
                                                return form;
                                            };

                                        type Props = Attribute & {
                                            inputRef: (ref: AttributeRef) => void;
                                            // Приходит отрицательным (-1) для форм вне списка форм пользователя.
                                            // Фактически запрещает редактирование
                                            formIndex: number;

                                            index: number;
                                            error?: string;
                                            onBlur?: () => void;
                                            onChange?: () => void;
                                            isEditable?: boolean;
                                            isDeletable?: boolean;
                                            isPlaceholder?: boolean;
                                            disabled?: boolean;

                                            isAddable?: boolean;
                                            isAdded?: boolean;
                                            triggerIsAdded?: () => void;

                                            clearRef?: (handleDelete: () => void) => void;
                                        }

                                            export const FormInput: FC<Props> = memo(({
                                                                                          formIndex,
                                                                                          index,
                                                                                          id,
                                                                                          mandatory,
                                                                                          title,
                                                                                          hint,
                                                                                          isEditable,
                                                                                          isDeletable,
                                                                                          error,
                                                                                          usage,
                                                                                          name,
                                                                                          isPlaceholder,
                                                                                          description,
                                                                                          placeholder,
                                                                                          min,
                                                                                          max,
                                                                                          variants,
                                                                                          validators,
                                                                                          inputRef,
                                                                                          disabled,
                                                                                          defaultValue,
                                                                                          isAddable,
                                                                                          isAdded: initialIsAdded,
                                                                                          triggerIsAdded,
                                                                                          ...props
                                                                                      }) => {
                                                const dispatch = useDispatch();
                                                const cppwApi = useCppwApiContext();
                                                const [errors, setErrors] = useState();
                                                const [isAdded, setIsAdded] = useState(initialIsAdded);
                                                const handleIsAdded = useCallback(() => {
                                                    setIsAdded(!isAdded);
                                                    triggerIsAdded && triggerIsAdded();
                                                }, [setIsAdded, triggerIsAdded, isAdded]);

                                                const labelInfo = useMemo(() => (
                                                    <span>
                                                        <span className = 'label-info' > {mandatory ? '*' : ''} < /span>
                                                {
                                                    hint ? <HintLabel text = {hint}/> : null}
                                                                                   < /span>;
                                                )
                                            ,
                                                [mandatory, hint];
                                            )
                                                ;
                                                const label = useMemo(() => (
                                                    <>
                                                        {
                                                            isAddable ? <Icon className = 'form-input__label-icon'
                                                                        icon = {isAdded ? 'small-tick' : 'small-plus'}
                                                            intent = {isAdded ? Intent.SUCCESS : Intent.DANGER}
                                                            onClick = {handleIsAdded}
                                                /> : null};
                                                {
                                                    title;
                                                }
                                                </>;
                                            ),
                                                [title, isAddable, isAdded, handleIsAdded];
                                            )
                                                ;
                                                const intent = error ? Intent.DANGER : Intent.NONE;
                                                const Component = USAGE_TO_INPUT_MAP[usage];

                                                const onSaveAttribute = useCallback((values, attributes) => {
                                                    const newAttribute = attributes ? attributes.reduce((res: { [k: string]: AttributeValue },
                                                                                                         item: Attribute,
                                                                                                         ind: number) => {
                                                        if (values && ind in values && values[ind] !== undefined) {
                                                            if (item.usage === Usage.Number) {
                                                                res[item.name] = parseFloat(values[ind]);
                                                            } else {
                                                                res[item.name] = values[ind];
                                                            }
                                                        }
                                                        return res;
                                                    }, {usage}) : {};

                                                    if (index !== undefined) {
                                                        newAttribute.isPlaceholder = false;
                                                        cppwApi && formIndex > -1 && cppwApi.saveAttribute(id, index, newAttribute, formIndex);
                                                    }
                                                }, [cppwApi, formIndex, id, index, usage]);
                                                const onCancelAttributeEdit = useCallback(() => {
                                                    if (index !== undefined && formIndex > -1) {
                                                        if (id === DEFAULT_ATTRIBUTE_ID) {
                                                            dispatch(deleteDraftFormAttribute(formIndex, index));
                                                        } else {
                                                            dispatch(addDraftFormAttributeProperties(formIndex, index, {isPlaceholder: false}));
                                                        }
                                                    }
                                                }, [dispatch, id, index, formIndex]);
                                                const onSetError = useCallback((newErrors) => {
                                                    setErrors(newErrors);
                                                }, [setErrors]);
                                                const onEditAttribute = useCallback(() => {
                                                    if (index !== undefined) {
                                                        if (formIndex > -1) {
                                                            dispatch(addDraftFormAttributeProperties(formIndex, index, {
                                                                isPlaceholder: !isPlaceholder,
                                                            }));
                                                        }
                                                    }
                                                }, [formIndex, isPlaceholder, dispatch, index]);
                                                const onDeleteAttribute = useCallback(() => {
                                                    if (index !== undefined && formIndex > -1) {
                                                        dispatch(deleteDraftFormAttribute(formIndex, index));
                                                    }
                                                }, [index, formIndex, dispatch]);

                                                if (isPlaceholder && formIndex > -1) {
                                                    const form = USAGE_TO_FORM_MAP[usage];
                                                    return form ? <Card className = 'form-input__plus' >
                                                                                    <FormLayout
                                                                                        index = { - 1
                                                }
                                                    {...
                                                        addDefaultValuesToForm(form, {
                                                            title,
                                                            hint,
                                                            name,
                                                            mandatory,
                                                            placeholder,
                                                            description,
                                                            min,
                                                            max,
                                                            variants,
                                                            validators,
                                                        });
                                                    }
                                                    HeaderComponent = {H3};
                                                    mode = {FormMode.Fill};
                                                    errors = {errors};
                                                    onSetError = {onSetError};
                                                    handleCancel = {onCancelAttributeEdit};
                                                    onFormSubmit = {onSaveAttribute};
                                                    />
                                                    < /Card> : null;;
                                                }

                                                return Component ? (
                                                                     <FormGroup
                                                                         key = {id}
                                                       className = 'form-input';
                                                label = {label};
                                                labelFor = {id};
                                                labelInfo = {labelInfo};
                                                helperText = {error};
                                                intent = {intent}
                                                >
                                                <Component
                                                    intent = {intent};
                                                // TODO что-то тут не так
                                                requestVariants = {usage === Usage.Activity && cppwApi ? () => cppwApi.get(
                                                    'formatted/activities/not-finished') : undefined;
                                            }
                                                inputRef = {inputRef};
                                                placeholder = {placeholder};
                                                defaultValue = {defaultValue};
                                                disabled = {disabled};
                                                variants = {variants};
                                                max = {max};
                                                min = {min};
                                                {...
                                                    props;
                                                }
                                                />;
                                                {
                                                    isEditable && Boolean(USAGE_TO_FORM_MAP[usage]) && <Icon className = 'form-input__cog';
                                                    icon = 'cog';
                                                    onClick = {onEditAttribute};
                                                    />};
                                                    {
                                                        isDeletable && <Icon className = 'form-input__cross';
                                                        icon = 'cross';
                                                        onClick = {onDeleteAttribute};
                                                        />}
                                                        < /FormGroup>;
                                                    )
                                            :
                                                null;
                                            });
                                            src / ui / blocks / form - input / form - student - suggest - input.tsx;
                                        import {Intent} from '@blueprintjs/core';
                                        import React, {FC, memo} from 'react';
                                        import {SearchInputView} from 'src/ui/blocks/form-input/form-mentor-suggest-input';

                                        type Student = {
                                            name: string;
                                            id: string;
                                        }
                                        type Props = {
                                            intent: Intent;
                                            inputRef: (ref: { value: Student } | null) => void;
                                            placeholder?: string;
                                            onChange?: () => void;
                                            defaultValue?: Student;
                                            disabled?: boolean;
                                        }
                                            export const StudentInputView: FC<Props> = memo((
                                                                                                {
                                                                                                    intent,
                                                                                                    inputRef,
                                                                                                    defaultValue,
                                                                                                    disabled,
                                                                                                },
                                                                                            ) => {
                                                return (<SearchInputView
                                                    key = {'query'}
                                                inputRef = {inputRef};
                                                intent = {intent};
                                                // TODO: как появится ручка - пофиксить path
                                                path = {''};
                                                defaultValue = {defaultValue};
                                                disabled = {disabled};
                                                placeholder = {`Начните имя студента...`;
                                            }
                                                />;
                                            )
                                                ;
                                            });
                                            src / ui / blocks / form - input / form - password - input.tsx;
                                        import {InputGroup, Intent} from '@blueprintjs/core';
                                        import React, {FC, memo} from 'react';

                                        type Props = {
                                            intent: Intent;
                                            inputRef: (ref: HTMLInputElement | null) => void;
                                            placeholder?: string;
                                            defaultValue?: string;
                                            disabled?: boolean;
                                        }

                                            export const PasswordInputView: FC<Props> = memo(({
                                                                                                  placeholder,
                                                                                                  intent,
                                                                                                  inputRef,
                                                                                                  defaultValue,
                                                                                                  disabled,
                                                                                              }) => {

                                                return (
                                                    <InputGroup
                                                        type = {'password'}
                                                disabled = {disabled};
                                                placeholder = {placeholder};
                                                inputRef = {inputRef};
                                                intent = {intent};
                                                defaultValue = {defaultValue};
                                                />;
                                            )
                                                ;
                                            });
                                            src / ui / blocks / form - input / form - validator - input.tsx;
                                        import {Card, EditableText, Icon, Intent} from '@blueprintjs/core';
                                        import React, {FC, memo, useCallback, useEffect, useState} from 'react';
                                        import {Validator} from 'src/types';

                                        type Props = {
                                            intent: Intent;
                                            inputRef: (ref: { value: Validator[] } | null) => void;
                                            defaultValue?: Validator[];
                                        }

                                            export const ValidatorInputView: FC<Props> = memo((
                                                                                                  {
                                                                                                      intent,
                                                                                                      inputRef,
                                                                                                      defaultValue = [],
                                                                                                  },
                                                                                              ) => {
                                                const [variants, seVariants] = useState(defaultValue);
                                                const addVariant = useCallback(() => seVariants([...variants, {regexp: '', message: ''}]),
                                                                               [seVariants, variants]);
                                                const deleteVariant = useCallback(
                                                    (index: number) => {
                                                        const newVariants = variants.filter((val: Validator, ind: number) => ind !== index);
                                                        seVariants(newVariants);
                                                    },
                                                    [seVariants, variants],
                                                );

                                                useEffect(() => {
                                                    inputRef && inputRef({value: variants});
                                                }, [inputRef, variants]);
                                                return (
                                                    <>
                                                        {
                                                            variants.map(({regexp, message}: Validator, index: number) =>
                                                                             <div className = {'validator-input'} key = {index} >
                                                                                                                                <div className = {'validator-input__text'} >
                                                                                                                                                                           <EditableText
                                                                                                                                                                               onChange = {(
                                                                value)
                                            =>
                                                {
                                                    variants[index].regexp = value;
                                                }
                                            }
                                                defaultValue = {String(regexp)};
                                                minWidth = {100};
                                                placeholder = 'Регулярное вырожение...'
                                                              / >
                                                              <EditableText
                                                                  onChange = {(value);
                                            =>
                                                {
                                                    variants[index].message = value;
                                                }
                                            }
                                                defaultValue = {message};
                                                minWidth = {100};
                                                placeholder = 'Сообщение об ошибке...'
                                                              / >
                                                              </div>
                                                              < Icon;
                                                className = 'validator-input__cross';
                                                icon = 'cross';
                                                key = {`${message}__cross`;
                                            }
                                                onClick = {();
                                            =>
                                                {
                                                    deleteVariant(index);
                                                }
                                            }
                                                />
                                                < /div>);
                                            }
                                                <Card className = 'addable-input__plus';
                                                onClick = {addVariant} >
                                                                       <Icon icon = 'plus' / >
                                                                                    </Card>
                                                                                    < />;
                                            )
                                                ;
                                            });
                                            src / ui / blocks / form - input / form - stage - input / form - task - input.tsx;
                                        import {Card, Icon} from '@blueprintjs/core';
                                        import React, {FC, memo, useCallback, useEffect, useState} from 'react';
                                        import {Task} from 'src/types';
                                        import {EditableTaskView} from 'src/ui/blocks/form-input/form-stage-input/editable-task-view';

                                            export const DEFAULT_TASK_ID = 'taskмяумяуякискис';
                                        export type EditableTask = Task & { isEditing?: boolean }
                                            const NEW_TASK: EditableTask = {
                                                id: DEFAULT_TASK_ID,
                                                name: '',
                                                description: '',
                                                isUploadable: false,
                                                isEditing: true,
                                            };

                                        type Props = {
                                            inputRef: (ref: { value: Task[] } | null) => void;
                                            defaultValue?: Task[];
                                            disabled?: boolean;
                                        }
                                            export const TaskInputView: FC<Props> = memo((
                                                                                             {
                                                                                                 inputRef,
                                                                                                 disabled,
                                                                                                 defaultValue = [],
                                                                                             },
                                                                                         ) => {
                                                const [tasks, setTasks] = useState(defaultValue);
                                                const addTask = useCallback(() => setTasks([...tasks, NEW_TASK]), [setTasks, tasks]);
                                                const deleteTask = (index: number) => () => {
                                                    const newTasks = tasks.filter((val: Task, ind: number) => ind !== index);
                                                    setTasks(newTasks);
                                                };
                                                const editTask = (index: number) => (newTask: EditableTask) => {
                                                    const newTasks = tasks.map((task: EditableTask, ind: number) => ind === index ? newTask : task);
                                                    setTasks(newTasks);
                                                };

                                                useEffect(() => {
                                                    inputRef && inputRef({value: tasks});
                                                }, [inputRef, tasks]);

                                                return (
                                                    <div className = {`task-input ${disabled ? '_disabled' : ''}`
                                            }>
                                                {
                                                    tasks.map((task: EditableTask, index: number) => <EditableTaskView {...task}
                                                    editTask = {editTask(index)};
                                                    deleteTask = {deleteTask(index)};
                                                    />);
                                                }
                                                <Card className = 'task-input__plus';
                                                onClick = {addTask} >
                                                                    <Icon icon = 'plus' / >
                                                                                 </Card>
                                                                                 < /div>;
                                            )
                                                ;
                                            });
                                            src / ui / blocks / form - input / form - stage - input / form - stage - input.tsx;
                                        import {Card, Icon} from '@blueprintjs/core';
                                        import React, {FC, memo, useCallback, useEffect, useState} from 'react';
                                        import {Stage} from 'src/types';
                                        import {EditableStageView} from 'src/ui/blocks/form-input/form-stage-input/editable-stage-view';

                                            export const DEFAULT_STAGE_ID = 'мяумяуякискис';
                                        export type EditableStage = Stage & { isEditing?: boolean }
                                            const NEW_STAGE: EditableStage = {
                                                id: DEFAULT_STAGE_ID,
                                                name: '',
                                                description: '',
                                                // @ts-ignore
                                                startDate: undefined,
                                                // @ts-ignore
                                                endDate: undefined,
                                                // @ts-ignore
                                                coefficient: undefined,
                                                tasks: [],
                                                hasForcedGrade: false,
                                                isEditing: true,
                                            };

                                        type Props = {
                                            inputRef: (ref: { value: Stage[] } | null) => void;
                                            onChange?: () => void;
                                            defaultValue?: Stage[];
                                            disabled?: boolean;
                                        }
                                            export const StageInputView: FC<Props> = memo((
                                                                                              {
                                                                                                  inputRef,
                                                                                                  defaultValue = [],
                                                                                                  disabled,
                                                                                              },
                                                                                          ) => {
                                                const [stages, setStages] = useState(defaultValue);
                                                const addStage = useCallback(() => setStages([...stages, NEW_STAGE]), [setStages, stages]);
                                                const deleteStage = useCallback(
                                                    (index: number) => () => {
                                                        const newStages = stages.filter((val: Stage, ind: number) => ind !== index);
                                                        setStages(newStages);
                                                    },
                                                    [setStages, stages],
                                                );
                                                const editStage = (index: number) => (newStage: EditableStage) => {
                                                    const newStages = stages.map((stage: EditableStage, ind: number) => ind === index
                                                                                                                        ? newStage
                                                                                                                        : stage);
                                                    setStages(newStages);
                                                };

                                                useEffect(() => {
                                                    inputRef && inputRef({value: stages});
                                                }, [inputRef, stages]);

                                                return (
                                                    <div className = {`stage-input ${disabled ? '_disabled' : ''}`
                                            }>
                                                {
                                                    stages.map((stage: EditableStage, index: number) => <EditableStageView {...stage}
                                                    editStage = {editStage(index)};
                                                    deleteStage = {deleteStage(index)};
                                                    />);
                                                }
                                                <Card className = 'stage-input__plus';
                                                onClick = {addStage} >
                                                                     <Icon icon = 'plus' / >
                                                                                  </Card>
                                                                                  < /div>;
                                            )
                                                ;
                                            });
                                            src / ui / blocks / form - input / form - stage - input / editable - stage - view.tsx;
                                        import {Card, H3, Icon} from '@blueprintjs/core';
                                        import React, {FC, useCallback, useMemo, useState} from 'react';
                                        import {Attribute, FormMode, FormType, Usage} from 'src/types';
                                        import {EditableStage} from 'src/ui/blocks/form-input/form-stage-input/form-stage-input';
                                        import {FormLayout} from 'src/ui/blocks/form-layout/form-layout';
                                        import {StageMode, StageView} from 'src/ui/blocks/stage-view/stage-view';

                                            const STAGE_ATTRIBUTES: Attribute[] = [
                                                {
                                                    id: `${Usage.Stage}-stageNumber`,
                                                    name: 'stageNumber',
                                                    usage: Usage.Number,
                                                    title: 'Номер этапа',
                                                    min: 1,
                                                    mandatory: true,
                                                    validators: [],
                                                },
                                                {
                                                    id: `${Usage.Stage}-name`,
                                                    name: 'name',
                                                    usage: Usage.ShortText,
                                                    title: 'Наименование этапа',
                                                    mandatory: true,
                                                    validators: [],
                                                },
                                                {
                                                    id: `${Usage.Stage}-description`,
                                                    name: 'description',
                                                    usage: Usage.LongText,
                                                    title: 'Описание этапа',
                                                    mandatory: false,
                                                    validators: [],
                                                },
                                                {
                                                    id: `${Usage.Stage}-startDate`,
                                                    name: 'startDate',
                                                    usage: Usage.Date,
                                                    title: 'Дата начала этапа',
                                                    mandatory: true,
                                                    validators: [],
                                                },
                                                {
                                                    id: `${Usage.Stage}-endDate`,
                                                    name: 'endDate',
                                                    usage: Usage.Date,
                                                    title: 'Дата завершения этапа',
                                                    mandatory: true,
                                                    validators: [],
                                                },
                                                {
                                                    id: `${Usage.Stage}-coefficient`,
                                                    name: 'coefficient',
                                                    usage: Usage.Number,
                                                    title: 'Коэффициент этапа в оценке',
                                                    mandatory: true,
                                                    max: 1,
                                                    min: 0,
                                                    validators: [],
                                                },
                                                {
                                                    id: `${Usage.Stage}-hasForcedGrade`,
                                                    name: 'hasForcedGrade',
                                                    usage: Usage.Switch,
                                                    title: 'Является ли оценка ментора итоговой для данного этапа?',
                                                    mandatory: false,
                                                    validators: [],
                                                },
                                                {
                                                    id: `${Usage.Stage}-tasks`,
                                                    name: 'tasks',
                                                    usage: Usage.Task,
                                                    title: 'Задания этапа',
                                                    mandatory: false,
                                                    validators: [],
                                                },
                                            ];
                                        type Props = EditableStage & {
                                            deleteStage: () => void;
                                            editStage: (stage: EditableStage) => void;
                                        }
                                            export const EditableStageView: FC<Props> = ({id, name, stageNumber, description, startDate, endDate, tasks, hasForcedGrade, coefficient, isEditing, editStage, deleteStage}) => {
                                                const [errors, setErrors] = useState();
                                                const attributes = useMemo(() => {
                                                    return [stageNumber,
                                                            name,
                                                            description,
                                                            startDate,
                                                            endDate,
                                                            coefficient,
                                                            hasForcedGrade,
                                                            tasks].map((val, ind) => ({
                                                        ...STAGE_ATTRIBUTES[ind],
                                                        defaultValue: val,
                                                    }));
                                                }, [stageNumber, name, description, startDate, endDate, coefficient, hasForcedGrade, tasks]);
                                                const handleCancel = useCallback(() => {
                                                                                     if (id !== DEFAULT_STAGE_ID) {
                                                                                         editStage({
                                                                                                       id,
                                                                                                       stageNumber,
                                                                                                       name,
                                                                                                       description,
                                                                                                       startDate,
                                                                                                       endDate,
                                                                                                       hasForcedGrade,
                                                                                                       coefficient,
                                                                                                       tasks,
                                                                                                       isEditing: false,
                                                                                                   });
                                                                                     } else {
                                                                                         deleteStage();
                                                                                     }
                                                                                 },
                                                                                 [hasForcedGrade,
                                                                                  stageNumber,
                                                                                  coefficient,
                                                                                  id,
                                                                                  name,
                                                                                  description,
                                                                                  startDate,
                                                                                  endDate,
                                                                                  tasks,
                                                                                  editStage,
                                                                                  deleteStage]);
                                                const handleSave = useCallback((values) => {
                                                    editStage({
                                                                  id: id + '1',
                                                                  stageNumber: parseInt(values[0]) || 0,
                                                                  name: values[1],
                                                                  description: values[2],
                                                                  startDate: values[3],
                                                                  endDate: values[4],
                                                                  coefficient: Number(values[5]),
                                                                  hasForcedGrade: values[6],
                                                                  tasks: values[7],
                                                                  isEditing: false,
                                                              });
                                                }, [editStage, id]);
                                                if (isEditing) {
                                                    return <Card className = {`stage-input__item`;
                                                }
                                                    key = {id} >
                                                               <FormLayout id = {id};
                                                    // Ставим какой-то, чтобы удовлетворить TS. Использоваться не будет.
                                                    type = {FormType.Questionnaire};
                                                    HeaderComponent = {H3};
                                                    title = {'Редактирование этапа'};
                                                    attributes = {attributes};
                                                    mode = {FormMode.Fill};
                                                    buttonName = 'Сохранить';
                                                    errors = {errors};
                                                    onFormSubmit = {handleSave};
                                                    onSetError = {setErrors};
                                                    handleCancel = {handleCancel};
                                                    index = { - 1;
                                                }
                                                    />
                                                    < /Card>;;
                                                }
                                                return <div className = 'stage-input__stage' >
                                                                        <StageView id = {id};
                                                className = 'stage-input__stage-view';
                                                name = {name};
                                                description = {description};
                                                endDate = {endDate};
                                                startDate = {startDate};
                                                coefficient = {coefficient};
                                                hasForcedGrade = {hasForcedGrade};
                                                stageMode = {StageMode.All};
                                                stageNumber = {stageNumber};
                                                tasks = {tasks};
                                                />
                                                < Icon;
                                                className = 'stage-input__cross';
                                                icon = 'cog';
                                                onClick = {();
                                            =>
                                                editStage({
                                                              id,
                                                              stageNumber,
                                                              name,
                                                              description,
                                                              startDate,
                                                              endDate,
                                                              tasks,
                                                              hasForcedGrade,
                                                              coefficient,
                                                              isEditing: true,
                                                          });
                                            }
                                                />
                                                < Icon;
                                                className = 'stage-input__cross';
                                                icon = 'cross';
                                                onClick = {deleteStage};
                                                />
                                                < /div>;;
                                            };
                                            src / ui / blocks / form - input / form - stage - input / editable - task - view.tsx;
                                        import {Card, H3, Icon} from '@blueprintjs/core';
                                        import React, {FC, useCallback, useMemo, useState} from 'react';
                                        import {Attribute, FormMode, FormType, Usage} from 'src/types';
                                        import {EditableTask} from 'src/ui/blocks/form-input/form-stage-input/form-task-input';
                                        import {FormLayout} from 'src/ui/blocks/form-layout/form-layout';
                                        import {StageMode, TaskView} from 'src/ui/blocks/stage-view/stage-view';

                                            const TASK_ATTRIBUTES: Attribute[] = [
                                                {
                                                    id: `${Usage.Task}-name`,
                                                    name: 'name',
                                                    usage: Usage.ShortText,
                                                    title: 'Наименование задания',
                                                    mandatory: true,
                                                    validators: [],
                                                },
                                                {
                                                    id: `${Usage.Task}-description`,
                                                    name: 'description',
                                                    usage: Usage.LongText,
                                                    title: 'Описание задания',
                                                    mandatory: false,
                                                    validators: [],
                                                },
                                                {
                                                    id: `${Usage.Task}-isUploadable`,
                                                    name: 'isUploadable',
                                                    usage: Usage.Switch,
                                                    title: 'Нужно ли загружать в него файл?',
                                                    mandatory: true,
                                                    validators: [],
                                                },
                                            ];
                                        type Props = EditableTask & {
                                            editTask: (task: EditableTask) => void;
                                            deleteTask: () => void;
                                        }
                                            export const EditableTaskView: FC<Props> = ({id, name, description, isUploadable, isEditing, editTask, deleteTask}) => {
                                                const [errors, setErrors] = useState();
                                                const attributes = useMemo(() => {
                                                    return [name, description, isUploadable].map((val, ind) => ({
                                                        ...TASK_ATTRIBUTES[ind],
                                                        defaultValue: val,
                                                    }));
                                                }, [name, description, isUploadable]);
                                                const handleCancel = useCallback(() => {
                                                    if (id !== DEFAULT_TASK_ID) {
                                                        editTask({id, name, description, isUploadable, isEditing: false});
                                                    } else {
                                                        deleteTask();
                                                    }
                                                }, [id, name, description, isUploadable, editTask, deleteTask]);
                                                const handleSave = useCallback((values) => {
                                                    editTask({
                                                                 id: id + '1',
                                                                 name: values[0],
                                                                 description: values[1],
                                                                 isUploadable: values[2],
                                                                 isEditing: false,
                                                             });
                                                }, [editTask, id]);
                                                const handleEdit = useCallback(() => {
                                                    editTask({id, name, description, isUploadable, isEditing: true});
                                                }, [id, name, description, isUploadable, editTask]);

                                                if (isEditing) {
                                                    return <Card className = {`task-input__item`;
                                                }>
                                                    <FormLayout id = {id};
                                                    // Ставим какой-то, чтобы удовлетворить TS. Использоваться не будет.
                                                    type = {FormType.Questionnaire};
                                                    HeaderComponent = {H3};
                                                    title = {'Редактирование задания этапа'};
                                                    attributes = {attributes};
                                                    mode = {FormMode.Fill};
                                                    buttonName = 'Сохранить';
                                                    errors = {errors};
                                                    onFormSubmit = {handleSave};
                                                    onSetError = {setErrors};
                                                    handleCancel = {handleCancel};
                                                    index = { - 1;
                                                }
                                                    />
                                                    < /Card>;;
                                                }
                                                return <div className = 'task-input__task' >
                                                                        <TaskView id = {id};
                                                className = 'task-input__task-view';
                                                name = {name};
                                                description = {description};
                                                stageMode = {StageMode.All};
                                                isUploadable = {isUploadable};
                                                />
                                                < Icon;
                                                className = 'task-input__cross';
                                                icon = 'cog';
                                                key = {`${name}__cog`;
                                            }
                                                onClick = {handleEdit};
                                                />
                                                < Icon;
                                                className = 'task-input__cross';
                                                icon = 'cross';
                                                key = {`${name}__cross`;
                                            }
                                                onClick = {deleteTask};
                                                />
                                                < /div>;;
                                            };
                                            src / ui / blocks / home - page - paragraph / home - page - paragraph.tsx;
                                        import {H1, H2, H3} from '@blueprintjs/core';

                                        import React, {FC} from 'react';
                                        import './home-page-heading.styl';

                                        type Descriptor = {
                                            text: string;
                                            link?: string;
                                        }
                                        type Props = {
                                            titleClassName?: string;
                                            title: string;
                                            description?: string | Descriptor[];
                                            mode: number;
                                        }

                                            export const HomePageParagraph: FC<Props> = ({title, description, mode, titleClassName}) => {
                                                return <>
                                                           {mode === 1 && <H1 className = {`home-page-heading__title ${titleClassName}`;
                                            }>
                                                {
                                                    title;
                                                }
                                                </H1>};
                                                {
                                                    mode === 2 && <H2 className = {`home-page-heading__title ${titleClassName}`;
                                                }>
                                                    {
                                                        title;
                                                    }
                                                    </H2>};
                                                    {
                                                        mode === 3 && <H3 className = {`home-page-heading__title ${titleClassName}`;
                                                    }>
                                                        {
                                                            title;
                                                        }
                                                        </H3>};
                                                        {
                                                            description && <p className = 'home-page-heading__description' > {
                                                                Array
                                                                .isArray(description) ? description.map(({text, link}) => link ? <a
                                                                    target = '_blank' href = {link} rel = 'noopener noreferrer' > {text} < /a> : text) : description}</
                                                                p >
                                                        }
                                                            </>;;
                                                        }
                                                        ;
                                                        src / ui / blocks / chat - users / chat - users.tsx;
                                                        import {
                                                            Button,
                                                            ButtonGroup,
                                                            Classes,
                                                            EditableText,
                                                            H1,
                                                            InputGroup,
                                                            Intent,
                                                        } from '@blueprintjs/core';
                                                        import React, {FC, useCallback, useEffect, useMemo, useRef, useState} from 'react';
                                                        import AutoSizer from 'react-virtualized-auto-sizer';
                                                        import {FixedSizeList as List} from 'react-window';
                                                        import {getRandomId} from 'src/api/api';
                                                        import {
                                                            addChatUser,
                                                            deleteChat,
                                                            deleteChatUser,
                                                            editChat,
                                                        } from 'src/store/actions/chats.actions';
                                                        import {ChatState} from 'src/store/reducers/chats.reducer';
                                                        import {AsyncStatus, AttributesByUserRole, ProfileOrSearchItem} from 'src/types';
                                                        import {SimpleChatUserCard} from 'src/ui/blocks/chat-user-card/chat-user-card';
                                                        import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                                                        import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                                        import './chat-users.styl';

                                                        type Props = {
                                                            chatIndex: number;
                                                            title: string;
                                                            isEditing: boolean;
                                                            attributes: AttributesByUserRole;
                                                            users: ProfileOrSearchItem[];
                                                            id: string;
                                                            backup?: ChatState;
                                                        }

                                                        export const ChatUsers: FC<Props> = ({chatIndex, title, isEditing, id, users, backup}) => {
                                                            const cppwApi = useCppwApiContext();
                                                            const [filter, setFilter] = useState('');
                                                            const logs = useRef<any[]>([]);
                                                            const onChange = useCallback(({target}: any) => {
                                                                setFilter(String(target.value)
                                                                              .toLowerCase());
                                                            }, [setFilter]);
                                                            const [allUsersStatus, setAllUsersStatus] = useState(AsyncStatus.Initial);
                                                            const [allUsers, setAllUsers] = useState<ProfileOrSearchItem[]>([]);
                                                            const filteredUsers = useMemo(() => users.filter(({name}) => name.toLowerCase().includes(
                                                                filter)), [filter, users]);
                                                            const filteredAllUsers = useMemo(() => allUsers.filter(({name}) => name.toLowerCase()
                                                                                                                                   .includes(filter)),
                                                                                             [filter, allUsers]);

                                                            const wrapperStyle = useMemo(() => {
                                                                if (window.innerWidth <= 800) {
                                                                    return {height: Math.min(34 * users.length, window.innerHeight / 2)};
                                                                }
                                                                return undefined;
                                                            }, [users.length]);
                                                            const editableWrapperStyle = useMemo(() => {
                                                                if (window.innerWidth <= 800) {
                                                                    return {height: Math.min(34 * allUsers.length, window.innerHeight / 2)};
                                                                }
                                                                return undefined;
                                                            }, [allUsers.length]);

                                                            const onChangeTitle = useCallback((name) => {
                                                                cppwApi && cppwApi.store.dispatch(editChat(chatIndex,
                                                                                                           {name}));
                                                            }, [chatIndex, cppwApi]);
                                                            const onEditFinished = useCallback(() => {
                                                                                                   cppwApi && cppwApi.saveChat(chatIndex, {id, users, name: title}, logs.current, () => {
                                                                                                       cppwApi && cppwApi.store.dispatch(editChat(chatIndex, {isEditing: false}));
                                                                                                       logs.current = [];
                                                                                                   });
                                                                                               },
                                                                                               [id, users, title, chatIndex, cppwApi]);
                                                            const onCancel = useCallback(() => {
                                                                                             if (backup) {
                                                                                                 cppwApi && cppwApi.store.dispatch(editChat(chatIndex,
                                                                                                                                            {...backup, isEditing: false}));
                                                                                             } else {
                                                                                                 cppwApi && cppwApi.store.dispatch(deleteChat(chatIndex));
                                                                                             }
                                                                                             logs.current = [];
                                                                                         },
                                                                                         [backup, chatIndex, cppwApi]);
                                                            const requestAllUsersForMailGroups = useCallback(() => {
                                                                if (isEditing && allUsersStatus !== AsyncStatus.Pending && allUsersStatus !== AsyncStatus.Success) {
                                                                    cppwApi && cppwApi.requestAllUsersForMailGroups(
                                                                        () => {
                                                                            setAllUsersStatus(AsyncStatus.Pending);
                                                                        },
                                                                        (result) => {
                                                                            setAllUsers(result);
                                                                            setAllUsersStatus(AsyncStatus.Success);
                                                                        },
                                                                        () => {
                                                                            setAllUsersStatus(AsyncStatus.Error);
                                                                        },
                                                                    );
                                                                }
                                                            }, [cppwApi, allUsersStatus, isEditing]);
                                                            const Row = useCallback(({index, style}) => (
                                                                <div style = {style} > <SimpleChatUserCard key = {filteredUsers[index].id}
                                                            userName = {filteredUsers[index].name};
                                                            userId = {filteredUsers[index].id};
                                                            /></;
                                                            div >
                                                        ),
                                                            [filteredUsers];
                                                        )
                                                            ;
                                                            const EditableRow = useCallback(({index, style}) => (
                                                                <div style = {style} > <SimpleChatUserCard key = {filteredAllUsers[index].id}
                                                            isAdded = {users.some(({id}) => id === filteredAllUsers[index].id)};
                                                            userName = {filteredAllUsers[index].name};
                                                            handleAdd = {();
                                                        =>
                                                            {
                                                                let wasFiltered = false;
                                                                logs.current = logs.current.filter(({about}) => {
                                                                    if (filteredAllUsers[index].id === about.id) {
                                                                        wasFiltered = true;
                                                                        return false;
                                                                    } else {
                                                                        return true;
                                                                    }
                                                                });
                                                                if (!wasFiltered) {
                                                                    logs.current.push({
                                                                                          id: getRandomId(),
                                                                                          date: (new Date()).toISOString(),
                                                                                          message: 'Добавлен пользователь',
                                                                                          about: {
                                                                                              name: filteredAllUsers[index].name,
                                                                                              id: filteredAllUsers[index].id,
                                                                                              type: 'user',
                                                                                          },
                                                                                      });
                                                                }
                                                                cppwApi && cppwApi.store.dispatch(addChatUser(chatIndex,
                                                                                                              filteredAllUsers[index]));
                                                            }
                                                        }
                                                            handleDelete = {();
                                                        =>
                                                            {
                                                                let wasFiltered = false;
                                                                logs.current = logs.current.filter(({about}) => {
                                                                    if (filteredAllUsers[index].id === about.id) {
                                                                        wasFiltered = true;
                                                                        return false;
                                                                    } else {
                                                                        return true;
                                                                    }
                                                                });
                                                                if (!wasFiltered) {
                                                                    logs.current.push({
                                                                                          id: getRandomId(),
                                                                                          date: (new Date()).toISOString(),
                                                                                          message: 'Удален пользователь',
                                                                                          about: {
                                                                                              name: filteredAllUsers[index].name,
                                                                                              id: filteredAllUsers[index].id,
                                                                                              type: 'user',
                                                                                          },
                                                                                      });
                                                                }
                                                                cppwApi && cppwApi.store.dispatch(deleteChatUser(chatIndex,
                                                                                                                 filteredAllUsers[index].id));
                                                            }
                                                        }
                                                            userId = {filteredAllUsers[index].id};
                                                            /></;
                                                            div >
                                                        ),
                                                            [chatIndex, cppwApi, users, filteredAllUsers];
                                                        )
                                                            ;

                                                            useEffect(() => {
                                                                requestAllUsersForMailGroups();
                                                            }, [requestAllUsersForMailGroups]);

                                                            if (isEditing) {
                                                                return <>
                                                                    <H1 className = 'chat-users__title-wrapper' >
                                                                                    <EditableText
                                                                                        className = {'chat-users__title'};
                                                                onChange = {onChangeTitle};
                                                                placeholder = 'Наименование группы контактов...';
                                                                value = {title};
                                                                />
                                                                < /H1>
                                                                < LoadableView;
                                                                status = {allUsersStatus};
                                                                onRetry = {requestAllUsersForMailGroups};
                                                                errorTitle = 'Ошибка загрузки списка всех пользователей';
                                                                errorSubtitle = 'Нажмите для повтора.' >
                                                                                <InputGroup className = {`${Classes.ROUND} ${Classes.FILL} search`;
                                                            }
                                                                leftIcon = 'search';
                                                                value = {filter};
                                                                onChange = {onChange};
                                                                placeholder = 'Искать...' / >
                                                                              <div className = 'chat-users__editable';
                                                                style = {editableWrapperStyle} >
                                                                                               <AutoSizer>
                                                                                                   {({height, width});
                                                            =>
                                                                <List
                                                                    height = {height};
                                                                itemCount = {filteredAllUsers.length};
                                                                itemSize = {34};
                                                                width = {width}
                                                                    >
                                                                    {EditableRow}
                                                                    < /List>;
                                                            }
                                                                </AutoSizer>
                                                                < /div>
                                                                < /LoadableView>
                                                                < ButtonGroup;
                                                                className = 'chat-users__buttons' >
                                                                            <Button text = 'Сохранить';
                                                                intent = {Intent.PRIMARY};
                                                                onClick = {onEditFinished};
                                                                />
                                                                < Button;
                                                                text = 'Отменить';
                                                                onClick = {onCancel};
                                                                />
                                                                < /ButtonGroup>
                                                                < />;;
                                                            }

                                                            return <>
                                                                <InputGroup className = {`${Classes.ROUND} ${Classes.FILL} search`;
                                                        }
                                                            leftIcon = 'search';
                                                            value = {filter};
                                                            onChange = {onChange};
                                                            placeholder = 'Искать...' / >
                                                                          <div className = 'chat-users';
                                                            style = {wrapperStyle} >
                                                                                   <AutoSizer>
                                                                                       {({height, width});
                                                        =>
                                                            <List
                                                                height = {height};
                                                            itemCount = {filteredUsers.length};
                                                            itemSize = {34};
                                                            width = {width}
                                                                >
                                                                {Row}
                                                                < /List>;
                                                        }
                                                            </AutoSizer>
                                                            < /div>
                                                            < />;;
                                                        };
                                                        src / ui / blocks / tree - item / tree - item.tsx;
                                                        import {Icon, Intent, ITreeNode, Spinner, Tree} from '@blueprintjs/core';
                                                        import React, {FC} from 'react';
                                                        import {ProfileOrSearchItem} from 'src/types';
                                                        import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                                        import './tree-item.styl';

                                                        const SPINNER_ITEM: ITreeNode = {
                                                            id: 'spinner',
                                                            label: <Spinner size = {15}
                                                        />,;
                                                    }
                                                        ;

                                                        const ERROR_ITEM: ITreeNode = {
                                                            id: 'error',
                                                            label: <span className = 'tree-item__error-view' > <Icon icon = {'error'}
                                                            intent = {Intent.DANGER}
                                                        /> Ошибка загрузки списка</s;
                                                        pan >,
                                                    }
                                                        ;

                                                        type Props = {
                                                            items: ITreeNode[];
                                                            editItem: (newItems: ITreeNode[]) => void;
                                                        }
                                                        export const TreeItem: FC<Props> = ({items, editItem}) => {
                                                            const cppwApi = useCppwApiContext();
                                                            const handleNodeCollapse = (nodeData: ITreeNode) => {
                                                                nodeData.isExpanded = false;
                                                                editItem([...items]);
                                                            };
                                                            const handleNodeExpand = (nodeData: ITreeNode) => {
                                                                if (nodeData.hasCaret && !nodeData.childNodes) {
                                                                    cppwApi && cppwApi.getOrganisationStructure(String(nodeData.id), () => {
                                                                        nodeData.isExpanded = true;
                                                                        nodeData.childNodes = [SPINNER_ITEM];
                                                                        editItem([...items]);
                                                                    }, (result: ProfileOrSearchItem[]) => {
                                                                        nodeData.childNodes = result[0].items;
                                                                        editItem([...items]);
                                                                    }, () => {
                                                                        nodeData.isExpanded = true;
                                                                        nodeData.childNodes = [ERROR_ITEM];
                                                                        editItem([...items]);
                                                                    });
                                                                } else {
                                                                    nodeData.isExpanded = true;
                                                                    editItem([...items]);
                                                                }
                                                            };
                                                            return (
                                                                <Tree
                                                                    contents = {items}
                                                            onNodeCollapse = {handleNodeCollapse};
                                                            onNodeExpand = {handleNodeExpand};
                                                            />;
                                                        )
                                                            ;
                                                        };
                                                        src / ui / blocks / stage - view / stage - view.tsx;
                                                        import {Checkbox, H5, H6, Icon, Position, Tooltip} from '@blueprintjs/core';
                                                        import React, {FC, useCallback, useMemo, useRef, useState} from 'react';
                                                        import {Stage, Task, Usage} from 'src/types';
                                                        import {FormInput} from 'src/ui/blocks/form-input/form-input';
                                                        import {parseDate} from 'src/ui/utils/parse-date';
                                                        import './stage-view.styl';

                                                        type TaskViewProps = Task & { stageMode: StageMode; className?: string };
                                                        export const TaskView: FC<TaskViewProps> = ({id, name, description, file, isUploadable, stageMode, className}) => {
                                                            const fileRef = useRef<{ value: { id: string, name: string, type: 'file' } | null }>(file
                                                                                                                                                 ? {value: file}
                                                                                                                                                 : null);
                                                            const validators = useMemo(() => [], []);
                                                            const setFileRef = useCallback((val) => {
                                                                // @ts-ignore
                                                                fileRef.current = val;
                                                            }, []);

                                                            return (<div className = {`task-view ${className}`
                                                        }>
                                                            <Checkbox labelElement = { < H6;
                                                            className = 'task-view__title' > {name} < /H6>}>
                                                                        < div;
                                                            className = 'task-view__label' >
                                                            {description && <p className = 'task-view__description' > {description} < /p>};
                                                            {
                                                                isUploadable && (stageMode === StageMode.Student ? <FormInput key = {'filik'}
                                                                                 title = ''
                                                                name = {'file'};
                                                                id = {'filik'};
                                                                mandatory = {false};
                                                                validators = {validators};
                                                                usage = {Usage.File};
                                                                inputRef = {setFileRef};
                                                                formIndex = { - 1;
                                                            }
                                                                index = { - 1;
                                                            }
                                                                defaultValue = {file};
                                                                // @ts-ignore
                                                                taskId = {id};
                                                                placeholder = 'Нажмите для выбора файла...'
                                                                              / >
                                                            :
                                                                <Tooltip className = 'task-view__upload-icon';
                                                                content = {'Для выполнения задания будет необходимо загрузить файл с результатами.'};
                                                                position = {Position.LEFT} > <Icon icon = 'import' / > </Tooltip>)}
                                                                                                          < /div>
                                                                                                          < /Checkbox>
                                                                                                          < /div>);;
                                                            }
                                                            ;
                                                            const now = new Date();

                                                            export enum StageMode {
                                                                // Для всех пользователей в активности
                                                                All = 'all',
                                                                // Для студента, исполняющего этот проект. Для загрузки материалов и просмотра оценки
                                                                Student = 'student',
                                                            }

                                                            type StageViewProps = Stage & { stageMode: StageMode; className?: string };
                                                            export const StageView: FC<StageViewProps> = ({
                                                                                                              name,
                                                                                                              description,
                                                                                                              startDate,
                                                                                                              endDate,
                                                                                                              coefficient,
                                                                                                              tasks,
                                                                                                              grade,
                                                                                                              stageMode,
                                                                                                              className,
                                                                                                          }) => {
                                                                const [isOpen, setIsOpen] = useState(new Date(startDate) <= now && new Date(endDate) >= now);
                                                                const handleOpen = useCallback(() => setIsOpen(!isOpen), [setIsOpen, isOpen]);
                                                                return (
                                                                    <div className = {`stage-view ${className}`
                                                            }>
                                                                <div className = 'stage-view__header';
                                                                onClick = {handleOpen} >
                                                                                       <H5 className = 'stage-view__title' > {name} < /H5>
                                                                                                       < Icon;
                                                                icon = 'chevron-down';
                                                                className = 'stage-view__arrow' / >
                                                                            </div>;
                                                                {
                                                                    <div className = {`stage-view__collapse ${isOpen ? '_is-open' : ''}`;
                                                                }>
                                                                    <p className = 'stage-view__description' > {parseDate(new Date(startDate)
                                                                )
                                                                }
                                                                    -{parseDate(new Date(endDate)
                                                                )
                                                                }
                                                                    </p>;
                                                                    {
                                                                        description && <p className = 'stage-view__description' > {description} < /p>}
                                                                                                      < p;
                                                                        className = 'stage-view__description' > Коэффицент;
                                                                        этапа;
                                                                        в;
                                                                        итоговой;
                                                                        оценке: {
                                                                            coefficient;
                                                                        }
                                                                        </p>;
                                                                        {
                                                                            tasks && !tasks.length && <p className = 'stage-view__description' > В;
                                                                            данном;
                                                                            этапе;
                                                                            нет;
                                                                            заданий. < /p>};
                                                                            {
                                                                                tasks && tasks.map((task, index) => <TaskView key = {index}
                                                                                {...
                                                                                    task;
                                                                                }
                                                                                stageMode = {stageMode};
                                                                                />);
                                                                            }
                                                                            {
                                                                                stageMode !== StageMode.All && <div>
                                                                                    <p className = 'stage-view__description' > Оценка;
                                                                                за;
                                                                                этап;
                                                                                от;
                                                                                ментора: {
                                                                                    grade && grade.mentorGrade ? grade.mentorGrade : '-';
                                                                                }
                                                                                </p>
                                                                                < p;
                                                                                className = 'stage-view__description' > Итоговая;
                                                                                ценка;
                                                                                за;
                                                                                этап: {
                                                                                    grade && grade.managerGrade ? grade.managerGrade : '-';
                                                                                }
                                                                                </p>
                                                                                < /div>;
                                                                            }
                                                                            </div>}
                                                                            < /div>;
                                                                        )
                                                                ;
                                                            };
                                                            src / ui / blocks / loadable - view / loadable - view.tsx;
                                                            import {Spinner} from '@blueprintjs/core';
                                                            import React, {FC} from 'react';
                                                            import {AsyncStatus} from 'src/types';
                                                            import {ErrorView} from 'src/ui/blocks/error-view/error-view';

                                                            type Props = {
                                                                status: AsyncStatus;

                                                                spinnerClassName?: string;

                                                                errorTitle?: string;
                                                                errorSubtitle?: string;
                                                                onRetry?: () => void;
                                                                errorSize?: 's';
                                                            }

                                                            export const LoadableView: FC<Props> = ({children, status, errorTitle, errorSubtitle, onRetry, errorSize, spinnerClassName}) => {
                                                                switch (status) {
                                                                    case AsyncStatus.Success:
                                                                        return <>{children} < />;;
                                                                    case AsyncStatus.Pending:
                                                                        return <Spinner className = {spinnerClassName};
                                                                        />;;
                                                                    case AsyncStatus.Error:
                                                                        if (errorTitle || errorSubtitle || onRetry || errorSize) {
                                                                            return <ErrorView title = {errorTitle};
                                                                            subtitle = {errorSubtitle};
                                                                            onRetry = {onRetry};
                                                                            size = {errorSize};
                                                                            />;;
                                                                        }
                                                                        return null;
                                                                    case AsyncStatus.Initial:
                                                                    default:
                                                                        return null;
                                                                }
                                                            };
                                                            src / ui / blocks / profile - list / profile - list.tsx;
                                                            import React, {FC, useCallback, useEffect} from 'react';
                                                            import {ApiResponse, AsyncStatus, ProfileOrSearchItem} from 'src/types';
                                                            import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                                                            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                                            type Props = {
                                                                status: AsyncStatus;
                                                                items: ProfileOrSearchItem[];
                                                                editCurrentList: (list: { items: ProfileOrSearchItem[], status: AsyncStatus }) => void;
                                                                component: FC<ProfileOrSearchItem>;
                                                                path: string;
                                                                profileId: string;
                                                                className: string;
                                                            };
                                                            export const ProfileList: FC<Props> = ({
                                                                                                       status,
                                                                                                       editCurrentList,
                                                                                                       items,
                                                                                                       component: Component,
                                                                                                       path,
                                                                                                       profileId,
                                                                                                       className,
                                                                                                   }) => {
                                                                const cppwApi = useCppwApiContext();
                                                                const editItem = useCallback((itemIndex: number, newInfo: ProfileOrSearchItem) => {
                                                                    const res = items.map((item, index) => itemIndex === index ? (newInfo
                                                                                                                                  ? {...item, ...newInfo}
                                                                                                                                  : newInfo) : item);
                                                                    editCurrentList({
                                                                                        status: AsyncStatus.Success,
                                                                                        items: res,
                                                                                    });
                                                                }, [items, editCurrentList]);

                                                                useEffect(() => {
                                                                    // Перезапрашиваем данные, если необходимо
                                                                    if (cppwApi && status === AsyncStatus.Initial && path in cppwApi) {
                                                                        // @ts-ignore
                                                                        cppwApi[path](profileId,
                                                                                      () => {
                                                                                          editCurrentList({
                                                                                                              status: AsyncStatus.Pending,
                                                                                                              items: [],
                                                                                                          });
                                                                                      },
                                                                                      (res: ApiResponse[]) => {
                                                                                          editCurrentList({
                                                                                                              status: AsyncStatus.Success,
                                                                                                              items: res,
                                                                                                          });
                                                                                      },
                                                                                      () => {
                                                                                          editCurrentList({
                                                                                                              status: AsyncStatus.Error,
                                                                                                              items: [],
                                                                                                          });
                                                                                      });
                                                                    }
                                                                }, [editCurrentList, status, profileId, cppwApi, path]);

                                                                return <LoadableView status = {status};
                                                                errorTitle = {'Ошибка загрузки списка'};
                                                                spinnerClassName = 'spinner-full-height' >
                                                                                   <div className = {className} >
                                                                    {
                                                                        items && items.filter(item => !!item).map((item,
                                                                                                                   index) => <Component key = {index}
                                                                {...
                                                                    item;
                                                                }
                                                                editItem = {editItem};
                                                                itemIndex = {index};
                                                                />);
                                                            }
                                                                {
                                                                    (!items || !items.filter(
                                                                        item => !!item).length) && <div className = 'profile-lists__no-items' > Список;
                                                                    пока;
                                                                    что;
                                                                    пуст < /div>;
                                                                }
                                                                </div>
                                                                < /LoadableView>;;
                                                            };
                                                            src / ui / blocks / vedomost / vedomost.tsx;
                                                            import React, {FC, useCallback, useEffect, useState} from 'react';
                                                            import {
                                                                AsyncStatus,
                                                                Attribute,
                                                                ProfileOrSearchItem,
                                                                ProfileType,
                                                                SearchType,
                                                            } from 'src/types';
                                                            import {SearchResults} from 'src/ui/blocks/search-results/search-results';
                                                            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                                            type Props = {
                                                                profileId: string;
                                                                profileType: ProfileType;
                                                            }
                                                            export const Vedomost: FC<Props> = ({profileId, profileType}) => {
                                                                const cppwApi = useCppwApiContext();

                                                                const [status, setStatus] = useState(AsyncStatus.Initial);
                                                                const [result, setResult] = useState<{ fields: Attribute[]; records: ProfileOrSearchItem[] }>(
                                                                    {fields: [], records: []});
                                                                const setMark = useCallback((mark, recordIndex, fieldName) => {
                                                                    result.records[recordIndex][fieldName] = mark;
                                                                    setResult(result);
                                                                }, [result, setResult]);

                                                                useEffect(() => {
                                                                    if (cppwApi && status === AsyncStatus.Initial) {
                                                                        switch (profileType) {
                                                                            case ProfileType.Activity: {
                                                                                cppwApi && cppwApi.getActivityVedomost(profileId,
                                                                                                                       () => {setStatus(AsyncStatus.Pending);},
                                                                                                                       (result) => {
                                                                                                                           setResult(result);
                                                                                                                           setStatus(AsyncStatus.Success);
                                                                                                                       },
                                                                                                                       () => {
                                                                                                                           setStatus(AsyncStatus.Error);
                                                                                                                       },
                                                                                );
                                                                                return;
                                                                            }
                                                                            case ProfileType.Project: {
                                                                                cppwApi && cppwApi.getProjectVedomost(profileId,
                                                                                                                      () => {setStatus(AsyncStatus.Pending);},
                                                                                                                      (result) => {
                                                                                                                          setResult(result);
                                                                                                                          setStatus(AsyncStatus.Success);
                                                                                                                      },
                                                                                                                      () => {
                                                                                                                          setStatus(AsyncStatus.Error);
                                                                                                                      },
                                                                                );
                                                                                return;
                                                                            }
                                                                        }
                                                                    }
                                                                }, [profileType, profileId, cppwApi, setStatus]);

                                                                return <SearchResults searchType = {SearchType.Initial};
                                                                status = {status};
                                                                fields = {result.fields};
                                                                records = {result.records};
                                                                setMark = {setMark};
                                                                profileId = {profileId};
                                                                />;;
                                                            };
                                                            src / ui / blocks / chat - column / chat - column.tsx;
                                                            import {Icon} from '@blueprintjs/core';
                                                            import React, {FC, useCallback, useMemo} from 'react';
                                                            import {addChat} from 'src/store/actions/chats.actions';
                                                            import {ChatState} from 'src/store/reducers/chats.reducer';
                                                            import {AsyncStatus} from 'src/types';
                                                            import {ChatCard} from 'src/ui/blocks/chat-card/chat-card';
                                                            import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                                                            import {Search} from 'src/ui/blocks/search/search';
                                                            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                                            export const DEFAULT_CHAT_ID = 'DEFAULT_CHAT_ID';

                                                            const NEW_CHAT = {
                                                                id: DEFAULT_CHAT_ID,
                                                                users: [],
                                                                name: '',
                                                                isEditing: true,
                                                                backup: undefined,
                                                            };

                                                            type Props = {
                                                                userId: string;
                                                                status: AsyncStatus;
                                                                chats: ChatState[];
                                                                activeTabIndex: number;
                                                                setActiveTabIndex: (activeTabIndex: number) => void;
                                                            }
                                                            export const ChatColumn: FC<Props> = ({status, chats, activeTabIndex, setActiveTabIndex, userId}) => {
                                                                const cppwApi = useCppwApiContext();
                                                                const items = useMemo(() => (
                                                                    chats.map((chat, index) => ({
                                                                        title: chat.name,
                                                                        chatIndex: index,
                                                                        chatId: chat.id,
                                                                        onClick: () => {setActiveTabIndex(index);},
                                                                        isEditing: Boolean(chat.isEditing),
                                                                        isActive: index === activeTabIndex,
                                                                    }))
                                                                ), [chats, setActiveTabIndex, activeTabIndex]);

                                                                const onClick = useCallback(() => {
                                                                    cppwApi && cppwApi.store.dispatch(addChat(NEW_CHAT));
                                                                    setActiveTabIndex(chats.length);
                                                                }, [chats.length, cppwApi, setActiveTabIndex]);
                                                                const onRetry = useCallback(() => {cppwApi && cppwApi.requestChats(userId);},
                                                                                            [userId, cppwApi]);

                                                                return (<>
                                                                    <LoadableView status = {status}
                                                                errorSize = 's';
                                                                errorTitle = 'Ошибка загрузки контактов.';
                                                                errorSubtitle = 'Нажмите для повтора';
                                                                onRetry = {onRetry} >
                                                                                    <Search component = {ChatCard};
                                                                searchPropertyName = 'title';
                                                                items = {items};
                                                                />
                                                                < div;
                                                                className = 'chat-card _placeholder';
                                                                onClick = {onClick} >
                                                                                    <Icon icon = 'plus' / >
                                                                                                 </div>
                                                                                                 < /LoadableView>
                                                                                                 < />);;
                                                            };
                                                            src / ui / blocks / notifications / notifications.tsx;
                                                            import {Icon} from '@blueprintjs/core';
                                                            import React, {FC, useCallback, useEffect, useState} from 'react';
                                                            import {Link} from 'react-router-dom';
                                                            import {AsyncStatus, CppwNotification} from 'src/types';
                                                            import {LoadableView} from 'src/ui/blocks/loadable-view/loadable-view';
                                                            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                                            import './notifications.styl';

                                                            const NotificationView: FC<CppwNotification> = ({id, from, message, about, read: initialReadState}) => {
                                                                const cppwApi = useCppwApiContext();
                                                                const [read, setRead] = useState(initialReadState);
                                                                const onRead = useCallback(() => {
                                                                    cppwApi && cppwApi.setNotificationSeen(id, () => {setRead(true);});
                                                                }, [id, cppwApi, setRead]);
                                                                return <div className = {`notification ${read ? '_is-read' : ''}`;
                                                            }>
                                                                <Icon className = 'notification__icon';
                                                                icon = {read ? 'eye-off' : 'eye-open'};
                                                                onClick = {onRead};
                                                                />
                                                                < div;
                                                                className = 'notification__text' >
                                                                            <Link to = {`/${from.type}/${from.id}`;
                                                            }>
                                                                {
                                                                    from.name;
                                                                }
                                                                </Link> {message} {about && <Link to={`/;${about.type}
                                                                /${about.id}`}>{about.name}</;
                                                                Link >
                                                            };
                                                            </div>
                                                            < /div>;;
                                                        }
                                                            ;

                                                            export const Notifications: FC = () => {
                                                                const cppwApi = useCppwApiContext();

                                                                const [notifications, setNotifications] = useState<CppwNotification[]>([]);
                                                                const [status, setStatus] = useState(AsyncStatus.Initial);

                                                                useEffect(() => {
                                                                    if (cppwApi && status === AsyncStatus.Initial) {
                                                                        cppwApi && cppwApi.getAllNotifications(
                                                                            () => {setStatus(AsyncStatus.Pending);},
                                                                            (notifications) => {
                                                                                setNotifications(notifications);
                                                                                setStatus(AsyncStatus.Success);
                                                                            },
                                                                            () => {setStatus(AsyncStatus.Error);},
                                                                        );
                                                                    }
                                                                }, [cppwApi, setStatus]);

                                                                return <LoadableView status = {status};
                                                                errorTitle = 'Ошибка загрузки нотификаций.';
                                                                spinnerClassName = 'spinner-full-height' >
                                                                    {
                                                                        notifications.map((notification) => <NotificationView key = {notification.id}
                                                                {...
                                                                    notification;
                                                                }
                                                                />);
                                                            }
                                                                </LoadableView>;;
                                                            };
                                                            src / ui / blocks / header / header.tsx;
                                                            import {Alignment, Button, Navbar} from '@blueprintjs/core';

                                                            import React, {FC, memo} from 'react';
                                                            import {useSelector} from 'react-redux';
                                                            import {Link} from 'react-router-dom';
                                                            import {State} from 'src/store/reducers';
                                                            import {UserRole} from 'src/types';
                                                            import {HomePageLocations} from 'src/ui/routes/home/home-page';
                                                            import {BACKEND_URL} from 'src/ui/utils/constants';
                                                            import './header.styl';

                                                            const AUTH = `https://dev-cppr.eu.auth0.com/authorize?response_type=code&client_id=yylyc1ApB4GlR42juTSFfoCQqb4wL0JY&redirect_uri=${BACKEND_URL}/api/v1/callback&scope=openid email profile&audience=${BACKEND_URL}&state=`;
                                                            const ROLE_TO_MENU: {
                                                                [key: string]: {
                                                                    hasForms: boolean;
                                                                    hasChats: boolean;
                                                                    hasProjects: boolean;
                                                                    hasAdmin: boolean;
                                                                }
                                                            } = {
                                                                [UserRole.Manager]: {
                                                                    hasForms: true,
                                                                    hasChats: true,
                                                                    hasProjects: false,
                                                                    hasAdmin: true,
                                                                },
                                                                [UserRole.Supervisor]: {
                                                                    hasForms: true,
                                                                    hasChats: true,
                                                                    hasProjects: false,
                                                                    hasAdmin: true,
                                                                },
                                                                [UserRole.Representative]: {
                                                                    hasForms: false,
                                                                    hasChats: false,
                                                                    hasProjects: true,
                                                                    hasAdmin: false,
                                                                },
                                                                [UserRole.Mentor]: {
                                                                    hasForms: false,
                                                                    hasChats: false,
                                                                    hasProjects: true,
                                                                    hasAdmin: false,
                                                                },
                                                                [UserRole.Student]: {
                                                                    hasForms: false,
                                                                    hasChats: false,
                                                                    hasProjects: false,
                                                                    hasAdmin: false,
                                                                },
                                                                'undefined': {
                                                                    hasForms: false,
                                                                    hasChats: false,
                                                                    hasProjects: false,
                                                                    hasAdmin: false,
                                                                },
                                                            };

                                                            export const Header: FC = memo(() => {
                                                                const {isAuthed, role: userRole, userId} = useSelector((state: State) => state.user.isAuthed
                                                                                                                                         ? state.user
                                                                                                                                         : {
                                                                        isAuthed: false,
                                                                        role: undefined,
                                                                        userId: undefined,
                                                                    });
                                                                const {hasForms, hasChats, hasProjects, hasAdmin} = ROLE_TO_MENU[String(userRole)];
                                                                return (
                                                                    <Navbar className = 'header' >
                                                                                        <Navbar.Group align = {Alignment.LEFT} >
                                                                                                                               <Navbar.Heading className = 'header__long-title' >
                                                                                                                                                           <Link className = 'header__link'
                                                                to = '/' > Центр;
                                                                практик;
                                                                и;
                                                                проектной;
                                                                работы < /Link>
                                                                < /Navbar.Heading>
                                                                < Navbar.Heading;
                                                                className = 'header__short-title' >
                                                                            <Link className = 'header__link';
                                                                to = {HomePageLocations.Main} > ЦППР < /Link>
                                                                                              < /Navbar.Heading>
                                                                                              < /Navbar.Group>

                                                                                              < Navbar.Group;
                                                                align = {Alignment.RIGHT} >
                                                                    {
                                                                        isAuthed ? (
                                                                                       <>
                                                                                           <Link className = 'header__link' to = '/search' > <Button className = 'bp3-minimal'
                                                                        icon = 'search' / > </Link>
                                                                {
                                                                    hasChats && <Link className = 'header__link';
                                                                    to = '/chat' > <Button className = 'bp3-minimal';
                                                                    icon = 'chat' / > </Link>};
                                                                    {
                                                                        hasForms && <Link className = 'header__link';
                                                                        to = '/forms' > <Button className = 'bp3-minimal';
                                                                        icon = 'clipboard' / > </Link>};

                                                                        {
                                                                            hasProjects && <Link className = 'header__link';
                                                                            to = {`/new_project_request`;
                                                                        }>
                                                                            <Button className = 'bp3-minimal';
                                                                            icon = 'plus' / > </Link>;
                                                                        }
                                                                        <Link className = 'header__link';
                                                                        to = {`/user/${userId}`;
                                                                    }>
                                                                        <Button className = 'bp3-minimal';
                                                                        icon = 'person' / > </Link>;
                                                                        {
                                                                            hasAdmin && <Link className = 'header__link';
                                                                            to = '/admin' > <Button className = 'bp3-minimal';
                                                                            icon = 'cog' / > </Link>;
                                                                        }
                                                                        </>;
                                                                    )
                                                            :
                                                                (
                                                                    <>
                                                                        <a className = 'header__link'
                                                                href = {`${AUTH}${window.location.pathname}`;
                                                            }>
                                                                <Button className = 'bp3-minimal';
                                                                icon = 'log-in';
                                                                text = 'Вход' / >
                                                                       </a>
                                                                       < />;
                                                            )
                                                            }
                                                                </Navbar.Group>
                                                                < /Navbar>;
                                                            )
                                                                ;
                                                            });
                                                            src / ui / app.tsx;
                                                            import {Position, Toaster} from '@blueprintjs/core';
                                                            import React, {createRef, memo, useMemo} from 'react';
                                                            import {Provider} from 'react-redux';
                                                            import {BrowserRouter, Route, Switch} from 'react-router-dom';
                                                            import {createXhrClient, UploadProvider} from 'react-use-upload';
                                                            import {createStore} from 'redux';
                                                            import {CppwApi} from 'src/api/api';
                                                            import {rootReducer} from 'src/store/reducers';
                                                            import {UserRole} from 'src/types';
                                                            import {Footer} from 'src/ui/blocks/footer/footer';
                                                            import {Header} from 'src/ui/blocks/header/header';
                                                            import {CppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';
                                                            import {
                                                                AdminPage,
                                                                ChatPage,
                                                                FormsPage,
                                                                HomePage,
                                                                NewProjectRequestPage,
                                                                ProfilePage,
                                                                SearchPage,
                                                            } from 'src/ui/routes';
                                                            import {checkURLPermission} from 'src/ui/utils/auth';
                                                            import {BACKEND_URL} from 'src/ui/utils/constants';
                                                            import {
                                                                ACTIVITY_PROFILE_PATH,
                                                                COMPANY_PROFILE_PATH,
                                                                PROJECT_PROFILE_PATH,
                                                                PROJECT_REQUEST_PROFILE_PATH,
                                                                USER_PROFILE_PATH,
                                                            } from './routes/profile/profile-page';

                                                            const store = createStore(rootReducer);

                                                            export const App: React.FC = memo(() => {
                                                                const toasterRef = createRef<Toaster>();
                                                                const cppwApi = useMemo(() => new CppwApi(store, toasterRef), []);
                                                                const user = cppwApi.store.getState().user;
                                                                const {role: userRole} = user.isAuthed ? user : {role: UserRole.Initial};
                                                                checkURLPermission(window.location.pathname, userRole);
                                                                return (
                                                                    <UploadProvider client = {createXhrClient({baseUrl: BACKEND_URL})} >
                                                                                                                                       <Provider store = {store} >
                                                                                                                                                                 <BrowserRouter>
                                                                                                                                                                     <CppwApiContext.Provider value = {cppwApi} >
                                                                                                                                                                                                                <div className = 'App' >
                                                                                                                                                                                                                                 <Header / >
                                                                                                                                                                                                                                 <Switch>
                                                                                                                                                                                                                                     <Route exact
                                                                path = '/';
                                                                component = {HomePage};
                                                                />
                                                                < Route;
                                                                exact;
                                                                path = '/for_partners';
                                                                component = {HomePage};
                                                                />
                                                                < Route;
                                                                exact;
                                                                path = '/for_students';
                                                                component = {HomePage};
                                                                />
                                                                < Route;
                                                                exact;
                                                                path = '/help';
                                                                component = {HomePage};
                                                                />
                                                                < Route;
                                                                exact;
                                                                path = '/contacts';
                                                                component = {HomePage};
                                                                />

                                                                < Route;
                                                                exact;
                                                                path = {USER_PROFILE_PATH};
                                                                component = {ProfilePage};
                                                                />
                                                                < Route;
                                                                exact;
                                                                path = {PROJECT_PROFILE_PATH};
                                                                component = {ProfilePage};
                                                                />
                                                                < Route;
                                                                exact;
                                                                path = {ACTIVITY_PROFILE_PATH};
                                                                component = {ProfilePage};
                                                                />
                                                                < Route;
                                                                exact;
                                                                path = {COMPANY_PROFILE_PATH};
                                                                component = {ProfilePage};
                                                                />
                                                                < Route;
                                                                exact;
                                                                path = {PROJECT_REQUEST_PROFILE_PATH};
                                                                component = {ProfilePage};
                                                                />
                                                                < Route;
                                                                exact;
                                                                path = '/admin';
                                                                component = {AdminPage};
                                                                />
                                                                < Route;
                                                                exact;
                                                                path = '/new_project_request';
                                                                component = {NewProjectRequestPage};
                                                                />

                                                                < Route;
                                                                exact;
                                                                path = '/chat';
                                                                component = {ChatPage};
                                                                />

                                                                < Route;
                                                                exact;
                                                                path = '/search';
                                                                component = {SearchPage};
                                                                />

                                                                < Route;
                                                                exact;
                                                                path = '/forms';
                                                                component = {FormsPage};
                                                                />
                                                                < Route;
                                                                component = {HomePage};
                                                                />
                                                                < /Switch>
                                                                < Footer / >

                                                                <Toaster canEscapeKeyClear = {true};
                                                                position = {Position.TOP};
                                                                ref = {toasterRef};
                                                                />
                                                                < /div>
                                                                < /CppwApiContext.Provider>
                                                                < /BrowserRouter>
                                                                < /Provider>
                                                                < /UploadProvider>;
                                                            )
                                                                ;
                                                            });
                                                            src / ui / contexts / cppw - api - context / cppw - api - context.tsx;
                                                            import {createContext, useContext} from 'react';
                                                            import {CppwApi} from 'src/api/api';

                                                            export const CppwApiContext = createContext<CppwApi | undefined>(undefined);

                                                            export const useCppwApiContext = () => useContext(CppwApiContext);
                                                            src / ui / utils / throttle.ts;

                                                            export function throttle<F>(func: F, ms: number): F {

                                                                let isThrottled = false,
                                                                    savedArgs: any = null,
                                                                    savedThis: any = null;

                                                                function wrapper() {

                                                                    if (isThrottled) { // (2)
                                                                        savedArgs = arguments;
                                                                        // @ts-ignore
                                                                        savedThis = this;
                                                                        return;
                                                                    }

                                                                    // @ts-ignore
                                                                    func.apply(this, arguments); // (1)

                                                                    isThrottled = true;

                                                                    setTimeout(function () {
                                                                        isThrottled = false; // (3)
                                                                        if (savedArgs) {
                                                                            wrapper.apply(savedThis, savedArgs);
                                                                            savedArgs = savedThis = null;
                                                                        }
                                                                    }, ms);
                                                                }

                                                                // @ts-ignore
                                                                return wrapper;
                                                            }

                                                            src / ui / utils / reoder - array.ts;
                                                            export const reorderArray = <T>(array: T[],
                                                                                            from: number,
                                                                                            to: number,
                                                                                            length = 1): T[] | undefined => {
                                                                if (length === 0 || length === array.length || from === to) {
                                                                    // return an unchanged copy
                                                                    return array.slice();
                                                                }

                                                                if (length < 0 || length > array.length || from + length > array.length) {
                                                                    return undefined;
                                                                }

                                                                const before = array.slice(0, from);
                                                                const within = array.slice(from, from + length);
                                                                const after = array.slice(from + length);

                                                                const result = [];
                                                                let i = 0;
                                                                let b = 0;
                                                                let w = 0;
                                                                let a = 0;

                                                                while (i < to) {
                                                                    if (b < before.length) {
                                                                        result.push(before[b]);
                                                                        b += 1;
                                                                    } else {
                                                                        result.push(after[a]);
                                                                        a += 1;
                                                                    }
                                                                    i += 1;
                                                                }

                                                                while (w < length) {
                                                                    result.push(within[w]);
                                                                    w += 1;
                                                                    i += 1;
                                                                }

                                                                while (i < array.length) {
                                                                    if (b < before.length) {
                                                                        result.push(before[b]);
                                                                        b += 1;
                                                                    } else {
                                                                        result.push(after[a]);
                                                                        a += 1;
                                                                    }
                                                                    i += 1;
                                                                }

                                                                return result;
                                                            };
                                                            src / ui / utils / clipboard.ts;
                                                            export const Clipboard = {
                                                                applySelectableStyles(elem: HTMLElement) {
                                                                    elem.style.overflow = 'hidden';
                                                                    elem.style.height = '0px';
                                                                    elem.style.setProperty('-webkit-user-select', 'all');
                                                                    elem.style.setProperty('-moz-user-select', 'all');
                                                                    elem.style.setProperty('-ms-user-select', 'all');
                                                                    elem.style.setProperty('user-select', 'all');
                                                                    return elem;
                                                                },

                                                                copyCells(cells: string[][]) {
                                                                    const table = document.createElement('table');
                                                                    Clipboard.applySelectableStyles(table);
                                                                    for (const row of cells) {
                                                                        const tr = table.appendChild(document.createElement('tr'));
                                                                        for (const cell of row) {
                                                                            const td = tr.appendChild(document.createElement('td'));
                                                                            td.textContent = cell;
                                                                        }
                                                                    }

                                                                    const tsv = cells.map(row => row.join('\t')).join('\n');
                                                                    return Clipboard.copyElement(table, tsv);
                                                                },

                                                                copyString(value: string) {
                                                                    const text = document.createElement('textarea');
                                                                    Clipboard.applySelectableStyles(text);
                                                                    text.value = value;

                                                                    return Clipboard.copyElement(text, value);
                                                                },

                                                                copyElement(elem: HTMLElement, plaintext?: string) {
                                                                    if (!Clipboard.isCopySupported()) {
                                                                        return false;
                                                                    }

                                                                    // must be document.body instead of document.documentElement for firefox
                                                                    document.body.appendChild(elem);
                                                                    try {
                                                                        // @ts-ignore
                                                                        window.getSelection().selectAllChildren(elem);

                                                                        if (plaintext != null) {
                                                                            // add plaintext fallback
                                                                            // http://stackoverflow.com/questions/23211018/copy-to-clipboard-with-jquery-js-in-chrome
                                                                            elem.addEventListener('copy', (e: any) => {
                                                                                e.preventDefault();
                                                                                const clipboardData = (e as any).clipboardData || (window as any).clipboardData;
                                                                                if (clipboardData != null) {
                                                                                    clipboardData.setData('text', plaintext);
                                                                                }
                                                                            });
                                                                        }

                                                                        return document.execCommand('copy');
                                                                    } catch (err) {
                                                                        return false;
                                                                    } finally {
                                                                        document.body.removeChild(elem);
                                                                    }
                                                                },

                                                                isCopySupported() {
                                                                    return document.queryCommandSupported != null && document.queryCommandSupported(
                                                                        'copy');
                                                                },
                                                            };
                                                            src / ui / utils / form - input - validator / text - validator.ts;
                                                            import {Attribute} from 'src/types';

                                                            export const isMandatoryFulfilledForText = (value: string, {mandatory}: Attribute) => {
                                                                if (mandatory && !value) {
                                                                    return 'Поле обязательно для заполнения.';
                                                                }
                                                                return '';
                                                            };
                                                            export const isMinLengthFulfilledForText = (value: string, {min, max}: Attribute) => {
                                                                if (min !== undefined && min !== null && value.length < min) {
                                                                    return (
                                                                               max !== undefined && max !== null
                                                                           )
                                                                           ? `В поле должно быть не менее ${min} и не более ${max} символов.`
                                                                           : `В поле должно быть не менее ${min} символов.`;
                                                                }
                                                                return '';
                                                            };
                                                            export const isMaxLengthFulfilledForText = (value: string, {min, max}: Attribute) => {
                                                                if (max !== undefined && max !== null && value.length > max) {
                                                                    return (
                                                                               min !== undefined && min !== null
                                                                           )
                                                                           ? `В поле должно быть не менее ${min} и не более ${max} символов.`
                                                                           : `В поле должно быть не более ${max} символов.`;
                                                                }
                                                                return '';
                                                            };
                                                            export const isValidatorsFulfilledForText = (value: string, {validators}: Attribute) => {
                                                                if (validators.length) {
                                                                    const validatorsWithError = validators.filter((validator) => {
                                                                        return !(new RegExp(validator.regexp)).test(value);
                                                                    });

                                                                    if (validatorsWithError.length) {
                                                                        return validatorsWithError[0].message;
                                                                    }
                                                                }
                                                                return '';
                                                            };
                                                            export const isEmptyForText = (value: string,
                                                                                           {mandatory}: Attribute) => !value && !mandatory;
                                                            src / ui / utils / form - input - validator / number - validator.ts;
                                                            import {Attribute} from 'src/types';

                                                            export const isFiniteFulfilledForNumber = (value: number) => {
                                                                if (!Number.isFinite(value)) {
                                                                    return 'Введенное число должно быть не бесконечным.';
                                                                }
                                                                return '';
                                                            };
                                                            export const isMinLengthFulfilledForNumber = (value: number, {min, max}: Attribute) => {
                                                                if (min !== undefined && min !== null && value < min) {
                                                                    return (max !== undefined && max !== null)
                                                                           ? `Число в поле должно быть не менее ${min} и не более ${max}.`
                                                                           : `Число в поле должно быть не менее ${min}.`;
                                                                }
                                                                return '';
                                                            };
                                                            export const isMaxLengthFulfilledForNumber = (value: number, {min, max}: Attribute) => {
                                                                if (max !== undefined && max !== null && value > max) {
                                                                    return (min !== undefined && min !== null)
                                                                           ? `Число в поле должно быть не менее ${min} и не более ${max}.`
                                                                           : `Число в поле должно быть не более ${max}.`;
                                                                }
                                                                return '';
                                                            };
                                                            src / ui / utils / form - input - validator / validator.ts;
                                                            import {Attribute, AttributeValue, Usage} from 'src/types';
                                                            import {
                                                                isFiniteFulfilledForNumber,
                                                                isMaxLengthFulfilledForNumber,
                                                                isMinLengthFulfilledForNumber,
                                                            } from './number-validator';
                                                            import {
                                                                isEmptyForText,
                                                                isMandatoryFulfilledForText,
                                                                isMaxLengthFulfilledForText,
                                                                isMinLengthFulfilledForText,
                                                                isValidatorsFulfilledForText,
                                                            } from './text-validator';

                                                            export const validateAllAttributes = (attributes: Attribute[],
                                                                                                  values: AttributeValue[]) => {
                                                                return attributes.map((attribute, i) => {
                                                                    switch (attribute.usage) {
                                                                        case (Usage.Password):
                                                                        case (Usage.ShortText):
                                                                        case (Usage.LongText): {
                                                                            const;
                                                                            value = values[i].trim();
                                                                            const;
                                                                            isEmpty = isEmptyForText(value, attribute);
                                                                            if(isEmpty);
                                                                            {
                                                                                return;
                                                                                '';
                                                                            }
                                                                            return isMandatoryFulfilledForText(value, attribute)
                                                                                   || isMinLengthFulfilledForText(value, attribute)
                                                                                   || isMaxLengthFulfilledForText(value, attribute)
                                                                                   || isValidatorsFulfilledForText(value, attribute);
                                                                        }
                                                                        case (Usage.File): {
                                                                            const;
                                                                            value = values[i];
                                                                            if(attribute.mandatory && !value);
                                                                            {
                                                                                return;
                                                                                'Поле обязательно для заполнения.';
                                                                            }
                                                                            return '';
                                                                        }
                                                                        case (Usage.Email): {
                                                                            const;
                                                                            value = values[i].trim();
                                                                            if(isEmptyForText(value, attribute));
                                                                            {
                                                                                return;
                                                                                '';
                                                                            }
                                                                            return isMandatoryFulfilledForText(value, attribute)
                                                                                   || isValidatorsFulfilledForText(value, attribute);
                                                                        }
                                                                        case (Usage.Activity):
                                                                        case (Usage.StudentGroup): {
                                                                            const;
                                                                            value = values[i].trim();
                                                                            if(isEmptyForText(value, attribute));
                                                                            {
                                                                                return;
                                                                                '';
                                                                            }
                                                                            return isMandatoryFulfilledForText(value, attribute);
                                                                        }
                                                                        case (Usage.Stage):
                                                                        case (Usage.Checkbox): {
                                                                            const;
                                                                            value = values[i];
                                                                            if(attribute.mandatory && !value.length);
                                                                            {
                                                                                return;
                                                                                'Поле обязательно для заполнения.';
                                                                            }
                                                                            return '';
                                                                        }
                                                                        case (Usage.Radio): {
                                                                            const;
                                                                            value = values[i];
                                                                            if(attribute.mandatory && value === '');
                                                                            {
                                                                                return;
                                                                                'Поле обязательно для заполнения.';
                                                                            }
                                                                            return '';
                                                                        }
                                                                        case (Usage.Date):
                                                                        case (Usage.Organisation):
                                                                        case (Usage.Student):
                                                                        case (Usage.Mentor): {
                                                                            const;
                                                                            value = values[i];
                                                                            if(attribute.mandatory && (value === undefined || value === null));
                                                                            {
                                                                                return;
                                                                                'Поле обязательно для заполнения.';
                                                                            }
                                                                            return '';
                                                                        }
                                                                        case (Usage.Number): {
                                                                            const;
                                                                            value = parseFloat(values[i]);
                                                                            const;
                                                                            isEmpty = isEmptyForText(values[i].trim(), attribute);
                                                                            if(isEmpty);
                                                                            {
                                                                                return;
                                                                                '';
                                                                            }
                                                                            return isMandatoryFulfilledForText(values[i].trim(), attribute)
                                                                                   || isFiniteFulfilledForNumber(value)
                                                                                   || isMinLengthFulfilledForNumber(value, attribute)
                                                                                   || isMaxLengthFulfilledForNumber(value, attribute);
                                                                        }
                                                                        case Usage.Switch:
                                                                        case Usage.Validator:
                                                                        case Usage.Task:
                                                                        case Usage.Variants:
                                                                        default: {
                                                                            return '';
                                                                        }
                                                                    }
                                                                });
                                                            };
                                                            src / ui / utils / cookie.tsx;
                                                            // возвращает куки с указанным name,
                                                            // или undefined, если ничего не найдено
                                                            export function getCookie(name: string) {
                                                                let matches = document.cookie.match(new RegExp(
                                                                    '(?:^|; )' + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)',
                                                                ));
                                                                return matches ? decodeURIComponent(matches[1]) : undefined;
                                                            }

                                                            export function setCookie(name: string, value: string, options: any = {}) {
                                                                options = {
                                                                    path: '/',
                                                                    samesite: 'strict',
                                                                    expires: new Date(Date.now() + 1000 * 60 * 60 * 24 * 7),
                                                                    ...options,
                                                                };

                                                                if (options.expires && typeof options.expires !== 'string' && options.expires.toUTCString) {
                                                                    options.expires = options.expires.toUTCString();
                                                                }

                                                                const updatedCookie = Object.keys(options).reduce((sum: string, optionKey) => {
                                                                    let optionValue = options[optionKey];
                                                                    let update = '';
                                                                    if (optionValue) {
                                                                        update += '; ' + optionKey;
                                                                        if (optionValue !== true) {
                                                                            update += '=' + optionValue;
                                                                        }
                                                                        return sum + update;
                                                                    }
                                                                    return sum;
                                                                }, encodeURIComponent(name) + '=' + encodeURIComponent(value));

                                                                document.cookie = updatedCookie;
                                                            }

                                                            export function deleteCookie(name: string) {
                                                                setCookie(name, '', {
                                                                    expires: -1,
                                                                });
                                                            }

                                                            src / ui / utils / constants.tsx;
                                                            // TODO собрать все константы

                                                            export const DEFAULT_CHAT_ID = 'DEFAULT_CHAT_ID';
                                                            export const BACKEND_URL = 'http://localhost:8090';
                                                            src / ui / utils / parse - date.tsx;
                                                            export const parseDate = (date: Date) => date.toLocaleString('ru',
                                                                                                                         {
                                                                                                                             year: 'numeric',
                                                                                                                             month: 'long',
                                                                                                                             day: 'numeric',
                                                                                                                         });
                                                            src / ui / utils / auth.ts;
                                                            import {TOKEN_PARAM_NAME} from 'src/api/api';
                                                            import {UserRole} from 'src/types';
                                                            import {deleteCookie} from 'src/ui/utils/cookie';

                                                            export const clearAuthCookie = () => {
                                                                deleteCookie(TOKEN_PARAM_NAME);
                                                            };

                                                            export const redirect = () => {
                                                                if (window.location.pathname !== '/') {
                                                                    window.location.pathname = '/';
                                                                }
                                                            };

                                                            const BASE_PATHNAMES = ['', 'for_partners', 'for_students', 'help', 'contacts'];
                                                            const AUTHED_PATHNAMES = ['user',
                                                                                      'project',
                                                                                      'project_request',
                                                                                      'activity',
                                                                                      'organisation',
                                                                                      'search'];
                                                            const MENTOR_PATHNAMES = ['new_project_request'];
                                                            const MANAGER_PATHNAMES = ['chat', 'forms', 'admin'];
                                                            export const checkURLPermission = (pathname: string, userRole: UserRole) => {
                                                                const [, origin] = pathname.split('/');
                                                                if (typeof origin !== 'string') {
                                                                    redirect();
                                                                }
                                                                switch (userRole) {
                                                                    case UserRole.Supervisor:
                                                                    case UserRole.Manager: {
                                                                        if (!BASE_PATHNAMES.includes(origin)
                                                                            && !AUTHED_PATHNAMES.includes(origin)
                                                                            && !MENTOR_PATHNAMES.includes(origin)
                                                                            && !MANAGER_PATHNAMES.includes(origin)) {
                                                                            redirect();
                                                                        }
                                                                        return;
                                                                    }
                                                                    case UserRole.Representative:
                                                                    case UserRole.Mentor: {
                                                                        if (!BASE_PATHNAMES.includes(origin)
                                                                            && !AUTHED_PATHNAMES.includes(origin)
                                                                            && !MENTOR_PATHNAMES.includes(origin)) {
                                                                            redirect();
                                                                        }
                                                                        return;
                                                                    }
                                                                    case UserRole.Student: {
                                                                        if (!BASE_PATHNAMES.includes(origin)
                                                                            && !AUTHED_PATHNAMES.includes(origin)) {
                                                                            redirect();
                                                                        }
                                                                        return;
                                                                    }
                                                                    case UserRole.Initial:
                                                                    default: {
                                                                        if (!BASE_PATHNAMES.includes(origin)) {
                                                                            clearAuthCookie();
                                                                            redirect();
                                                                        }
                                                                    }
                                                                }
                                                            };
                                                            src / ui / utils / get - formatted - attribute - value.tsx;
                                                            import {Icon} from '@blueprintjs/core';
                                                            import React from 'react';
                                                            import {Link} from 'react-router-dom';
                                                            import {AttributeValue, ProfileOrSearchItem, SearchType, Usage} from 'src/types';
                                                            import {BACKEND_URL} from 'src/ui/utils/constants';

                                                            const getFormattedValue = (value: AttributeValue, usage: Usage) => {
                                                                if (usage === Usage.Switch) {
                                                                    if (typeof value !== 'boolean') {
                                                                        return '';
                                                                    }
                                                                    return value ? 'да' : 'нет';
                                                                }
                                                                if (usage === Usage.Checkbox) {
                                                                    if (typeof value === 'string') {
                                                                        try {
                                                                            return JSON.parse(value).join(', ');
                                                                        } catch (e) {
                                                                            return value;
                                                                        }
                                                                    } else {
                                                                        if (Array.isArray(value)) {
                                                                            return value.join(', ');
                                                                        }
                                                                    }
                                                                }
                                                                return value;
                                                            };

                                                            export const getFormattedStringValue = (value: AttributeValue, usage: Usage): string => {
                                                                if (Array.isArray(value)) {
                                                                    return getFormattedStringValue(value[value.length - 1], usage);
                                                                }
                                                                if (typeof value === 'object') {
                                                                    if (!(value && 'name' in value)) {
                                                                        return '';
                                                                    }
                                                                    return value.name;
                                                                }
                                                                return getFormattedValue(value, usage);
                                                            };

                                                            export const getFormattedStringOrLinkValue = (value: AttributeValue,
                                                                                                          usage: Usage): any => {
                                                                if (value && (typeof value === 'object') && (usage === Usage.File || value.type === 'file')) {
                                                                    if (value && 'name' in value && 'id' in value) {
                                                                        return <a href = {`${BACKEND_URL}/api/v1/${value.type || 'file'}/${value.id}`;
                                                                    }
                                                                        download = {true} > {value.name} < /a>;;
                                                                    }
                                                                }
                                                                if (value && Array.isArray(value)) {
                                                                    return <>
                                                                               {
                                                                                   value.map((val, index) => {
                                                                                       return <>
                                                                                           {
                                                                                               getFormattedStringOrLinkValue(val, usage),
                                                                                           };
                                                                                       {
                                                                                           index !== (value.length - 1) && (usage === Usage.Organisation
                                                                                                                            ? <Icon icon = 'chevron-right' / >
                                                                                                                            : ', ');
                                                                                       }
                                                                                       </>;;
                                                                                   }),
                                                                               }
                                                                           < />;;
                                                                }
                                                                if (typeof value === 'object') {
                                                                    if (value && 'name' in value && 'type' in value && 'id' in value) {
                                                                        return <Link to = {`/${value.type || value.type}/${value.id}`;
                                                                    }>
                                                                        {
                                                                            value.name;
                                                                        }
                                                                        </Link>;;
                                                                    }
                                                                }
                                                                return getFormattedStringValue(value, usage);
                                                            };
                                                            export const getLinkOrText = (item: ProfileOrSearchItem,
                                                                                          searchType: SearchType,
                                                                                          field: string,
                                                                                          usage: Usage) => {
                                                                const value = field in item
                                                                              ? item[field]
                                                                              : ('content' in item && field in item.content)
                                                                                ? item.content[field]
                                                                                : '';

                                                                return getFormattedStringOrLinkValue(value, usage);
                                                            };
                                                            export const getText = (item: ProfileOrSearchItem,
                                                                                    searchType: SearchType,
                                                                                    field: string,
                                                                                    usage: Usage) => {
                                                                const value = field in item
                                                                              ? item[field]
                                                                              : ('content' in item && field in item.content)
                                                                                ? item.content[field]
                                                                                : '';

                                                                return getFormattedStringValue(value, usage);
                                                            };
                                                            src / ui / utils / get - empty - form.tsx;
                                                            import {FormType} from 'src/types';

                                                            export const getEmptyForm = (type: FormType) => ({
                                                                type: type,
                                                                title: '',
                                                                description: '',
                                                                attributes: [],
                                                                buttonName: '',
                                                            });
                                                            src / ui / routes / home / home - page.tsx;
                                                            import {Classes} from '@blueprintjs/core';
                                                            import React, {FC, memo, useMemo} from 'react';
                                                            import {Contacts} from 'src/ui/blocks/contacts/contacts';
                                                            import {Help} from 'src/ui/blocks/default-form-view/help';
                                                            import {Signup} from 'src/ui/blocks/default-form-view/signup';
                                                            import {Empty} from 'src/ui/blocks/empty/empty';
                                                            import {Home} from 'src/ui/blocks/home/home';
                                                            import {Layout} from 'src/ui/blocks/layout/layout';
                                                            import {Partners} from 'src/ui/blocks/partners/partners';
                                                            import {Tab} from 'src/ui/blocks/tab/tab';

                                                            export enum HomePageLocations {
                                                                Main = '/',
                                                                ForPartners = '/for_partners',
                                                                ForStudents = '/for_students',
                                                                Contacts = '/contacts',
                                                                Help = '/help'
                                                            }

                                                            const linksList = [
                                                                {title: 'О Центре', href: HomePageLocations.Main},
                                                                {title: 'Компаниям-партнерам', href: HomePageLocations.ForPartners},
                                                                {title: 'Студентам', href: HomePageLocations.ForStudents},
                                                                {title: 'Контакты', href: HomePageLocations.Contacts},
                                                                {title: 'Помощь', href: HomePageLocations.Help},
                                                            ];

                                                            const homePageLocationsToRightComponentsMap: { [key: string]: FC<{}> } = {
                                                                [HomePageLocations.Main]: Home,
                                                                [HomePageLocations.ForPartners]: Partners,
                                                                [HomePageLocations.ForStudents]: Signup,
                                                                [HomePageLocations.Contacts]: Contacts,
                                                                [HomePageLocations.Help]: Help,
                                                            };
                                                            const homePageLocationsToIndexMap: { [key: string]: number } = {
                                                                [HomePageLocations.Main]: 0,
                                                                [HomePageLocations.ForPartners]: 1,
                                                                [HomePageLocations.ForStudents]: 2,
                                                                [HomePageLocations.Contacts]: 3,
                                                                [HomePageLocations.Help]: 4,

                                                            };

                                                            export const HomePage: FC = memo(() => {
                                                                const RightComponent = useMemo(
                                                                    () => homePageLocationsToRightComponentsMap[window.location.pathname] || Empty,
                                                                    [window.location.pathname],
                                                                );
                                                                const selectedTabId = window.location.pathname in homePageLocationsToIndexMap
                                                                                      ? homePageLocationsToIndexMap[window.location.pathname]
                                                                                      : -1;

                                                                const leftComponent = (
                                                                    <div className = {Classes.FILL} >
                                                                        {
                                                                            linksList.map(({title, href}, index) => (
                                                                                <Tab
                                                                                    key = {index}
                                                                            isActive = {index === selectedTabId,
                                                                        }
                                                                link = {href};
                                                                title = {title};
                                                                />;
                                                            ))
                                                            }
                                                                </div>;
                                                            )
                                                                ;
                                                                return (
                                                                    <Layout leftComponent = {leftComponent}
                                                                rightComponent = { < RightComponent / >
                                                            }
                                                                />;
                                                            )
                                                                ;
                                                            });
                                                            src / ui / routes / new - project - request / new - project - request - page.tsx;
                                                            import {Classes} from '@blueprintjs/core';
                                                            import React, {FC, memo} from 'react';
                                                            import {ProjectRequest} from 'src/ui/blocks/default-form-view/project-request';
                                                            import {Layout} from 'src/ui/blocks/layout/layout';
                                                            import {Tab} from 'src/ui/blocks/tab/tab';

                                                            export const NewProjectRequestPage: FC = memo(() => {

                                                                const leftComponent = (
                                                                    <div className = {Classes.FILL} >
                                                                        {
                                                                            [{title: 'Подать заявку на проект', href: '/new_project_request'}]
                                                                            .map(({title, href}, index) => (
                                                                                <Tab
                                                                                    key = {index}
                                                                            isActive = {true}
                                                                            link = {href}
                                                                            title = {title}
                                                                />;
                                                            ))
                                                            }
                                                                </div>;
                                                            )
                                                                ;
                                                                return <Layout rightComponent = { < ProjectRequest / >
                                                            }
                                                                leftComponent = {leftComponent};
                                                                />;;
                                                            });
                                                            src / ui / routes / forms / forms - page.tsx;
                                                            import {Spinner} from '@blueprintjs/core';
                                                            import React, {FC, useCallback, useEffect, useState} from 'react';
                                                            import {useDispatch, useSelector} from 'react-redux';
                                                            import {errorUserForm} from 'src/store/actions/user-forms.actions';
                                                            import {State} from 'src/store/reducers';
                                                            import {AsyncStatus, Form, FormMode, FormsList} from 'src/types';
                                                            import {Empty} from 'src/ui/blocks/empty/empty';
                                                            import {FormLayout} from 'src/ui/blocks/form-layout/form-layout';
                                                            import {FormsColumn} from 'src/ui/blocks/forms-column/forms-column';
                                                            import {Layout} from 'src/ui/blocks/layout/layout';
                                                            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                                            const getFirstSelectedFormIndex = (search: string,
                                                                                               forms: Form[],
                                                                                               defaultIndex: number) => {
                                                                const selectedFormId = search && search.slice(6);

                                                                if (selectedFormId && forms.length) {
                                                                    const tab = forms.reduce((index: number, item, ind) => {
                                                                        if (item.id === selectedFormId) {
                                                                            return ind;
                                                                        }
                                                                        return index;
                                                                    }, -1);
                                                                    if (tab !== -1) {
                                                                        window.history.replaceState(null,
                                                                                                    'ЦППР',
                                                                                                    window.location.href.replace(search, ''));
                                                                        return tab;
                                                                    }
                                                                }

                                                                return defaultIndex;
                                                            };

                                                            type Props = {
                                                                location: {
                                                                    search: string;
                                                                }
                                                            }
                                                            export const FormsPage: FC<Props> = ({location}) => {
                                                                const cppwApi = useCppwApiContext();
                                                                const dispatch = useDispatch();

                                                                const [currentTab, setCurrentTab] = useState(FormsList.My);
                                                                const {status, forms} = useSelector((state: State) => currentTab === FormsList.My
                                                                                                                      ? state.userForms
                                                                                                                      : state.userArchiveForms);
                                                                const [currentFormIndex, setCurrentFormIndex] = useState(getFirstSelectedFormIndex(
                                                                    location.search,
                                                                    forms,
                                                                    0));

                                                                const onSetError = useCallback((newErrors) => {
                                                                    dispatch(errorUserForm(currentFormIndex, newErrors));
                                                                }, [dispatch, currentFormIndex]);
                                                                const onFormSubmit = useCallback(() => {}, []);

                                                                const leftComponent = (
                                                                    <FormsColumn forms = {forms}
                                                                status = {status};
                                                                currentFormIndex = {currentFormIndex};
                                                                setCurrentFormIndex = {setCurrentFormIndex};
                                                                currentTab = {currentTab};
                                                                setCurrentTab = {setCurrentTab};
                                                                />;
                                                            )
                                                                ;

                                                                useEffect(() => {
                                                                    if (status === AsyncStatus.Initial && cppwApi) {
                                                                        if (currentTab === FormsList.My) {
                                                                            cppwApi.getUserForms();
                                                                        } else {
                                                                            cppwApi.getUserArchiveForms();
                                                                        }
                                                                    }
                                                                }, [status, cppwApi, currentTab]);

                                                                useEffect(() => {
                                                                    window.onbeforeunload = () => {
                                                                        if (forms.some(({mode}: { mode: FormMode }) => mode === FormMode.Edit)) {
                                                                            return 'Данные не сохранены. Точно перейти?';
                                                                        }
                                                                    };
                                                                    setCurrentFormIndex(getFirstSelectedFormIndex(location.search,
                                                                                                                  forms,
                                                                                                                  currentFormIndex));
                                                                }, [location.search, forms, setCurrentFormIndex, currentFormIndex]);

                                                                switch (status) {
                                                                    case AsyncStatus.Success: {
                                                                        if (forms.length === 0) {
                                                                            return <Layout leftComponent = {leftComponent};
                                                                            />;;
                                                                        }
                                                                        const rightComponent = currentFormIndex >= forms.length ? <Empty / > : (
                                                                            <FormLayout
                                                                                index = {currentFormIndex}
                                                                        onSetError = {onSetError};
                                                                        onFormSubmit = {onFormSubmit};
                                                                        {...
                                                                            forms[currentFormIndex];
                                                                        }
                                                                        />;
                                                                    )
                                                                        ;
                                                                        return (
                                                                            <Layout leftComponent = {leftComponent}
                                                                        rightComponent = {rightComponent};
                                                                        />;
                                                                    )
                                                                        ;
                                                                    }
                                                                    case AsyncStatus.Initial:
                                                                    case AsyncStatus.Pending: {
                                                                        return <Layout leftComponent = {leftComponent};
                                                                        rightComponent = { < Spinner;
                                                                        className = 'spinner-full-height' / >
                                                                    }
                                                                        />;;
                                                                    }
                                                                    case AsyncStatus.Error:
                                                                    default: {
                                                                        return <Layout leftComponent = {leftComponent};
                                                                        />;;
                                                                    }
                                                                }

                                                            };
                                                            src / ui / routes / chat / chat - page.tsx;
                                                            import React, {FC, useEffect, useMemo, useState} from 'react';
                                                            import {useSelector} from 'react-redux';
                                                            import {State} from 'src/store/reducers';
                                                            import {AsyncStatus, AttributesByUserRole} from 'src/types';
                                                            import {ChatColumn} from 'src/ui/blocks/chat-column/chat-column';
                                                            import {ChatInfo} from 'src/ui/blocks/chat-info/chat-info';
                                                            import {Layout} from 'src/ui/blocks/layout/layout';
                                                            import {useCppwApiContext} from 'src/ui/contexts/cppw-api-context/cppw-api-context';

                                                            export const ChatPage: FC = () => {
                                                                const cppwApi = useCppwApiContext();
                                                                const {userId} = useSelector((state: State) => state.user.isAuthed
                                                                                                               ? state.user
                                                                                                               : {userId: ''});
                                                                const {status, chats, attributes} = useSelector((state: State) => state.chats);
                                                                const [activeTabIndex, setActiveTabIndex] = useState(0);
                                                                const isEditing = useMemo(() => Boolean(chats && chats[activeTabIndex] && chats[activeTabIndex].isEditing),
                                                                                          [activeTabIndex, chats]);

                                                                useEffect(() => {
                                                                    if (status === AsyncStatus.Initial && cppwApi) {
                                                                        cppwApi.requestChats(userId);
                                                                    }
                                                                }, [userId, status, cppwApi]);

                                                                return <Layout leftComponent = { < ChatColumn;
                                                                status = {status};
                                                                userId = {userId};
                                                                chats = {chats};
                                                                activeTabIndex = {Math.min(activeTabIndex, chats.length)};
                                                                setActiveTabIndex = {setActiveTabIndex};
                                                                />};
                                                                rightComponent = { < ChatInfo;
                                                                status = {status};
                                                                isEditing = {isEditing};
                                                                chatIndex = {Math.min(activeTabIndex, chats.length)};
                                                                attributes = {attributes as AttributesByUserRole};
                                                                chat = {chats[Math.min(activeTabIndex, chats.length)]};
                                                                />}/ >;
                                                            }
                                                                ;
                                                                src / ui / routes / admin / admin - page.tsx;
                                                                import {Classes} from '@blueprintjs/core';
                                                                import React, {FC, memo, useState} from 'react';
                                                                import {Admin} from 'src/ui/blocks/admin/admin';
                                                                import {Layout} from 'src/ui/blocks/layout/layout';
                                                                import {Tab} from 'src/ui/blocks/tab/tab';

                                                                const linksList = [
                                                                    {title: 'Создать активность'},
                                                                    {title: 'Создать проект'},
                                                                    {title: 'Создать организацию'},
                                                                    {title: 'Зарегистрировать пользователя'},
                                                                    {title: 'Начать учебный год'},
                                                                    {title: 'Актуализировать контакты пользователей'},
                                                                    {title: 'Редактировать активные студенческие группы'},
                                                                    {title: 'Добавить студента к активности'},
                                                                ];

                                                                export const AdminPage: FC = memo(() => {
                                                                    const [selectedTab, setSelectedTab] = useState(0);
                                                                    const leftComponent = (
                                                                        <div className = {Classes.FILL} >
                                                                            {
                                                                                linksList.map(({title}, index) => (
                                                                                    <Tab
                                                                                        key = {index}
                                                                                isActive = {index === selectedTab,
                                                                            }
                                                                    title = {title};
                                                                    onClick = {();
                                                                =>
                                                                    {
                                                                        setSelectedTab(index);
                                                                    }
                                                                }
                                                                    />;
                                                                ))
                                                                }
                                                                    </div>;
                                                                )
                                                                    ;
                                                                    return <Layout rightComponent = { < Admin;
                                                                    selectedTab = {selectedTab};
                                                                    />};
                                                                    leftComponent = {leftComponent};
                                                                    />;;
                                                                });
                                                                src / ui / routes / search / search - page.tsx;
                                                                import React, {FC} from 'react';
                                                                import {useSelector} from 'react-redux';
                                                                import {State} from 'src/store/reducers';
                                                                import {Layout} from 'src/ui/blocks/layout/layout';
                                                                import {SearchColumn} from 'src/ui/blocks/search-column/search-column';
                                                                import {SearchResults} from 'src/ui/blocks/search-results/search-results';

                                                                export const SearchPage: FC = () => {
                                                                    const {searchFilterStatus, searchStatus, fields, records, searchType} = useSelector(
                                                                        (state: State) => state.search);
                                                                    return <Layout leftComponent = { < SearchColumn;
                                                                    status = {searchFilterStatus};
                                                                    fields = {fields};
                                                                    searchType = {searchType};
                                                                    />};
                                                                    rightComponent = { < SearchResults;
                                                                    status = {searchStatus};
                                                                    records = {records};
                                                                    fields = {fields};
                                                                    searchType = {searchType};
                                                                    />}/ >;
                                                                }
                                                                    ;
                                                                    src / ui / routes / profile / profile - page.tsx;
                                                                    import React, {FC, useEffect, useState} from 'react';
                                                                    import {ProfileType} from 'src/types';
                                                                    import {Layout} from 'src/ui/blocks/layout/layout';
                                                                    import {Notifications} from 'src/ui/blocks/notifications/notifications';
                                                                    import {ProfileColumn} from 'src/ui/blocks/profile-column/profile-column';
                                                                    import {Profile} from 'src/ui/blocks/profile/profile';
                                                                    import {Vedomost} from 'src/ui/blocks/vedomost/vedomost';

                                                                    export const USER_PROFILE_PATH = '/user/:id';
                                                                    export const PROJECT_PROFILE_PATH = '/project/:id';
                                                                    export const PROJECT_REQUEST_PROFILE_PATH = '/project_request/:id';
                                                                    export const ACTIVITY_PROFILE_PATH = '/activity/:id';
                                                                    export const COMPANY_PROFILE_PATH = '/organisation/:id';

                                                                    export const PATH_TO_PROFILE_TYPE_MAP: { [k: string]: ProfileType } = {
                                                                        [USER_PROFILE_PATH]: ProfileType.User,
                                                                        [PROJECT_PROFILE_PATH]: ProfileType.Project,
                                                                        [PROJECT_REQUEST_PROFILE_PATH]: ProfileType.ProjectRequest,
                                                                        [ACTIVITY_PROFILE_PATH]: ProfileType.Activity,
                                                                        [COMPANY_PROFILE_PATH]: ProfileType.Organisation,
                                                                    };

                                                                    type Props = {
                                                                        userId: string;
                                                                        match: {
                                                                            path: string;
                                                                            params: {
                                                                                id: string;
                                                                            }
                                                                        }
                                                                    }

                                                                    export const ProfilePage: FC<Props> = ({match}) => {
                                                                        const {path} = match;
                                                                        const profileType = PATH_TO_PROFILE_TYPE_MAP[path];
                                                                        const {id} = match.params;
                                                                        const [isEditing, setIsEditing] = useState(false);
                                                                        const [modifyAllowed, setModifyAllowed] = useState(false);
                                                                        const [isBlocked, setIsBlocked] = useState(false);
                                                                        const [selectedIndex, setSelectedIndex] = useState(0);

                                                                        const rightComponent = (selectedIndex === 0) ? <Profile id = {id}
                                                                                               modifyAllowed = {modifyAllowed};
                                                                        setModifyAllowed = {setModifyAllowed};
                                                                        isEditing = {isEditing};
                                                                        setIsEditing = {setIsEditing};
                                                                        isBlocked = {isBlocked};
                                                                        setIsBlocked = {setIsBlocked};
                                                                        profileType = {profileType};
                                                                        /> : (selectedIndex === 1)
                                                                        ? <Notifications / >
                                                                        : <Vedomost profileId = {id};
                                                                        profileType = {profileType};
                                                                        />;;

                                                                        useEffect(() => {
                                                                            setIsEditing(false);
                                                                            setSelectedIndex(0);
                                                                        }, [id]);

                                                                        if (!profileType) {
                                                                            return null;
                                                                        }

                                                                        return <Layout rightComponent = {rightComponent};
                                                                        leftComponent = { < ProfileColumn;
                                                                        profileType = {profileType};
                                                                        modifyAllowed = {modifyAllowed};
                                                                        selectedIndex = {selectedIndex};
                                                                        setSelectedIndex = {setSelectedIndex};
                                                                        setIsEditing = {setIsEditing};
                                                                        isBlocked = {isBlocked};
                                                                        setIsBlocked = {setIsBlocked};
                                                                        id = {id};
                                                                        />}/ >;
                                                                    }
                                                                        ;
                                                                        src / ui / routes / index.ts;
                                                                        import './page.styl';

                                                                        export {HomePage} from './home/home-page';
                                                                        export {ProfilePage} from './profile/profile-page';
                                                                        export {FormsPage} from './forms/forms-page';
                                                                        export {ChatPage} from './chat/chat-page';
                                                                        export {SearchPage} from './search/search-page';
                                                                        export {AdminPage} from './admin/admin-page';
                                                                        export {
                                                                            NewProjectRequestPage,
                                                                        }from './new-project-request/new-project-request-page';
                                                                        src / api / api - parser / chat - parser.tsx;
                                                                        import {checkStrings} from 'src/api/api-parser/type-checkes';
                                                                        import {Chat, HistoryLog} from 'src/store/reducers/chats.reducer';
                                                                        import {ApiResponse} from 'src/types';
                                                                        import {parseDate} from 'src/ui/utils/parse-date';

                                                                        const parseHistoryLog = ({id, date, message, about}: ApiResponse) => {
                                                                            try {
                                                                                checkStrings([id, message, date],
                                                                                             ['id', 'title', 'name', 'link', 'date']);

                                                                                return {
                                                                                    id,
                                                                                    name: about ? about.name : '',
                                                                                    title: message,
                                                                                    link: about ? about.type === 'form'
                                                                                                  ? `/forms?form=${about.id}`
                                                                                                  : `${about.type}/${about.id}` : '',
                                                                                    date: parseDate(new Date(date)),
                                                                                };
                                                                            } catch (e) {
                                                                                console.error(`Wrong history log ${id} format: ${e.message}`);
                                                                            }
                                                                        };

                                                                        export const parseHistoryLogs = (logs: ApiResponse): HistoryLog[] => {
                                                                            if (!Array.isArray(logs)) {
                                                                                console.error(`Wrong api answer! (parseHistoryLogs)`);
                                                                                return [];
                                                                            }

                                                                            return logs.map((item: ApiResponse) => parseHistoryLog(item))
                                                                                       .filter((item: HistoryLog | undefined) => !!item) as HistoryLog[];
                                                                        };

                                                                        const parseChat = ({id, name, users}: ApiResponse): Chat | undefined => {
                                                                            try {
                                                                                checkStrings([id, name], ['id', 'name']);

                                                                                return {
                                                                                    id,
                                                                                    name,
                                                                                    // TODO ParseUser
                                                                                    users,
                                                                                };
                                                                            } catch (e) {
                                                                                console.error(`Wrong chat ${id} format: ${e.message}`);
                                                                            }
                                                                        };

                                                                        export const parseChats = (chats: ApiResponse): Chat[] => {
                                                                            if (!Array.isArray(chats)) {
                                                                                console.error(`Wrong api answer! (parseChats)`);
                                                                                return [];
                                                                            }

                                                                            return chats.map((item: ApiResponse) => parseChat(item))
                                                                                        .filter((item: Chat | undefined) => !!item) as Chat[];
                                                                        };
                                                                        src / api / api - parser / jwt - parser.tsx;
                                                                        export const parseJWT = (token: string) => {
                                                                            try {
                                                                                const base64Url = token.split('.')[1];
                                                                                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                                                                                const jsonPayload = decodeURIComponent(atob(base64).split('').map(
                                                                                    function (c) {
                                                                                        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                                                                                    }).join(''));

                                                                                const res = JSON.parse(jsonPayload);
                                                                                return {
                                                                                    userId: res['https://dev-cppr.auth0/userinfo/user_id'],
                                                                                    role: res['https://dev-cppr.auth0/userinfo/role'],
                                                                                    exp: res.exp,
                                                                                    email: res.email,
                                                                                    email_verified: res.email_verified,
                                                                                    token,
                                                                                };
                                                                            } catch (e) {
                                                                                console.error('Parse jwt error: ', e, token);
                                                                                return null;
                                                                            }
                                                                        };
                                                                        src / api / api - parser / type - checkes.tsx;
                                                                        import {ApiResponse} from 'src/types';

                                                                        const isBoolean = (val: ApiResponse) => (
                                                                            typeof val === 'boolean'
                                                                        );
                                                                        export const checkBooleans = (vals: ApiResponse[], names: string[]) => {
                                                                            vals.forEach((val, ind) => {
                                                                                if (!isBoolean(val)) {
                                                                                    throw Error(`Wrong attribute property type ${names[ind]}`);
                                                                                }
                                                                            });
                                                                        };
                                                                        const isOptionalString = (val: ApiResponse) => (
                                                                            typeof val === 'string' || typeof val === 'undefined' || val === null
                                                                        );
                                                                        export const checkOptionalStrings = (vals: ApiResponse[],
                                                                                                             names: string[]) => {
                                                                            vals.forEach((val, ind) => {
                                                                                if (!isOptionalString(val)) {
                                                                                    throw Error(`Wrong attribute property type ${names[ind]}`);
                                                                                }
                                                                            });
                                                                        };
                                                                        const isString = (val: ApiResponse) => (
                                                                            typeof val === 'string'
                                                                        );
                                                                        export const checkStrings = (vals: ApiResponse[], names: string[]) => {
                                                                            vals.forEach((val, ind) => {
                                                                                if (!isString(val)) {
                                                                                    throw Error(`Wrong attribute property type ${names[ind]}`);
                                                                                }
                                                                            });
                                                                        };
                                                                        const isOptionalNumber = (val: ApiResponse) => (
                                                                            typeof val === 'number' || typeof val === 'undefined' || val === null
                                                                        );
                                                                        export const checkOptionalNumbers = (vals: ApiResponse[],
                                                                                                             names: string[]) => {
                                                                            vals.forEach((val, ind) => {
                                                                                if (!isOptionalNumber(val)) {
                                                                                    throw Error(`Wrong attribute property type ${names[ind]}`);
                                                                                }
                                                                            });
                                                                        };
                                                                        const isNumber = (val: ApiResponse) => (
                                                                            typeof val === 'number'
                                                                        );
                                                                        const checkNumbers = (vals: ApiResponse[], names: string[]) => {
                                                                            vals.forEach((val, ind) => {
                                                                                if (!isNumber(val)) {
                                                                                    throw Error(`Wrong attribute property type ${names[ind]}`);
                                                                                }
                                                                            });
                                                                        };
                                                                        src / api / api - parser / form - parser.tsx;
                                                                        import {
                                                                            ApiResponse,
                                                                            Attribute,
                                                                            Form,
                                                                            FormMode,
                                                                            FormType,
                                                                            Usage,
                                                                            Validator,
                                                                        } from 'src/types';
                                                                        import {
                                                                            checkBooleans,
                                                                            checkOptionalNumbers,
                                                                            checkOptionalStrings,
                                                                            checkStrings,
                                                                        } from './type-checkes';

                                                                        const getUsage: (usage: string) => Usage = (usage) => {
                                                                            if (Object.values(Usage).includes(usage as Usage)) {
                                                                                return usage as Usage;
                                                                            }
                                                                            throw new Error(`Unknown usage ${usage}`);
                                                                        };

                                                                        export const getFormType: (formType: string) => FormType = (formType) => {
                                                                            if (Object.values(FormType).includes(formType as FormType)) {
                                                                                return formType as FormType;
                                                                            }
                                                                            throw new Error(`Unknown form type ${formType}`);
                                                                        };

                                                                        const parseValidator = ({regexp, message}: ApiResponse): Validator | undefined => {
                                                                            checkStrings([message, regexp], ['message', 'regexp']);
                                                                            try {
                                                                                return {
                                                                                    message,
                                                                                    regexp: regexp,
                                                                                };
                                                                            } catch (e) {
                                                                                throw Error(`Wrong attribute validator: ${e.message}`);
                                                                            }
                                                                        };

                                                                        export const parseAttribute = ({
                                                                                                           id,
                                                                                                           name,
                                                                                                           description,
                                                                                                           usage,
                                                                                                           title,
                                                                                                           mandatory,
                                                                                                           hint,
                                                                                                           validators,
                                                                                                           min,
                                                                                                           max,
                                                                                                           placeholder,
                                                                                                           variants,
                                                                                                       }: ApiResponse) => {
                                                                            try {
                                                                                const parsedUsage = getUsage(usage);
                                                                                checkStrings([id, name, title], ['id', 'name', 'title']);
                                                                                checkOptionalStrings([hint, placeholder],
                                                                                                     ['hint', 'placeholder', 'description']);
                                                                                checkOptionalNumbers([min, max], ['min', 'max']);
                                                                                checkBooleans([mandatory], ['mandatory']);

                                                                                return {
                                                                                    id,
                                                                                    name,
                                                                                    description: description === null ? '' : description,
                                                                                    usage: parsedUsage,
                                                                                    title,
                                                                                    mandatory,
                                                                                    hint: hint === null ? '' : hint,
                                                                                    min: min === null ? undefined : min,
                                                                                    max: max === null ? undefined : max,
                                                                                    validators: validators.map(parseValidator),
                                                                                    placeholder: placeholder === null ? '' : placeholder,
                                                                                    variants,
                                                                                    isAdded: true,
                                                                                };
                                                                            } catch (e) {
                                                                                console.error(`Wrong attribute (${name}) format: ${e.message}`);
                                                                            }

                                                                        };

                                                                        const parseField = ({
                                                                                                name,
                                                                                                title,
                                                                                                modifyAllowed,
                                                                                                attribute,
                                                                                            }: ApiResponse) => {
                                                                            try {
                                                                                checkStrings([name, title], ['name', 'title']);

                                                                                return {
                                                                                    name,
                                                                                    title,
                                                                                    modifyAllowed: Boolean(modifyAllowed),
                                                                                    attribute: parseAttribute(attribute),
                                                                                };
                                                                            } catch (e) {
                                                                                console.error(`Wrong attribute (${name}) format: ${e.message}`);
                                                                            }

                                                                        };

                                                                        export const parseAttributes = (attributes: ApiResponse) => {
                                                                            try {
                                                                                return attributes.map(parseAttribute)
                                                                                                 .filter((item: Attribute | undefined) => !!item);
                                                                            } catch (e) {
                                                                                console.error(`Wrong api answer! (parseAttributes)`);
                                                                                return [];
                                                                            }
                                                                        };
                                                                        export const parseFields = (fields: ApiResponse) => {
                                                                            try {
                                                                                return fields.map(parseField)
                                                                                             .filter((item: Attribute | undefined) => !!item)
                                                                                             .map(({attribute, modifyAllowed, name}: { attribute: Attribute, modifyAllowed: boolean, name: string }) => ({
                                                                                                 ...attribute,
                                                                                                 modifyAllowed,
                                                                                                 realName: name,
                                                                                             }));
                                                                            } catch (e) {
                                                                                console.error(`Wrong api answer! (parseFields)`);
                                                                                return [];
                                                                            }
                                                                        };

                                                                        export const parseForm = ({
                                                                                                      id,
                                                                                                      schemaType,
                                                                                                      title,
                                                                                                      description,
                                                                                                      attributes,
                                                                                                      fields,
                                                                                                      buttonName,
                                                                                                      schemaContent,
                                                                                                  }: ApiResponse, mode: FormMode) => {
                                                                            try {
                                                                                checkStrings([id, title], ['id', 'title']);
                                                                                checkOptionalStrings([buttonName, description],
                                                                                                     ['buttonName', 'description']);

                                                                                return {
                                                                                    id,
                                                                                    type: getFormType(schemaType),
                                                                                    title,
                                                                                    attributes: [...parseFields(fields),
                                                                                                 ...parseAttributes(attributes)],
                                                                                    buttonName,
                                                                                    description,
                                                                                    errors: [],
                                                                                    mode: mode,
                                                                                    content: schemaContent ? JSON.parse(schemaContent) : undefined,
                                                                                };
                                                                            } catch (e) {
                                                                                console.error(`Wrong form ${id} format: ${e.message}`);
                                                                            }
                                                                        };

                                                                        export const parseForms = (formsFromApi: ApiResponse, mode: FormMode) => {
                                                                            if (!formsFromApi.map || typeof formsFromApi.map !== 'function') {
                                                                                console.error(`Wrong api answer! (parseForms)`);
                                                                                return [];
                                                                            }

                                                                            return formsFromApi.map((item: ApiResponse) => parseForm(item, mode))
                                                                                               .filter((item: Form | undefined) => !!item);
                                                                        };
                                                                        src / api / api - parser / profile - parser.tsx;
                                                                        import {UserRole} from 'src/types';

                                                                        export const parseUserRole: (role: string) => UserRole = (role) => {
                                                                            if (Object.values(UserRole).includes(role as UserRole)) {
                                                                                return role as UserRole;
                                                                            }
                                                                            throw new Error('Ошибка парсинга роли пользователя');
                                                                        };
                                                                        src / api / api.tsx;
                                                                        import {Intent} from '@blueprintjs/core';
                                                                        import React from 'react';
                                                                        import {Link} from 'react-router-dom';
                                                                        import {Store} from 'redux';
                                                                        import {parseChats, parseHistoryLogs} from 'src/api/api-parser/chat-parser';
                                                                        import {
                                                                            parseAttribute,
                                                                            parseFields,
                                                                            parseForm,
                                                                            parseForms,
                                                                        } from 'src/api/api-parser/form-parser';
                                                                        import {parseUserRole} from 'src/api/api-parser/profile-parser';
                                                                        import {
                                                                            addNewAttribute,
                                                                            editAttribute,
                                                                            errorAttributeByUsage,
                                                                            receiveAttributeByUsage,
                                                                            requestAttributeByUsage,
                                                                        } from 'src/store/actions/attributes.actions';
                                                                        import {
                                                                            addHistoryLogs,
                                                                            deleteChat,
                                                                            editChat,
                                                                            errorChats,
                                                                            errorHistoryLogs,
                                                                            receiveChats,
                                                                            receiveHistoryLogs,
                                                                            requestChats,
                                                                            requestHistoryLogs,
                                                                        } from 'src/store/actions/chats.actions';
                                                                        import {
                                                                            errorFormByType,
                                                                            receiveFormByType,
                                                                            requestFormByType,
                                                                        } from 'src/store/actions/default-forms.actions';
                                                                        import {
                                                                            errorFullSearch,
                                                                            errorSearch,
                                                                            receiveFullSearch,
                                                                            receiveSearch,
                                                                            requestFullSearch,
                                                                            requestSearch,
                                                                        } from 'src/store/actions/search.actions';
                                                                        import {
                                                                            addArchiveForm,
                                                                            errorUserArchiveForms,
                                                                            removeArchiveForm,
                                                                            requestUserArchiveForms,
                                                                            successUserArchiveForms,
                                                                        } from 'src/store/actions/user-archive-forms.actions';
                                                                        import {
                                                                            addDraftFormAttributeProperties,
                                                                            editUserForm,
                                                                            errorFormStats,
                                                                            errorUserForms,
                                                                            requestFormStats,
                                                                            requestUserForms,
                                                                            successFormStats,
                                                                            successUserForms,
                                                                        } from 'src/store/actions/user-forms.actions';
                                                                        import {setUserData} from 'src/store/actions/user.actions';
                                                                        import {State} from 'src/store/reducers';
                                                                        import {Chat, HistoryLog} from 'src/store/reducers/chats.reducer';
                                                                        import {
                                                                            ApiResponse,
                                                                            Attribute,
                                                                            AttributesByUserRole,
                                                                            AttributeValue,
                                                                            Form,
                                                                            FormMode,
                                                                            FormType,
                                                                            ProfileOrSearchItem,
                                                                            ProfileStatus,
                                                                            ProfileType,
                                                                            ProjectApplicationStatus,
                                                                            ProjectRequestStatus,
                                                                            ToasterFromContext,
                                                                            Usage,
                                                                            UserAction,
                                                                            UserRole,
                                                                        } from 'src/types';
                                                                        import {StageMode} from 'src/ui/blocks/stage-view/stage-view';
                                                                        import {clearAuthCookie, redirect} from 'src/ui/utils/auth';
                                                                        import {BACKEND_URL, DEFAULT_CHAT_ID} from 'src/ui/utils/constants';
                                                                        import {getCookie, setCookie} from 'src/ui/utils/cookie';
                                                                        import {parseJWT} from './api-parser/jwt-parser';
                                                                        import notificationsList from './notifications-list.json';
                                                                        import organisationMembers from './organisation-members.json';
                                                                        import organisationProfile from './organisation-profile.json';
                                                                        import organisationStructure from './organisation-structure.json';

                                                                        export const TOKEN_PARAM_NAME = 'token';

                                                                        export const STUDENT_ID = '0a9728ac-9d00-11ea-b58a-4b77bf19dd29';
                                                                        export const getRandomId = () => Math.random().toString(36).substring(2,
                                                                                                                                              15) + Math.random()
                                                                                                                                                        .toString(
                                                                                                                                                            36)
                                                                                                                                                        .substring(
                                                                                                                                                            2,
                                                                                                                                                            15);

                                                                        export const formSearchUrl = (fields: Attribute[]) => {
                                                                            const staticFields = fields.filter(({realName}: { realName?: string }) => realName)
                                                                                                       .reduce((
                                                                                                                   res: { [k: string]: AttributeValue },
                                                                                                                   {realName, defaultValue}: Attribute,
                                                                                                               ) => {
                                                                                                           if (!defaultValue || !realName) {
                                                                                                               return res;
                                                                                                           } else {
                                                                                                               return {
                                                                                                                   ...res,
                                                                                                                   [realName]: defaultValue,
                                                                                                               };
                                                                                                           }
                                                                                                       }, {});
                                                                            const content = fields.filter(({realName}: { realName?: string }) => !realName)
                                                                                                  .reduce((
                                                                                                              res: { [k: string]: AttributeValue },
                                                                                                              {name, defaultValue}: Attribute,
                                                                                                          ) => {
                                                                                                      if (!defaultValue) {
                                                                                                          return res;
                                                                                                      } else {
                                                                                                          return {
                                                                                                              ...res,
                                                                                                              [name]: defaultValue,
                                                                                                          };
                                                                                                      }
                                                                                                  }, {});
                                                                            const statics = Object.keys(staticFields).reduce((res,
                                                                                                                              key) => res + `&${key}=${staticFields[key]}`,
                                                                                                                             '');
                                                                            const dynamics = Object.keys(content).length
                                                                                             ? `&filter_params=${JSON.stringify(content)
                                                                                                                     .split('}')
                                                                                                                     .join('')
                                                                                                                     .split(
                                                                                                                         '{')
                                                                                                                     .join('')}`
                                                                                             : '';

                                                                            return `?${statics}${dynamics}`;
                                                                        };

                                                                        export class CppwApi {
                                                                            store: Store<State>;
                                                                            toaster: ToasterFromContext;
                                                                            token: string = '';

                                                                            constructor(store: Store<State>, toaster: ToasterFromContext) {
                                                                                this.store = store;
                                                                                this.toaster = toaster;

                                                                                this.init();
                                                                            }

                                                                            init() {
                                                                                const dispatch = this.store.dispatch;
                                                                                const cashedToken = getCookie(TOKEN_PARAM_NAME);
                                                                                const urlToken = (
                                                                                                     window.location && window.location.search
                                                                                                 )
                                                                                                 ? window.location.search
                                                                                                         .slice(1)
                                                                                                         .split('&')
                                                                                                         .reduce((res, cur) => {
                                                                                                             if (res) {
                                                                                                                 return res;
                                                                                                             }
                                                                                                             const [name, val] = cur.split('=');
                                                                                                             return (
                                                                                                                        name === TOKEN_PARAM_NAME
                                                                                                                    ) ? val : res;
                                                                                                         }, '')
                                                                                                 : undefined;

                                                                                const parsedCashedToken = cashedToken ? parseJWT(cashedToken) : null;
                                                                                const parsedUrlToken = urlToken ? parseJWT(urlToken) : null;

                                                                                // смотрим на даты их и выбираем более новый
                                                                                const finalParsedData = parsedCashedToken
                                                                                                        ? parsedUrlToken
                                                                                                          ? (
                                                                                                                parsedCashedToken.exp < parsedUrlToken.exp
                                                                                                            ) ? parsedCashedToken : parsedUrlToken
                                                                                                          : parsedCashedToken
                                                                                                        : parsedUrlToken ? parsedUrlToken : null;

                                                                                if (finalParsedData) {
                                                                                    if ((finalParsedData?.exp * 1000) < Date.now()) {
                                                                                        clearAuthCookie();
                                                                                        redirect();
                                                                                    } else {
                                                                                        dispatch(setUserData(finalParsedData));
                                                                                        setCookie(TOKEN_PARAM_NAME,
                                                                                                  finalParsedData.token,
                                                                                                  {expires: finalParsedData.exp});
                                                                                        this.token = finalParsedData.token;
                                                                                    }
                                                                                }
                                                                                if (urlToken !== undefined) {
                                                                                    window.history.replaceState(null, 'ЦППР', window.location.href
                                                                                                                                    .replace(`${TOKEN_PARAM_NAME}=${urlToken}&`,
                                                                                                                                             '')
                                                                                                                                    .replace(`&${TOKEN_PARAM_NAME}=${urlToken}`,
                                                                                                                                             '')
                                                                                                                                    .replace(`?${TOKEN_PARAM_NAME}=${urlToken}`,
                                                                                                                                             ''),
                                                                                    );
                                                                                }
                                                                            }

                                                                            async get(path: string, params: RequestInit = {}) {
                                                                                const answer = await fetch(`${BACKEND_URL}/api/v1/${path}`, params);
                                                                                if (answer.status === 401) {
                                                                                    clearAuthCookie();
                                                                                    redirect();
                                                                                }
                                                                                return await answer.json();
                                                                            }

                                                                            async makeRequest({getResult, onRequest, onReceive, onError, onRetry, errorMessage, successMessage}: {
                                                                                                  getResult: () => Promise<ApiResponse>,
                                                                                                  onRequest?: () => void,
                                                                                                  onReceive: (result: ApiResponse) => void,
                                                                                                  onError?: () => void,
                                                                                                  onRetry?: () => void,
                                                                                                  errorMessage?: string,
                                                                                                  successMessage?: string,
                                                                                              },
                                                                            ) {
                                                                                const toaster = this.toaster;
                                                                                try {
                                                                                    onRequest && onRequest();
                                                                                    const result = await getResult();
                                                                                    onReceive(result);
                                                                                    if (toaster.current && successMessage) {
                                                                                        toaster.current.show(
                                                                                            {
                                                                                                icon: 'tick',
                                                                                                intent: Intent.SUCCESS,
                                                                                                message: successMessage,
                                                                                            },
                                                                                        );
                                                                                    }
                                                                                } catch (e) {
                                                                                    onError && onError();
                                                                                    console.error(e);
                                                                                    if (toaster.current && onRetry && errorMessage) {
                                                                                        toaster.current.show(
                                                                                            {
                                                                                                action: {
                                                                                                    onClick: onRetry,
                                                                                                    text: 'Повторить',
                                                                                                },
                                                                                                icon: 'error',
                                                                                                intent: Intent.DANGER,
                                                                                                message: errorMessage,
                                                                                            },
                                                                                        );
                                                                                    }
                                                                                }
                                                                            }

                                                                            // На успех - глобальный стейт + тостер, На ошибку - тостер
                                                                            async updateDefaultForm(form: Form) {
                                                                                const dispatch = this.store.dispatch;
                                                                                const {id, type} = form;
                                                                                const getResult = async () => {
                                                                                    return await this.get(`current-schema/update/${type}`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({
                                                                                                                 schemaId: id,
                                                                                                             }),
                                                                                    });
                                                                                };
                                                                                const onReceive = () => {
                                                                                    dispatch(receiveFormByType(type, form));
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.updateDefaultForm(form);
                                                                                };
                                                                                const successMessage = 'Дефолтная форма задана успешно.';
                                                                                const errorMessage = 'Не удалось задать дефолтную форму';
                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            // На успех - глобальный стейт, На ошибку - глобальный стейт + тостер
                                                                            async getDefaultForm(type: FormType) {
                                                                                const dispatch = this.store.dispatch;

                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/current-schema/${type}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    dispatch(requestFormByType(type));
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const parsedForm = parseForm(result, FormMode.Fill);
                                                                                    if (parsedForm) {
                                                                                        dispatch(receiveFormByType(type, parsedForm));
                                                                                    } else {
                                                                                        dispatch(errorFormByType(type));
                                                                                    }
                                                                                };
                                                                                const onError = () => {
                                                                                    dispatch(errorFormByType(type));
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.getDefaultForm(type);
                                                                                };
                                                                                const errorMessage = 'Ошибка загрузки формы.';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onRequest,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     onError,
                                                                                                     errorMessage,
                                                                                                 });
                                                                            }

                                                                            // На успех - глобальный стейт, На ошибку - глобальный стейт
                                                                            async getUserForms() {
                                                                                const dispatch = this.store.dispatch;

                                                                                const getResult = async () => {
                                                                                    return await this.get('formatted/schemas/');
                                                                                };
                                                                                const onRequest = () => {
                                                                                    dispatch(requestUserForms());
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    dispatch(successUserForms(parseForms(result, FormMode.View)));
                                                                                };
                                                                                const onError = () => {
                                                                                    dispatch(errorUserForms());
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getUserArchiveForms() {
                                                                                const dispatch = this.store.dispatch;

                                                                                const getResult = async () => {
                                                                                    // TODO заменить как появится ручка
                                                                                    return await this.get('formatted/schemas/');
                                                                                };
                                                                                const onRequest = () => {
                                                                                    dispatch(requestUserArchiveForms());
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    dispatch(successUserArchiveForms(parseForms(result,
                                                                                                                                FormMode.View)));
                                                                                };
                                                                                const onError = () => {
                                                                                    dispatch(errorUserArchiveForms());
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async saveAttribute(id: string,
                                                                                                index: number,
                                                                                                newAttribute: Partial<Attribute>,
                                                                                                formIndex: number) {
                                                                                const dispatch = this.store.dispatch;
                                                                                const isCreate = id === DEFAULT_ATTRIBUTE_ID;

                                                                                const getResult = async () => {
                                                                                    return await this.get(`attribute/${isCreate ? '' : id}`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify(newAttribute),
                                                                                    });
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const newAttribute: Attribute | undefined = parseAttribute(result);
                                                                                    if (!newAttribute) {
                                                                                        throw Error('Wrong api response! (saveAttribute)');
                                                                                    }
                                                                                    if (isCreate) {
                                                                                        dispatch(addNewAttribute(newAttribute.usage, newAttribute));
                                                                                    } else {
                                                                                        dispatch(editAttribute(newAttribute.usage, newAttribute));
                                                                                    }
                                                                                    newAttribute.isPlaceholder = false;
                                                                                    dispatch(addDraftFormAttributeProperties(formIndex,
                                                                                                                             index,
                                                                                                                             newAttribute));
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.saveAttribute(id, index, newAttribute, formIndex);
                                                                                };
                                                                                const errorMessage = 'Ошибка создания атрибута.';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            async getAttributesByUsage(usage: Usage) {
                                                                                const dispatch = this.store.dispatch;
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/attributes-by-usage-name/${usage}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    dispatch(requestAttributeByUsage(usage));
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    dispatch(receiveAttributeByUsage(
                                                                                        usage,
                                                                                        (result || []).map(parseAttribute),
                                                                                    ));
                                                                                };
                                                                                const onError = () => {
                                                                                    dispatch(errorAttributeByUsage(usage));
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.getAttributesByUsage(usage);
                                                                                };
                                                                                const errorMessage = 'Ошибка загрузки атрибутов.';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onRequest,
                                                                                                     onReceive,
                                                                                                     onError,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                 });
                                                                            }

                                                                            async saveForm(index: number,
                                                                                           form: Partial<Form>,
                                                                                           onSuccess: () => void) {
                                                                                const dispatch = this.store.dispatch;
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/schema/${!form.id || form.id === DEFAULT_FORM_ID
                                                                                                                              ? ''
                                                                                                                              : form.id}`, {
                                                                                                              method: 'POST',
                                                                                                              body: JSON.stringify({
                                                                                                                                       ...form,
                                                                                                                                       attributes: form.attributes
                                                                                                                                                   ? form.attributes.filter(
                                                                                                                                               ({realName}: Attribute) => !realName)
                                                                                                                                                   : [],
                                                                                                                                   }),
                                                                                                          });
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    dispatch(editUserForm(index,
                                                                                                          {
                                                                                                              ...form,
                                                                                                              id: result.id,
                                                                                                              attributes: form.attributes,
                                                                                                          }));
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.saveForm(index, form, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка сохранения формы.';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            async fullSearch() {
                                                                                const dispatch = this.store.dispatch;
                                                                                const state = this.store.getState();
                                                                                const {searchType, fields} = state.search;

                                                                                const params = formSearchUrl(fields);
                                                                                const getResult = async () => {
                                                                                    return await this.get(`search/${searchType}${params}`);
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    dispatch(receiveSearch(result));
                                                                                };
                                                                                const onRequest = () => {
                                                                                    dispatch(requestSearch());
                                                                                };
                                                                                const onError = () => {
                                                                                    dispatch(errorSearch());
                                                                                };

                                                                                this.makeRequest({getResult, onReceive, onError, onRequest});
                                                                            }

                                                                            async search() {
                                                                                const dispatch = this.store.dispatch;
                                                                                const state = this.store.getState();

                                                                                const getResult = async () => {
                                                                                    return await this.get(`search/${state.search.searchType}`);
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const parsedForm = parseForm(result.schema, FormMode.View);
                                                                                    if (!parsedForm) {
                                                                                        dispatch(errorFullSearch());
                                                                                    } else {
                                                                                        dispatch(receiveFullSearch({
                                                                                                                       records: result.records,
                                                                                                                       schema: parsedForm,
                                                                                                                   }));
                                                                                    }
                                                                                };
                                                                                const onRequest = () => {
                                                                                    dispatch(requestFullSearch());
                                                                                };
                                                                                const onError = () => {
                                                                                    dispatch(errorFullSearch());
                                                                                };

                                                                                this.makeRequest({getResult, onReceive, onError, onRequest});
                                                                            }

                                                                            async getProfile(id: string,
                                                                                             profileType: ProfileType,
                                                                                             handleRequest: () => void,
                                                                                             handleReceive: (profile: ProfileOrSearchItem,
                                                                                                             fuelds: Attribute[],
                                                                                                             info: UserRole | ProjectRequestStatus | string,
                                                                                                             firstList: any[],
                                                                                                             hasWarning: boolean,
                                                                                                             status: ProfileStatus,
                                                                                                             schemaContentId: string,
                                                                                                             modifyAllowed: boolean) => void,
                                                                                             handleError: () => void) {
                                                                                const user = this.store.getState().user;
                                                                                const {userId} = user.isAuthed ? user : {userId: ''};
                                                                                const getResult = async () => {
                                                                                    if (!user.isAuthed) {
                                                                                        throw new Error();
                                                                                    }
                                                                                    if (profileType === ProfileType.Organisation) {
                                                                                        return organisationProfile;
                                                                                    }
                                                                                    if (profileType === ProfileType.Project && user.role === UserRole.Student) {
                                                                                        return await this.get(`formatted/project-for-student?projectId=${id}&studentId=${userId}`);
                                                                                    }
                                                                                    return await this.get(`formatted/${profileType}-profile/${id}`);
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    if (!user.isAuthed) {
                                                                                        throw new Error();
                                                                                    }
                                                                                    // TODO Это всё-таки парсинг (его бы вынести отсюда)
                                                                                    const content = result.schemaContent
                                                                                                    ? JSON.parse(result.schemaContent)
                                                                                                    : {};
                                                                                    const parsedForm = parseForm(result, FormMode.View);
                                                                                    if (parsedForm) {
                                                                                        let hasWarning = false;
                                                                                        const fields = parsedForm.attributes.map((item) => {
                                                                                            if (item.realName) {
                                                                                                return {...item, defaultValue: result[item.realName]};
                                                                                            }
                                                                                            if (item.name in content) {
                                                                                                return {...item, defaultValue: content[item.name]};
                                                                                            }
                                                                                            if (!hasWarning && (profileType === ProfileType.User || profileType === ProfileType.Organisation)) {
                                                                                                hasWarning = true;
                                                                                            }
                                                                                            return (
                                                                                                {...item}
                                                                                            );
                                                                                        });
                                                                                        const info = (profileType === ProfileType.User)
                                                                                                     ? result.role
                                                                                                     : (profileType === ProfileType.ProjectRequest)
                                                                                                       ? result.status
                                                                                                       : '';

                                                                                        const stages = [ProfileType.Project,
                                                                                                        ProfileType.Activity].includes(profileType) && result.stages
                                                                                                       ? result.stages.map((stage: ApiResponse) => ({
                                                                                                ...stage,
                                                                                                stageMode: (user.role === UserRole.Student && result.modifyAllowed)
                                                                                                           ? StageMode.Student
                                                                                                           : StageMode.All,
                                                                                            }))
                                                                                                       : undefined;
                                                                                        const posts = ([ProfileType.User,
                                                                                                        ProfileType.Organisation,
                                                                                                        ProfileType.ProjectRequest].includes(
                                                                                            profileType) && result.posts)
                                                                                                      ? result.posts
                                                                                                      : undefined;
                                                                                        const firstList = stages || posts || [];
                                                                                        handleReceive(result,
                                                                                                      fields,
                                                                                                      info,
                                                                                                      firstList,
                                                                                                      hasWarning,
                                                                                                      result.status,
                                                                                                      result.schemaContentId,
                                                                                                      result.modifyAllowed);
                                                                                    } else {
                                                                                        handleError();
                                                                                    }
                                                                                };

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onRequest: handleRequest,
                                                                                                     onReceive,
                                                                                                     onError: handleError,
                                                                                                 });
                                                                            }

                                                                            async saveProfile(id: string,
                                                                                              type: string,
                                                                                              newProfile: ProfileOrSearchItem) {
                                                                                if (type === ProfileType.Activity) {
                                                                                    newProfile.course = newProfile.course
                                                                                                        ? Number(newProfile.course)
                                                                                                        : newProfile.course;
                                                                                    return await this.get(`formatted/activity/update/${id}`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify(newProfile),
                                                                                    });
                                                                                }

                                                                                return await this.get(`formatted/${type}-profile/${id}`, {
                                                                                    method: 'POST',
                                                                                    body: JSON.stringify(newProfile),
                                                                                });
                                                                            }

                                                                            async submitDefaultForm(req: { [k: string]: AttributeValue },
                                                                                                    onSubmit: () => void,
                                                                                                    path: string,
                                                                                                    additional: {}) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(path, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({
                                                                                                                 ...req,
                                                                                                                 content: JSON.stringify(req.content), ...additional,
                                                                                                             }),

                                                                                    });
                                                                                };
                                                                                const onReceive = () => {
                                                                                    onSubmit();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.submitDefaultForm(req, onSubmit, path, additional);
                                                                                };
                                                                                const errorMessage = 'Ошибка отправки формы.';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            async requestChats(userId: string) {
                                                                                const dispatch = this.store.dispatch;

                                                                                const getResult = async () => {
                                                                                    // Все чаты создаются 123e4567-e89b-12d3-a000-000000000000 ?
                                                                                    return await this.get(`formatted/mail-groups/${userId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    dispatch(requestChats());
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    if (!('mail-fields' in result && 'groups' in result)) {
                                                                                        dispatch(errorChats());
                                                                                        return;
                                                                                    }
                                                                                    const attributes = Object.keys(result['mail-fields'])
                                                                                                             .reduce((res: { [k in UserRole]?: Attribute[] },
                                                                                                                      item: string) => {
                                                                                                                 const userRole = parseUserRole(item);
                                                                                                                 res[userRole] = parseFields(result['mail-fields'][userRole]);
                                                                                                                 return res;
                                                                                                             }, {}) as AttributesByUserRole;
                                                                                    const chats = parseChats(result.groups);
                                                                                    dispatch(receiveChats(attributes, chats));
                                                                                };
                                                                                const onError = () => {
                                                                                    dispatch(errorChats());
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async requestChatsHistoryLog(chatId: string, chatIndex: number) {
                                                                                const dispatch = this.store.dispatch;

                                                                                const getResult = async () => {
                                                                                    // TODO ручка есть но проверить ее работу невозможно
                                                                                    return await `mail-group/history?id=${chatId}`;
                                                                                };
                                                                                const onRequest = () => {
                                                                                    dispatch(requestHistoryLogs(chatIndex));
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    dispatch(receiveHistoryLogs(chatIndex, parseHistoryLogs(result)));
                                                                                };
                                                                                const onError = () => {
                                                                                    dispatch(errorHistoryLogs(chatIndex));
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            // На успех и на ошибку только изменение глобального состояния
                                                                            async requestAllUsersForMailGroups(handleRequest: () => void,
                                                                                                               handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                               handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/mail-groups/users`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    //TODO parse user
                                                                                    handleReceive(result.users.filter(({name, id}: ApiResponse) => Boolean(
                                                                                        name && id)));
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getAllQuestionnaires(handleRequest: () => void,
                                                                                                       handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                       handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get('questionnaires/');
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    //TODO parse user
                                                                                    handleReceive(result);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getAllUsersQuestionnaires(profileId: string,
                                                                                                            handleRequest: () => void,
                                                                                                            handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                            handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`questionnaires/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    handleReceive(parseForms(result.records.map(({id, schema, schemaContent}: ApiResponse) => ({
                                                                                                                 ...schema,
                                                                                                                 schemaContent,
                                                                                                                 id,
                                                                                                             })),
                                                                                                             FormMode.Fill));
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            // Эталон: На успех - меняем локальное состояние, на ошибку - тостер
                                                                            async submitQuestionnaire(formId: string,
                                                                                                      content: string,
                                                                                                      onSuccess: () => void) {
                                                                                const getResult = async () => {

                                                                                    return await this.get(`questionnaires/${formId}`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({schemaContent: content}),

                                                                                    });
                                                                                };
                                                                                const onReceive = () => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.submitQuestionnaire(formId, content, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка отправки формы. Повторите позднее';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            // Эталон: На успех - меняем внешнее состояние, на ошибку - тостер
                                                                            async saveChat(chatIndex: number,
                                                                                           chat: Chat,
                                                                                           logs: HistoryLog[],
                                                                                           onSuccess: () => void) {
                                                                                const state = this.store.getState();
                                                                                const userId = state.user.isAuthed ? state.user.userId : '';
                                                                                const dispatch = this.store.dispatch;
                                                                                const isCreation = !chat.id || chat.id === DEFAULT_CHAT_ID;
                                                                                const getResult = async () => {
                                                                                    if (!chat.name || !chat.users.length) {
                                                                                        throw new Error();
                                                                                    }
                                                                                    // TODO изменить когда пофиксим ручку
                                                                                    if (!isCreation) {
                                                                                        return ({
                                                                                            id: chat.id,
                                                                                            logs: logs,
                                                                                        });
                                                                                    }

                                                                                    const path = `formatted/mail-group/${isCreation ? '' : chat.id}`;
                                                                                    const randomId = getRandomId();
                                                                                    const randomIdForLog = getRandomId();
                                                                                    const hlogs = isCreation ? [{
                                                                                        id: randomIdForLog,
                                                                                        date: (new Date()).toISOString(),
                                                                                        message: 'Группа контактов создана',
                                                                                    }] : logs;
                                                                                    // TODO Макс попросить возвращать id и logs в какой-то момент
                                                                                    await this.get(path, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({
                                                                                                                 createdBy: userId,
                                                                                                                 logs: hlogs,
                                                                                                                 name: chat.name,
                                                                                                                 users: chat.users.map(({id}) => id),
                                                                                                             }),
                                                                                    });
                                                                                    return ({
                                                                                        id: isCreation ? randomId : chat.id,
                                                                                        logs: hlogs,
                                                                                    });
                                                                                };
                                                                                const onReceive = ({id, logs}: ApiResponse) => {
                                                                                    if (chatIndex > -1) {
                                                                                        dispatch(editChat(chatIndex, id));
                                                                                        dispatch(addHistoryLogs(chatIndex, parseHistoryLogs(logs)));
                                                                                    }

                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.saveChat(chatIndex, chat, logs, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка сохранения группы контактов.';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            // Эталон: Только тостеры, без состояний
                                                                            async sendForm(chatIndex: number,
                                                                                           chatId: string,
                                                                                           formId: string,
                                                                                           formName: string) {
                                                                                const dispatch = this.store.dispatch;
                                                                                const getResult = async () => {
                                                                                    const randomIdForLog = getRandomId();
                                                                                    const logs = [{
                                                                                        id: randomIdForLog,
                                                                                        date: (new Date()).toISOString(),
                                                                                        message: 'Отправлена форма ',
                                                                                        about: {
                                                                                            name: formName,
                                                                                            id: formId,
                                                                                            type: 'form',
                                                                                        },
                                                                                    }];
                                                                                    await this.get(`questionnaires/`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({
                                                                                                                 schemaId: formId,
                                                                                                                 mailGroupId: chatId,
                                                                                                                 logs,
                                                                                                             }),
                                                                                    });
                                                                                    return await logs;
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    dispatch(addHistoryLogs(chatIndex, parseHistoryLogs(response)));
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.sendForm(chatIndex, chatId, formId, formName);
                                                                                };
                                                                                const errorMessage = 'Ошибка отправки формы.';
                                                                                const successMessage = 'Форма отправлена!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async getFormStats(formIndex: number,
                                                                                               formId: string,
                                                                                               filter?: Attribute[]) {
                                                                                const dispatch = this.store.dispatch;
                                                                                const params = filter ? formSearchUrl(filter) : '';

                                                                                const getResult = async () => {
                                                                                    return await this.get(`search/questionnaires/${formId}${params}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    dispatch(requestFormStats(formIndex));
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    // TODO Макс не спамить лишним
                                                                                    dispatch(successFormStats(formIndex,
                                                                                                              result.records.map(({schemaContent, ...rest}: ApiResponse) => ({
                                                                                                                  ...rest,
                                                                                                                  content: schemaContent ? JSON.parse(
                                                                                                                      schemaContent) : {},
                                                                                                              }))));
                                                                                };
                                                                                const onError = () => {
                                                                                    dispatch(errorFormStats(formIndex));
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            // Эталон: На всё - меняем локальное состояние
                                                                            async getAllStudentsProjects(profileId: string,
                                                                                                         handleRequest: () => void,
                                                                                                         handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                         handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/projects/student/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({projectNameRus}: ApiResponse) => ({
                                                                                        name: projectNameRus.name,
                                                                                        link: `/${ProfileType.Project}/${projectNameRus.id}`,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getAllStudentsProjectApplications(profileId: string,
                                                                                                                    handleRequest: () => void,
                                                                                                                    handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                                    handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/student/applied/projects/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({projectNameRus}: ApiResponse) => ({
                                                                                        name: projectNameRus.name,
                                                                                        link: `/${ProfileType.Project}/${projectNameRus.id}`,
                                                                                        status: ProjectApplicationStatus.Waiting,
                                                                                        applicationId: projectNameRus.id,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getAllUsersProjectRequests(profileId: string,
                                                                                                             handleRequest: () => void,
                                                                                                             handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                             handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/project_requests/mentor/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({projectNameRus, status, id}: ApiResponse) => ({
                                                                                        name: projectNameRus,
                                                                                        link: `/${ProfileType.ProjectRequest}/${id}`,
                                                                                        status,
                                                                                        applicationId: id,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getAllUsersProjects(profileId: string,
                                                                                                      handleRequest: () => void,
                                                                                                      handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                      handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/projects/mentor/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({projectNameRus, id}: ApiResponse) => ({
                                                                                        name: projectNameRus.name,
                                                                                        link: `/${ProfileType.Project}/${id}`,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getAllUsersActivities(profileId: string,
                                                                                                        handleRequest: () => void,
                                                                                                        handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                        handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/activities/student/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({name}: ApiResponse) => ({
                                                                                        name: name.name,
                                                                                        link: `/${ProfileType.Activity}/${name.id}`,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getAllProjectsApplications(profileId: string,
                                                                                                             handleRequest: () => void,
                                                                                                             handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                             handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/project/applied/students/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({name, id}: ApiResponse) => ({
                                                                                        name: name.name,
                                                                                        link: `/${ProfileType.User}/${id}`,
                                                                                        projectId: profileId,
                                                                                        studentId: id,
                                                                                        status: ProjectApplicationStatus.Waiting,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getAllProjectsStudents(profileId: string,
                                                                                                         handleRequest: () => void,
                                                                                                         handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                         handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/project/students/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({name}: ApiResponse) => ({
                                                                                        name: name.name,
                                                                                        link: `/${ProfileType.Project}/${name.id}`,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getAllActivitiesProjects(profileId: string,
                                                                                                           handleRequest: () => void,
                                                                                                           handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                           handleError: () => void) {
                                                                                const user = this.store.getState().user;
                                                                                const {userId: id} = user.isAuthed ? user : {userId: ''};
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/projects/activity/${profileId}?userId=${id}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({projectNameRus, id, isApplied}: ApiResponse) => ({
                                                                                        name: projectNameRus.name,
                                                                                        link: `/${ProfileType.Project}/${id}`,
                                                                                        isRequested: isApplied,
                                                                                        projectId: id,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async changeProjectApplicationStatus(projectId: string,
                                                                                                                 studentId: string,
                                                                                                                 status: ProjectApplicationStatus,
                                                                                                                 onSuccess: () => void) {
                                                                                const getResult = async () => {
                                                                                    switch (status) {
                                                                                        case ProjectApplicationStatus.Waiting: {
                                                                                            return;
                                                                                        }
                                                                                        case ProjectApplicationStatus.Rejected: {
                                                                                            return await this.get(`formatted/student/applied/projects/decline`,
                                                                                                                  {
                                                                                                                      method: 'POST',
                                                                                                                      body: JSON.stringify({
                                                                                                                                               projectId,
                                                                                                                                               studentId,
                                                                                                                                           }),
                                                                                                                  });
                                                                                        }
                                                                                        case ProjectApplicationStatus.Accepted: {
                                                                                            return await this.get(`formatted/student/applied/projects/accept`,
                                                                                                                  {
                                                                                                                      method: 'POST',
                                                                                                                      body: JSON.stringify({
                                                                                                                                               projectId,
                                                                                                                                               studentId,
                                                                                                                                           }),
                                                                                                                  });
                                                                                        }
                                                                                    }
                                                                                };
                                                                                const onReceive = () => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.changeProjectApplicationStatus(projectId,
                                                                                                                        studentId,
                                                                                                                        status,
                                                                                                                        onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка изменения статуса заявки. Повторите позднее';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            // Отмена заявки на проект студентом.
                                                                            async cancelProjectApplication(userId: string,
                                                                                                           applicationOrRequestId: string,
                                                                                                           handleReceive: () => void) {
                                                                                const user = this.store.getState().user;
                                                                                const {userId: id} = user.isAuthed ? user : {userId: ''};
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/student/applied/projects/cancel`,
                                                                                                          {
                                                                                                              method: 'POST',
                                                                                                              body: JSON.stringify({
                                                                                                                                       studentId: id,
                                                                                                                                       projectId: applicationOrRequestId,
                                                                                                                                   }),
                                                                                                          });
                                                                                };
                                                                                const onReceive = () => {
                                                                                    handleReceive();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.cancelProjectApplication(userId,
                                                                                                                  applicationOrRequestId,
                                                                                                                  handleReceive);
                                                                                };
                                                                                const errorMessage = 'Ошибка отмены заявки.';
                                                                                const successMessage = 'Заявка отменена!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async reapplyForProjectApplication(userId: string,
                                                                                                               applicationOrRequestId: string,
                                                                                                               handleReceive: () => void) {
                                                                                const user = this.store.getState().user;
                                                                                const {userId: id} = user.isAuthed ? user : {userId: ''};
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/student/applied/projects`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({
                                                                                                                 studentId: id,
                                                                                                                 projectId: applicationOrRequestId,
                                                                                                             }),
                                                                                    });
                                                                                };
                                                                                const onReceive = () => {
                                                                                    handleReceive();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.reapplyForProjectApplication(userId,
                                                                                                                      applicationOrRequestId,
                                                                                                                      handleReceive);
                                                                                };
                                                                                const errorMessage = 'Ошибка подачи заявки.';
                                                                                const successMessage = 'Заявка успешно подана!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async cancelProjectRequest(projectRequestId: string,
                                                                                                       handleReceive: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`formatted/project_request/cancel/${projectRequestId}`,
                                                                                                          {
                                                                                                              method: 'POST',
                                                                                                          });
                                                                                };
                                                                                const onReceive = () => {
                                                                                    handleReceive();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.cancelProjectRequest(projectRequestId, handleReceive);
                                                                                };
                                                                                const errorMessage = 'Ошибка отмены заявки.';
                                                                                const successMessage = 'Заявка отменена!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async recreateProjectRequest(projectRequestId: string,
                                                                                                         handleReceive: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO: прицепить ручку как появится
                                                                                    return [];
                                                                                };
                                                                                const onReceive = () => {
                                                                                    handleReceive();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.recreateProjectRequest(projectRequestId, handleReceive);
                                                                                };
                                                                                const errorMessage = 'Ошибка подачи заявки.';
                                                                                const successMessage = 'Заявка успешно подана!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async addProjectRequestComment(projectId: string,
                                                                                                           intent: Intent,
                                                                                                           onSuccess: () => void) {
                                                                                const getResult = async () => {

                                                                                    switch (intent) {
                                                                                        case Intent.PRIMARY:
                                                                                        case Intent.SUCCESS: {
                                                                                            // утвердить проект
                                                                                            return await this.get(`formatted/project_request/accept/${projectId}`,
                                                                                                                  {
                                                                                                                      method: 'POST',

                                                                                                                  });
                                                                                        }
                                                                                        case Intent.DANGER:
                                                                                        case Intent.WARNING: {
                                                                                            // отклонить проект
                                                                                            return await this.get(`formatted/project_request/reject/${projectId}`,
                                                                                                                  {
                                                                                                                      method: 'POST',

                                                                                                                  });
                                                                                        }
                                                                                        default: {
                                                                                            throw new Error('Unknown request type!');
                                                                                        }
                                                                                    }
                                                                                };
                                                                                const onReceive = () => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.addProjectRequestComment(projectId, intent, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка изменения статуса заявки!';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            async blockProfile(profileId: string | undefined,
                                                                                               profileType: ProfileType | undefined,
                                                                                               onSuccess: () => void) {
                                                                                const getResult = async () => {
                                                                                    if (!profileId || !profileType) {
                                                                                        throw Error();
                                                                                    }
                                                                                    // TODO нужна ручка
                                                                                    return [];
                                                                                    return await this.get(`block/${profileType}`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({profileId}),
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.blockProfile(profileId, profileType, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка блокировки.';
                                                                                const successMessage = 'Блокировка прошла успешно!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async unblockProfile(profileId: string | undefined,
                                                                                                 profileType: ProfileType | undefined,
                                                                                                 onSuccess: () => void) {
                                                                                const getResult = async () => {
                                                                                    if (!profileId || !profileType) {
                                                                                        throw Error();
                                                                                    }
                                                                                    // TODO нужна ручка
                                                                                    return [];
                                                                                    return await this.get(`blocked/${profileType}`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({profileId}),
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.unblockProfile(profileId, profileType, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка разблокировки.';
                                                                                const successMessage = 'Разблокировка прошла успешно!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async complaintProfile(profileId: string | undefined,
                                                                                                   profileType: ProfileType | undefined) {
                                                                                const getResult = async () => {
                                                                                    if (!profileId || !profileType) {
                                                                                        throw Error();
                                                                                    }
                                                                                    // TODO нужна ручка
                                                                                    return [];
                                                                                    return await this.get(`blocked/${profileType}`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({profileId}),
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.complaintProfile(profileId, profileType);
                                                                                };
                                                                                const errorMessage = 'Жалоба не отправлена.';
                                                                                const successMessage = 'Жалоба отправлена!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async getOrganisationMembers(profileId: string,
                                                                                                         handleRequest: () => void,
                                                                                                         handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                         handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return organisationMembers;
                                                                                    return await this.get(`formatted/activities/student/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    handleReceive(result.map(({id, name, type}: ApiResponse) => ({
                                                                                        name,
                                                                                        link: `/${type}/${id}`,
                                                                                    })));
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getOrganisationStructure(profileId: string,
                                                                                                           handleRequest: () => void,
                                                                                                           handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                           handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return organisationStructure;
                                                                                    return await this.get(`formatted/activities/student/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    handleReceive([{
                                                                                        items: result.map(({id, name, type, hasChildren}: ApiResponse) => ({
                                                                                            id,
                                                                                            label: <Link to = {`/${type}/${id}`,
                                                                                        } className = 'profile-lists__link' > {name} < /Link>,
                                                                                        hasCaret: hasChildren,
                                                                                    });
                                                                                ),
                                                                                }])
                                                                                    ;
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async deleteComment(commentId: string, onSuccess: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`post/delete?postId=${commentId}`, {
                                                                                        method: 'POST',
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.deleteComment(commentId, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка удаления поста.';
                                                                                const successMessage = 'Пост удален!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async editComment(commentId: string,
                                                                                              newComment: ProfileOrSearchItem,
                                                                                              onSuccess: () => void) {
                                                                                const getResult = async () => {
                                                                                    const req: ProfileOrSearchItem = {};
                                                                                    if (newComment.text) {
                                                                                        req.text = newComment.text;
                                                                                    }
                                                                                    if (newComment.file && newComment.file.id) {
                                                                                        req.file = newComment.file.id;
                                                                                    }
                                                                                    return await this.get(`post/update?postId=${commentId}`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify(req),
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.editComment(commentId, newComment, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка редактирования поста.';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            async startNewAcademicYear(onSuccess: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return [];
                                                                                    return await this.get(`blocked/`, {
                                                                                        method: 'POST',
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.startNewAcademicYear(onSuccess);
                                                                                };
                                                                                const errorMessage = 'Попытка начать новый учебный год завершилась с ошибкой.';
                                                                                const successMessage = 'Учебный год начат!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async getLastAcademicYearStartDate(handleRequest: () => void,
                                                                                                               handleReceive: (result: number) => void,
                                                                                                               handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return {date: 0};
                                                                                    return await this.get(``);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = ({date}: ApiResponse) => {
                                                                                    handleReceive(date);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getStudentGroupsList(handleRequest: () => void,
                                                                                                       handleReceive: (result: string[]) => void,
                                                                                                       handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return {
                                                                                        groups: ['БПИ162',
                                                                                                 'БПИ161',
                                                                                                 'БПИ171',
                                                                                                 'БПИ181',
                                                                                                 'БПИ191',
                                                                                                 'БПМИ161',
                                                                                                 'БПМИ171',
                                                                                                 'БПМИ181',
                                                                                                 'БПМИ191'],
                                                                                    };
                                                                                    return await this.get(``);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = ({groups}: ApiResponse) => {
                                                                                    handleReceive(groups);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async setNewStudentGroupsList(newList: string[], onSuccess: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return [];
                                                                                    return await this.get(`blocked/`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({newList}),
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.setNewStudentGroupsList(newList, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка сохранения нового списка групп.';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            async actualizeContacts(onSuccess: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return [];
                                                                                    return await this.get(`blocked/`, {
                                                                                        method: 'POST',
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.actualizeContacts(onSuccess);
                                                                                };
                                                                                const errorMessage = 'Попытка актуализировать контакты завершилась с ошибкой.';
                                                                                const successMessage = 'Запрос на актуализацию контактов отправлен!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async getLastContactsActualisationDate(handleRequest: () => void,
                                                                                                                   handleReceive: (result: number) => void,
                                                                                                                   handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return {date: 0};
                                                                                    return await this.get(``);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = ({date}: ApiResponse) => {
                                                                                    handleReceive(date);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async addToArchive(index: number, form: Form) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return [];
                                                                                    return await this.get(`blocked/`, {
                                                                                        method: 'POST',
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    this.store.dispatch(addArchiveForm(index, form));
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.addToArchive(index, form);
                                                                                };
                                                                                const errorMessage = 'Не удалось архивировать форму.';
                                                                                const successMessage = 'Форма архивирована!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async deleteFromArchive(index: number, form: Form) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return [];
                                                                                    return await this.get(`blocked/`, {
                                                                                        method: 'POST',
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    this.store.dispatch(removeArchiveForm(index, form));
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.deleteFromArchive(index, form);
                                                                                };
                                                                                const errorMessage = 'Не удалось разархивировать форму.';
                                                                                const successMessage = 'Форма разархивирована!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async setNotificationSeen(notificationId: string, onSuccess: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return [];
                                                                                    return await this.get(`blocked/`, {
                                                                                        method: 'POST',
                                                                                    });
                                                                                };
                                                                                const onReceive = (response: ApiResponse) => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.setNotificationSeen(notificationId, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Не удалось пометить нотификацию как просмотренную.';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            async getAllNotifications(handleRequest: () => void,
                                                                                                      handleReceive: (result: ApiResponse[]) => void,
                                                                                                      handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    // TODO нужна ручка
                                                                                    return notificationsList;
                                                                                    return await this.get(``);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (notifications: ApiResponse[]) => {
                                                                                    handleReceive(notifications);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            // На успех - глобальный стейт + тостер, На ошибку - тостер
                                                                            async deleteChat(chatIndex: number, chatId: string) {
                                                                                const dispatch = this.store.dispatch;
                                                                                const getResult = async () => {
                                                                                    return {};
                                                                                    // TODO нуна ручка!!
                                                                                    return await this.get(`delete/${chatId}`);
                                                                                };
                                                                                const onReceive = () => {
                                                                                    dispatch(deleteChat(chatIndex));
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.deleteChat(chatIndex, chatId);
                                                                                };
                                                                                const successMessage = 'Группа контактов удалена!';
                                                                                const errorMessage = 'Не удалось удалить группу контактов';
                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async getAllStudentMentors(profileId: string,
                                                                                                       handleRequest: () => void,
                                                                                                       handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                       handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return [];
                                                                                    // TODO нуна ручка!!
                                                                                    return await this.get(`formatted/projects/mentor/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({name, id}: ApiResponse) => ({
                                                                                        name,
                                                                                        link: `/${ProfileType.User}/${id}`,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getAllMentorMenties(profileId: string,
                                                                                                      handleRequest: () => void,
                                                                                                      handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                                      handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return [];
                                                                                    // TODO нуна ручка!!
                                                                                    return await this.get(`formatted/projects/mentor/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({name, id}: ApiResponse) => ({
                                                                                        name,
                                                                                        link: `/${ProfileType.User}/${id}`,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            // Эталон: На успех - меняем локальное и глобальное состояние и показываем тостер, на ошибку - тостер
                                                                            async sendNotification(mailGroupId: string,
                                                                                                   mailGroupIndex: number,
                                                                                                   text: string,
                                                                                                   onSuccess: () => void) {
                                                                                const dispatch = this.store.dispatch;
                                                                                const getResult = async () => {
                                                                                    const logs = [{
                                                                                        id: getRandomId(),
                                                                                        date: (new Date()).toISOString(),
                                                                                        message: `Отправлена нотификация: ${text}`,
                                                                                    }];
                                                                                    return logs;
                                                                                    // TODO ручка ручка ручка
                                                                                    return await this.get(`???/${mailGroupId}`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({text, logs}),

                                                                                    });
                                                                                };
                                                                                const onReceive = (logs: ApiResponse) => {
                                                                                    onSuccess();
                                                                                    dispatch(addHistoryLogs(mailGroupIndex, parseHistoryLogs(logs)));
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.sendNotification(mailGroupId,
                                                                                                          mailGroupIndex,
                                                                                                          text,
                                                                                                          onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка отправки нотификации. Повторите позднее';
                                                                                const successMessage = 'Нотификация отправлена';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async addPost(profileId: string,
                                                                                          message: UserAction,
                                                                                          text: string,
                                                                                          file: { id: string, name: string, type: 'file' } | null,
                                                                                          onSuccess: (id: string) => void) {
                                                                                const state = this.store.getState();
                                                                                const getResult = async () => {
                                                                                    return await this.get(`post/create?profileId=${profileId}`, {
                                                                                        method: 'POST',
                                                                                        // @ts-ignore
                                                                                        body: JSON.stringify({
                                                                                                                 name: state.user.userId,
                                                                                                                 text,
                                                                                                                 file: file && file.id,
                                                                                                                 message,
                                                                                                             }),
                                                                                    });
                                                                                };
                                                                                const onReceive = ({id}: ApiResponse) => {
                                                                                    onSuccess(id);
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.addPost(profileId, message, text, file, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка отправки комментария.';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }

                                                                            async getAllPosts(profileId: string,
                                                                                              handleRequest: () => void,
                                                                                              handleReceive: (result: ProfileOrSearchItem[]) => void,
                                                                                              handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`posts/get?profileId=${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const res = result.map(({id, message, text, name, file}: ApiResponse) => ({
                                                                                        id,
                                                                                        file,
                                                                                        text,
                                                                                        userAction: message,
                                                                                        userName: name.name,
                                                                                        userLink: `/user/${name.id}`,
                                                                                    }));
                                                                                    handleReceive(res);
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getActivityVedomost(profileId: string,
                                                                                                      handleRequest: () => void,
                                                                                                      handleReceive: (result: ProfileOrSearchItem) => void,
                                                                                                      handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`sheet/activity/${profileId}`, {
                                                                                        method: 'GET',
                                                                                    });
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const fields = parseFields(result.fields.map(({name, title}: { name: string, title: string },
                                                                                                                                  index: number) => ({
                                                                                        name, title, attribute: {
                                                                                            id: String(index),
                                                                                            usage: 'short_text',
                                                                                            name,
                                                                                            description: '',
                                                                                            title,
                                                                                            placeholder: '',
                                                                                            hint: '',
                                                                                            mandatory: true,
                                                                                            validators: [],
                                                                                        },
                                                                                    })));
                                                                                    // const parsedForm = parseForm(result.schema, FormMode.View);
                                                                                    if (!fields.length) {
                                                                                        handleError();
                                                                                    } else {
                                                                                        handleReceive({records: result.records, fields});
                                                                                    }
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async getProjectVedomost(profileId: string,
                                                                                                     handleRequest: () => void,
                                                                                                     handleReceive: (result: ProfileOrSearchItem) => void,
                                                                                                     handleError: () => void) {
                                                                                const getResult = async () => {
                                                                                    return await this.get(`sheet/project/${profileId}`);
                                                                                };
                                                                                const onRequest = () => {
                                                                                    handleRequest();
                                                                                };
                                                                                const onReceive = (result: ApiResponse) => {
                                                                                    const fields = parseFields(result.fields.map(({name, title, isModifyAllowed}: { name: string, title: string, isModifyAllowed: boolean },
                                                                                                                                  index: number) => ({
                                                                                        name,
                                                                                        title,
                                                                                        modifyAllowed: isModifyAllowed,
                                                                                        attribute: {
                                                                                            id: String(index),
                                                                                            usage: 'short_text',
                                                                                            name,
                                                                                            description: '',
                                                                                            title,
                                                                                            placeholder: '',
                                                                                            hint: '',
                                                                                            mandatory: true,
                                                                                            validators: [],
                                                                                        },
                                                                                    })));
                                                                                    if (!fields.length) {
                                                                                        handleError();
                                                                                    } else {
                                                                                        handleReceive({records: result.records, fields});
                                                                                    }
                                                                                };
                                                                                const onError = () => {
                                                                                    handleError();
                                                                                };

                                                                                this.makeRequest({getResult, onRequest, onReceive, onError});
                                                                            }

                                                                            async changeMark(mark: string,
                                                                                             projectId: string,
                                                                                             studentId: string,
                                                                                             stageId: string,
                                                                                             gradeType: string,
                                                                                             onSuccess: (mark: string) => void) {
                                                                                const getResult = async () => {
                                                                                    const grade = mark === '' ? null : parseInt(mark);
                                                                                    if (grade !== null && (grade > 10 || grade < 0)) {
                                                                                        throw new Error();
                                                                                    }
                                                                                    if (!grade && grade !== null && grade !== 0) {
                                                                                        throw new Error();
                                                                                    }

                                                                                    await this.get(`sheet/project/update?projectId=${projectId}&studentId=${studentId}&stageId=${stageId}&gradeType=${gradeType}&grade=${mark}`,
                                                                                                   {
                                                                                                       method: 'POST',
                                                                                                   });
                                                                                    return grade;
                                                                                };
                                                                                const onReceive = (grade: ApiResponse) => {
                                                                                    onSuccess(grade === null ? '' : String(grade));
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.changeMark(mark,
                                                                                                    projectId,
                                                                                                    studentId,
                                                                                                    stageId,
                                                                                                    gradeType,
                                                                                                    onSuccess);
                                                                                };
                                                                                const errorMessage = 'Ошибка задания оценки.';
                                                                                const successMessage = 'Оценка выствлена!';

                                                                                this.makeRequest({
                                                                                                     getResult,
                                                                                                     onReceive,
                                                                                                     onRetry,
                                                                                                     errorMessage,
                                                                                                     successMessage,
                                                                                                 });
                                                                            }

                                                                            async addStudentToActivity(studentId: string,
                                                                                                       activityName: string,
                                                                                                       onSuccess: () => void) {
                                                                                const getResult = async () => {

                                                                                    return {};
                                                                                    return await this.get(`questionnaires/${studentId}`, {
                                                                                        method: 'POST',
                                                                                        body: JSON.stringify({activityName}),

                                                                                    });
                                                                                };
                                                                                const onReceive = () => {
                                                                                    onSuccess();
                                                                                };
                                                                                const onRetry = () => {
                                                                                    this.addStudentToActivity(studentId, activityName, onSuccess);
                                                                                };
                                                                                const errorMessage = 'Не удалось добавить студента к активности';

                                                                                this.makeRequest({getResult, onReceive, onRetry, errorMessage});
                                                                            }
                                                                        }

                                                                        src / react - app - env.d.ts;
                                                                        /// <reference types="node" />
                                                                        /// <reference types="react" />
                                                                        /// <reference types="react-dom" />

                                                                        declare namespace NodeJS {
                                                                            interface ProcessEnv {
                                                                                readonly NODE_ENV: 'development' | 'production' | 'test';
                                                                                readonly PUBLIC_URL: string;
                                                                            }
                                                                        }

                                                                        declare module '*.bmp' {
                                                                            const src: string;
                                                                            export default src;
                                                                        }

                                                                        declare module '*.gif' {
                                                                            const src: string;
                                                                            export default src;
                                                                        }

                                                                        declare module '*.jpg' {
                                                                            const src: string;
                                                                            export default src;
                                                                        }

                                                                        declare module '*.jpeg' {
                                                                            const src: string;
                                                                            export default src;
                                                                        }

                                                                        declare module '*.png' {
                                                                            const src: string;
                                                                            export default src;
                                                                        }

                                                                        declare module '*.webp' {
                                                                            const src: string;
                                                                            export default src;
                                                                        }

                                                                        declare module '*.svg' {
                                                                            import * as React from 'react';

                                                                            export const ReactComponent: React.FunctionComponent<React.SVGProps<SVGSVGElement>>;

                                                                            const src: string;
                                                                            export default src;
                                                                        }

                                                                        declare module '*.module.css' {
                                                                            const classes: { readonly [key: string]: string };
                                                                            export default classes;
                                                                        }

                                                                        declare module '*.module.scss' {
                                                                            const classes: { readonly [key: string]: string };
                                                                            export default classes;
                                                                        }

                                                                        declare module '*.module.sass' {
                                                                            const classes: { readonly [key: string]: string };
                                                                            export default classes;
                                                                        }
                                                                        src / types.tsx;
                                                                        import {Toaster} from '@blueprintjs/core';

                                                                        export type AttributeRef =
                                                                            (HTMLTextAreaElement | null)
                                                                            | (HTMLInputElement | null);

                                                                        export type Validator = {
                                                                            message: string;
                                                                            regexp: string;
                                                                        }

                                                                        export enum FormType {
                                                                            Initial = '',

                                                                            StudentRegistration = 'student_registration',
                                                                            StudentProfile = 'student_profile',
                                                                            StudentProfileTemplate = 'student_profile_template',

                                                                            UserRegistration = 'user_registration',
                                                                            UserProfile = 'user_profile',
                                                                            UserProfileTemplate = 'user_profile_template',

                                                                            OrgProfile = 'org_profile',
                                                                            // Не используем
                                                                            OrgProfileTemplate = 'org_profile_template',

                                                                            ProjectRequest = 'project_request',
                                                                            Project = 'project',
                                                                            Activity = 'activity',

                                                                            Questionnaire = 'questionnaire',
                                                                            Help = 'help',

                                                                            AttributeCreator = 'attribute-creator',
                                                                        }

                                                                        export enum Usage {
                                                                            Password = 'password',
                                                                            Email = 'email',
                                                                            ShortText = 'short_text',
                                                                            Number = 'number',
                                                                            LongText = 'long_text',
                                                                            File = 'file',
                                                                            Checkbox = 'checkbox',
                                                                            Radio = 'radio',
                                                                            // Tel = 'tel',
                                                                            // Url = 'url',
                                                                            Date = 'date',
                                                                            // Time = 'time',
                                                                            Switch = 'switch',
                                                                            StudentGroup = 'student_group',
                                                                            Mentor = 'mentor',
                                                                            Activity = 'activity',
                                                                            Organisation = 'organisation',
                                                                            Student = 'student',
                                                                            Validator = 'validator',

                                                                            Stage = 'stage',
                                                                            Task = 'task',

                                                                            Variants = 'variants',
                                                                        }

                                                                        export type AttributeValue = any; // string | string[] | undefined | null | Task[] | Stage[] | Date | boolean | {name: string, id: string};

                                                                        export type Attribute = {
                                                                            id: string;
                                                                            name: string;
                                                                            usage: Usage;
                                                                            title: string;
                                                                            mandatory: boolean;
                                                                            validators: Validator[];
                                                                            realName?: string;
                                                                            defaultValue?: AttributeValue;
                                                                            description?: string;
                                                                            placeholder?: string;
                                                                            hint?: string;
                                                                            isPlaceholder?: boolean;
                                                                            min?: number;
                                                                            max?: number;
                                                                            variants?: string[];

                                                                            isAdded?: boolean;
                                                                            modifyAllowed?: boolean;
                                                                        }
                                                                        export type FormStats = {
                                                                            status: AsyncStatus;
                                                                            records: Content[];
                                                                        }
                                                                        export type Content = { [k: string]: any };
                                                                        export type Form = {
                                                                            id: string;
                                                                            type: FormType;
                                                                            title: string;
                                                                            attributes: Attribute[];
                                                                            mode: FormMode;
                                                                            description?: string;
                                                                            buttonName?: string;
                                                                            content?: Content;
                                                                            stats?: FormStats;
                                                                        }

                                                                        export enum UserRole {
                                                                            Supervisor = 'supervisor',
                                                                            Manager = 'manager',
                                                                            Student = 'student',
                                                                            Representative = 'representative',
                                                                            Mentor = 'mentor',

                                                                            Initial = '',
                                                                        }

                                                                        export enum ProfileStatus {
                                                                            Active = 'active',
                                                                            Inactive = 'inactive',
                                                                            Blocked = 'blocked',
                                                                        }

                                                                        export type UserData = {
                                                                            email: string;
                                                                            email_verified: boolean;
                                                                            exp: number;
                                                                            role: UserRole;
                                                                            userId: string;
                                                                        }

                                                                        /**
                                                                         * Статус запроса за данными
                                                                         */
                                                                        export enum AsyncStatus {
                                                                            Initial = 'initial',
                                                                            Pending = 'pending',
                                                                            Error = 'error',
                                                                            Success = 'success',
                                                                        }

                                                                        export type ToasterFromContext = { current: Toaster | null };

                                                                        export enum SearchType {
                                                                            Initial = '',
                                                                            Students = 'students',
                                                                            Mentors = 'mentors',
                                                                            Activities = 'activities',
                                                                            Projects = 'projects',
                                                                            Organisations = 'organisations',
                                                                            ProjectRequests = 'project_requests',

                                                                            Questionnaire = 'questionnaire',
                                                                        }

                                                                        export enum FormMode {
                                                                            View = 'view',
                                                                            Fill = 'fill',
                                                                            Edit = 'edit',
                                                                            Stats = 'stats',
                                                                        }

                                                                        export enum FormsList {
                                                                            Archive = 'archive',
                                                                            My = 'my',
                                                                        }

                                                                        export enum ProfileType {
                                                                            User = 'user',
                                                                            ProjectRequest = 'project_request',
                                                                            Activity = 'activity',
                                                                            Project = 'project',
                                                                            Organisation = 'organisation',
                                                                        }

                                                                        export type Task = {
                                                                            id: string;
                                                                            name: string;
                                                                            description: string;
                                                                            file?: null | {
                                                                                id: string;
                                                                                name: string;
                                                                                type: 'file';
                                                                            }
                                                                            isUploadable: boolean;
                                                                        }
                                                                        export type Stage = {
                                                                            stageNumber: number;
                                                                            id: string;
                                                                            name: string;
                                                                            description: string;
                                                                            startDate: Date;
                                                                            endDate: Date;
                                                                            hasForcedGrade: boolean;
                                                                            coefficient: number;
                                                                            tasks: Task[];
                                                                            grade?: null | {
                                                                                mentorGrade: string;
                                                                                managerGrade: string;
                                                                            }
                                                                        }

                                                                        export type ApiResponse = any;

                                                                        export type ProfileOrSearchItem = any;

                                                                        export type StateForm = Form & { errors?: string[]; };

                                                                        export type AttributesByUserRole = { [k in UserRole]: Attribute[] };

                                                                        export enum ProjectApplicationStatus {
                                                                            Accepted = 'accepted',
                                                                            Rejected = 'rejected',
                                                                            Waiting = 'waiting'
                                                                        }

                                                                        export enum ProjectRequestStatus {
                                                                            Accepted = 'approved',
                                                                            Rejected = 'rejected',
                                                                            Waiting = 'validating'
                                                                        }

                                                                        export enum UserAction {
                                                                            Comment = 'написал(а):',
                                                                            Approve = 'утвердил(а) заявку:',
                                                                            Reject = 'отклонил(а) заявку:',
                                                                        }

                                                                        type ProjectRequest = {
                                                                            id: string;
                                                                            buttonName: string;
                                                                            attributes: Attribute[],
                                                                            projectNameRus: string;
                                                                            projectNameEng: string;
                                                                            projectIndividuality: 'Индивидуальный' | 'Групповой';
                                                                            projectType: 'Технический' | 'Исследовательский';
                                                                            piCourses: number[];
                                                                            pmiCourses: number[];
                                                                            padCourses: number[];
                                                                            status: 'approved' | 'rejected' | 'validating',
                                                                        }

                                                                        type Student = {
                                                                            id: string;
                                                                            content: Content;
                                                                            name: string;
                                                                            role: 'student';
                                                                            course: number;
                                                                            faculty: Content;
                                                                            group: string;
                                                                            email: string;
                                                                            status: 'active' | 'inactive' | 'blocked'
                                                                        }

                                                                        type User = {
                                                                            id: string;
                                                                            content: Content;
                                                                            name: string;
                                                                            role: 'mentor' | 'supervisor' | 'manager' | 'representative';
                                                                            organisation: Content;
                                                                            email: string;
                                                                            status: 'active' | 'inactive' | 'blocked'
                                                                        }

                                                                        export type CppwNotification = {
                                                                            id: string;
                                                                            from: {
                                                                                id: string;
                                                                                name: string;
                                                                                type: string;
                                                                            };
                                                                            read?: boolean;
                                                                            message: string;
                                                                            about?: {
                                                                                id: string;
                                                                                name: string;
                                                                                type: string;
                                                                            };
                                                                        }

                                                                        type Post = {
                                                                            id: string;
                                                                            file: {
                                                                                id: string;
                                                                                name: string;
                                                                                type: 'file';
                                                                            };
                                                                            date: string;
                                                                            text: string;
                                                                        }
                                                                        src / store / actions / search.actions.tsx;
                                                                        import {Attribute, Form, ProfileOrSearchItem, SearchType} from 'src/types';

                                                                        export const RECEIVE_SEARCH = 'RECEIVE_SEARCH' as const;
                                                                        export const REQUEST_SEARCH = 'REQUEST_SEARCH' as const;
                                                                        export const ERROR_SEARCH = 'ERROR_SEARCH' as const;

                                                                        export const RECEIVE_FULL_SEARCH = 'RECEIVE_FULL_SEARCH' as const;
                                                                        export const REQUEST_FULL_SEARCH = 'REQUEST_FULL_SEARCH' as const;
                                                                        export const ERROR_FULL_SEARCH = 'ERROR_FULL_SEARCH' as const;

                                                                        export const SELECT_SEARCH_TYPE = 'SELECT_SEARCH_TYPE' as const;
                                                                        export const SET_FILTER = 'SET_FILTER' as const;

                                                                        export const receiveSearch = (results: { records: ProfileOrSearchItem[] }) => (
                                                                            {
                                                                                type: RECEIVE_SEARCH,
                                                                                payload: results,
                                                                            }
                                                                        );
                                                                        export const requestSearch = () => (
                                                                            {
                                                                                type: REQUEST_SEARCH,
                                                                            }
                                                                        );
                                                                        export const errorSearch = () => (
                                                                            {
                                                                                type: ERROR_SEARCH,
                                                                            }
                                                                        );

                                                                        export const receiveFullSearch = (results: { records: {}[]; schema: Form }) => (
                                                                            {
                                                                                type: RECEIVE_FULL_SEARCH,
                                                                                payload: results,
                                                                            }
                                                                        );
                                                                        export const requestFullSearch = () => (
                                                                            {
                                                                                type: REQUEST_FULL_SEARCH,
                                                                            }
                                                                        );
                                                                        export const errorFullSearch = () => (
                                                                            {
                                                                                type: ERROR_FULL_SEARCH,
                                                                            }
                                                                        );

                                                                        export const selectSearchType = (type: SearchType) => (
                                                                            {
                                                                                type: SELECT_SEARCH_TYPE,
                                                                                payload: type,
                                                                            }
                                                                        );
                                                                        export const setFilter = (filter: Attribute[]) => (
                                                                            {
                                                                                type: SET_FILTER,
                                                                                payload: filter,
                                                                            }
                                                                        );
                                                                        src / store / actions / user - forms.actions.tsx;
                                                                        import {Attribute, Content, Form, FormMode} from 'src/types';

                                                                        export const REQUEST_USER_FORMS = 'REQUEST_USER_FORMS' as const;
                                                                        export const SUCCESS_USER_FORMS = 'SUCCESS_USER_FORMS' as const;
                                                                        export const ERROR_USER_FORMS = 'ERROR_USER_FORMS' as const;
                                                                        export const ADD_NEW_USER_FORM = 'ADD_NEW_USER_FORM' as const;
                                                                        export const DELETE_NEW_USER_FORM = 'DELETE_NEW_USER_FORM' as const;
                                                                        export const ERROR_USER_FORM = 'ERROR_USER_FORM' as const;
                                                                        export const CHANGE_USER_FORM_MODE = 'CHANGE_USER_FORM_MODE' as const;

                                                                        export const EDIT_USER_FORM = 'EDIT_USER_FORM' as const;

                                                                        export const SET_DRAFT_FORM_TITLE = 'SET_DRAFT_FORM_TITLE' as const;
                                                                        export const SET_DRAFT_FORM_DESCRIPTION = 'SET_DRAFT_FORM_DESCRIPTION' as const;
                                                                        export const SET_DRAFT_FORM_BUTTON_NAME = 'SET_DRAFT_FORM_BUTTON_NAME' as const;
                                                                        export const ADD_DRAFT_FORM_ATTRIBUTES = 'ADD_DRAFT_FORM_ATTRIBUTES' as const;
                                                                        export const DELETE_DRAFT_FORM_ATTRIBUTE = 'DELETE_DRAFT_FORM_ATTRIBUTE' as const;
                                                                        export const ADD_DRAFT_FORM_ATTRIBUTE_PROPERTIES = 'ADD_DRAFT_FORM_ATTRIBUTE_PROPERTIES' as const;

                                                                        export const REQUEST_FORM_STATS = 'REQUEST_FORM_STATS' as const;
                                                                        export const SUCCESS_FORM_STATS = 'SUCCESS_FORM_STATS' as const;
                                                                        export const ERROR_FORM_STATS = 'ERROR_FORM_STATS' as const;

                                                                        export const requestUserForms = () => (
                                                                            {
                                                                                type: REQUEST_USER_FORMS,
                                                                            }
                                                                        );
                                                                        export const errorUserForms = () => (
                                                                            {
                                                                                type: ERROR_USER_FORMS,
                                                                            }
                                                                        );
                                                                        export const successUserForms = (forms: Form[]) => (
                                                                            {
                                                                                type: SUCCESS_USER_FORMS,
                                                                                payload: forms,
                                                                            }
                                                                        );
                                                                        export const addNewUserForm = (form: Form) => (
                                                                            {
                                                                                type: ADD_NEW_USER_FORM,
                                                                                payload: form,
                                                                            }
                                                                        );
                                                                        export const deleteNewUserForm = (formIndex: number) => (
                                                                            {
                                                                                type: DELETE_NEW_USER_FORM,
                                                                                payload: formIndex,
                                                                            }
                                                                        );
                                                                        export const editUserForm = (formIndex: number, form: Partial<Form>) => (
                                                                            {
                                                                                type: EDIT_USER_FORM,
                                                                                payload: {form, formIndex},
                                                                            }
                                                                        );
                                                                        export const errorUserForm = (formIndex: number, errors: string[]) => (
                                                                            {
                                                                                type: ERROR_USER_FORM,
                                                                                payload: {formIndex, errors},
                                                                            }
                                                                        );
                                                                        export const changeUserFormMode = (formIndex: number, mode: FormMode) => (
                                                                            {
                                                                                type: CHANGE_USER_FORM_MODE,
                                                                                payload: {formIndex, mode},
                                                                            }
                                                                        );
                                                                        export const setDraftFormTitle = (formIndex: number, title: string) => (
                                                                            {
                                                                                type: SET_DRAFT_FORM_TITLE,
                                                                                payload: {formIndex, title},
                                                                            }
                                                                        );
                                                                        export const setDraftFormDescription = (formIndex: number,
                                                                                                                description: string) => (
                                                                            {
                                                                                type: SET_DRAFT_FORM_DESCRIPTION,
                                                                                payload: {formIndex, description},
                                                                            }
                                                                        );
                                                                        export const setDraftFormButtonName = (formIndex: number,
                                                                                                               buttonName: string) => (
                                                                            {
                                                                                type: SET_DRAFT_FORM_BUTTON_NAME,
                                                                                payload: {formIndex, buttonName},
                                                                            }
                                                                        );
                                                                        export const addDraftFormAttributes = (formIndex: number,
                                                                                                               attributes: Attribute[]) => (
                                                                            {
                                                                                type: ADD_DRAFT_FORM_ATTRIBUTES,
                                                                                payload: {formIndex, attributes},
                                                                            }
                                                                        );
                                                                        export const deleteDraftFormAttribute = (formIndex: number,
                                                                                                                 attributeIndex: number) => (
                                                                            {
                                                                                type: DELETE_DRAFT_FORM_ATTRIBUTE,
                                                                                payload: {formIndex, attributeIndex},
                                                                            }
                                                                        );
                                                                        export const addDraftFormAttributeProperties = (formIndex: number,
                                                                                                                        attributeIndex: number,
                                                                                                                        attribute: Partial<Attribute>) => (
                                                                            {
                                                                                type: ADD_DRAFT_FORM_ATTRIBUTE_PROPERTIES,
                                                                                payload: {formIndex, attributeIndex, attribute},
                                                                            }
                                                                        );

                                                                        export const requestFormStats = (formIndex: number) => (
                                                                            {
                                                                                type: REQUEST_FORM_STATS,
                                                                                payload: formIndex,
                                                                            }
                                                                        );
                                                                        export const errorFormStats = (formIndex: number) => (
                                                                            {
                                                                                type: ERROR_FORM_STATS,
                                                                                payload: formIndex,
                                                                            }
                                                                        );
                                                                        export const successFormStats = (formIndex: number, records: Content[]) => (
                                                                            {
                                                                                type: SUCCESS_FORM_STATS,
                                                                                payload: {formIndex, records},
                                                                            }
                                                                        );
                                                                        src / store / actions / user - archive - forms.actions.tsx;
                                                                        import {Form} from 'src/types';

                                                                        export const REQUEST_USER_ARCHIVE_FORMS = 'REQUEST_USER_ARCHIVE_FORMS' as const;
                                                                        export const SUCCESS_USER_ARCHIVE_FORMS = 'SUCCESS_USER_ARCHIVE_FORMS' as const;
                                                                        export const ERROR_USER_ARCHIVE_FORMS = 'ERROR_USER_ARCHIVE_FORMS' as const;
                                                                        export const ADD_NEW_USER_ARCHIVE_FORM = 'ADD_NEW_USER_ARCHIVE_FORM' as const;
                                                                        export const ERROR_USER_ARCHIVE_FORM = 'ERROR_USER_ARCHIVE_FORM' as const;
                                                                        export const ARCHIVE_ADD_FORM = 'ARCHIVE_ADD_FORM' as const;
                                                                        export const ARCHIVE_REMOVE_FORM = 'ARCHIVE_REMOVE_FORM' as const;

                                                                        export const requestUserArchiveForms = () => ({
                                                                            type: REQUEST_USER_ARCHIVE_FORMS,
                                                                        });
                                                                        export const errorUserArchiveForms = () => ({
                                                                            type: ERROR_USER_ARCHIVE_FORMS,
                                                                        });
                                                                        export const successUserArchiveForms = (forms: Form[]) => ({
                                                                            type: SUCCESS_USER_ARCHIVE_FORMS,
                                                                            payload: forms,
                                                                        });
                                                                        export const addArchiveForm = (formIndex: number, form: Form) => ({
                                                                            type: ARCHIVE_ADD_FORM,
                                                                            payload: {formIndex, form},
                                                                        });
                                                                        export const removeArchiveForm = (formIndex: number, form: Form) => ({
                                                                            type: ARCHIVE_REMOVE_FORM,
                                                                            payload: {formIndex, form},
                                                                        });
                                                                        export const errorArchiveForm = (formIndex: number, errors: string[]) => (
                                                                            {
                                                                                type: ERROR_USER_ARCHIVE_FORM,
                                                                                payload: {formIndex, errors},
                                                                            }
                                                                        );
                                                                        src / store / actions / action - type.tsx;
                                                                        import {
                                                                            addNewAttribute,
                                                                            editAttribute,
                                                                            errorAttributeByUsage,
                                                                            receiveAttributeByUsage,
                                                                            requestAttributeByUsage,
                                                                        } from 'src/store/actions/attributes.actions';
                                                                        import {
                                                                            addChat,
                                                                            addChatUser,
                                                                            addHistoryLogs,
                                                                            deleteChat,
                                                                            deleteChatUser,
                                                                            editChat,
                                                                            errorChats,
                                                                            errorHistoryLogs,
                                                                            receiveChats,
                                                                            receiveHistoryLogs,
                                                                            requestChats,
                                                                            requestHistoryLogs,
                                                                        } from 'src/store/actions/chats.actions';
                                                                        import {
                                                                            errorFormByType,
                                                                            receiveFormByType,
                                                                            requestFormByType,
                                                                        } from 'src/store/actions/default-forms.actions';
                                                                        import {
                                                                            errorFullSearch,
                                                                            errorSearch,
                                                                            receiveFullSearch,
                                                                            receiveSearch,
                                                                            requestFullSearch,
                                                                            requestSearch,
                                                                            selectSearchType,
                                                                            setFilter,
                                                                        } from 'src/store/actions/search.actions';
                                                                        import {
                                                                            addArchiveForm,
                                                                            errorArchiveForm,
                                                                            errorUserArchiveForms,
                                                                            removeArchiveForm,
                                                                            requestUserArchiveForms,
                                                                            successUserArchiveForms,
                                                                        } from 'src/store/actions/user-archive-forms.actions';
                                                                        import {
                                                                            addDraftFormAttributeProperties,
                                                                            addDraftFormAttributes,
                                                                            addNewUserForm,
                                                                            changeUserFormMode,
                                                                            deleteDraftFormAttribute,
                                                                            deleteNewUserForm,
                                                                            editUserForm,
                                                                            errorFormStats,
                                                                            errorUserForm,
                                                                            errorUserForms,
                                                                            requestFormStats,
                                                                            requestUserForms,
                                                                            setDraftFormButtonName,
                                                                            setDraftFormDescription,
                                                                            setDraftFormTitle,
                                                                            successFormStats,
                                                                            successUserForms,
                                                                        } from 'src/store/actions/user-forms.actions';
                                                                        import {logout, setUserData} from 'src/store/actions/user.actions';

                                                                        export type Actions =
                                                                            | ReturnType<typeof receiveAttributeByUsage>
                                                                            | ReturnType<typeof requestAttributeByUsage>
                                                                            | ReturnType<typeof errorAttributeByUsage>
                                                                            | ReturnType<typeof addNewAttribute>
                                                                            | ReturnType<typeof editAttribute>
                                                                            | ReturnType<typeof receiveFormByType>
                                                                            | ReturnType<typeof requestFormByType>
                                                                            | ReturnType<typeof errorFormByType>
                                                                            | ReturnType<typeof receiveSearch>
                                                                            | ReturnType<typeof requestSearch>
                                                                            | ReturnType<typeof errorSearch>
                                                                            | ReturnType<typeof receiveFullSearch>
                                                                            | ReturnType<typeof requestFullSearch>
                                                                            | ReturnType<typeof errorFullSearch>
                                                                            | ReturnType<typeof selectSearchType>
                                                                            | ReturnType<typeof setFilter>
                                                                            | ReturnType<typeof setUserData>
                                                                            | ReturnType<typeof logout>
                                                                            | ReturnType<typeof requestUserArchiveForms>
                                                                            | ReturnType<typeof errorUserArchiveForms>
                                                                            | ReturnType<typeof successUserArchiveForms>
                                                                            | ReturnType<typeof addArchiveForm>
                                                                            | ReturnType<typeof removeArchiveForm>
                                                                            | ReturnType<typeof errorArchiveForm>
                                                                            | ReturnType<typeof requestUserForms>
                                                                            | ReturnType<typeof errorUserForms>
                                                                            | ReturnType<typeof successUserForms>
                                                                            | ReturnType<typeof addNewUserForm>
                                                                            | ReturnType<typeof deleteNewUserForm>
                                                                            | ReturnType<typeof editUserForm>
                                                                            | ReturnType<typeof errorUserForm>
                                                                            | ReturnType<typeof changeUserFormMode>
                                                                            | ReturnType<typeof setDraftFormTitle>
                                                                            | ReturnType<typeof setDraftFormDescription>
                                                                            | ReturnType<typeof setDraftFormButtonName>
                                                                            | ReturnType<typeof addDraftFormAttributes>
                                                                            | ReturnType<typeof deleteDraftFormAttribute>
                                                                            | ReturnType<typeof addDraftFormAttributeProperties>
                                                                            | ReturnType<typeof receiveChats>
                                                                            | ReturnType<typeof errorChats>
                                                                            | ReturnType<typeof requestChats>
                                                                            | ReturnType<typeof receiveHistoryLogs>
                                                                            | ReturnType<typeof errorHistoryLogs>
                                                                            | ReturnType<typeof requestHistoryLogs>
                                                                            | ReturnType<typeof addChat>
                                                                            | ReturnType<typeof deleteChat>
                                                                            | ReturnType<typeof editChat>
                                                                            | ReturnType<typeof addChatUser>
                                                                            | ReturnType<typeof deleteChatUser>
                                                                            | ReturnType<typeof addHistoryLogs>
                                                                            | ReturnType<typeof requestFormStats>
                                                                            | ReturnType<typeof errorFormStats>
                                                                            | ReturnType<typeof successFormStats>;
                                                                        src / store / actions / attributes.actions.tsx;
                                                                        import {Attribute, Usage} from 'src/types';

                                                                        export const RECEIVE_ATTRIBUTES_BY_USAGE = 'RECEIVE_ATTRIBUTES_BY_USAGE' as const;
                                                                        export const REQUEST_ATTRIBUTES_BY_USAGE = 'REQUEST_ATTRIBUTES_BY_USAGE' as const;
                                                                        export const ERROR_ATTRIBUTES_BY_USAGE = 'ERROR_ATTRIBUTES_BY_USAGE' as const;
                                                                        export const ADD_NEW_ATTRIBUTE = 'ADD_NEW_ATTRIBUTE' as const;
                                                                        export const EDIT_ATTRIBUTE = 'EDIT_ATTRIBUTE' as const;

                                                                        // fix name ATTRIBUTES
                                                                        export const receiveAttributeByUsage = (usage: Usage,
                                                                                                                attributes: Attribute[]) => (
                                                                            {
                                                                                type: RECEIVE_ATTRIBUTES_BY_USAGE,
                                                                                payload: {
                                                                                    usage,
                                                                                    attributes,
                                                                                },
                                                                            }
                                                                        );
                                                                        export const requestAttributeByUsage = (usage: Usage) => (
                                                                            {
                                                                                type: REQUEST_ATTRIBUTES_BY_USAGE,
                                                                                payload: {
                                                                                    usage,
                                                                                },
                                                                            }
                                                                        );
                                                                        export const errorAttributeByUsage = (usage: Usage) => (
                                                                            {
                                                                                type: ERROR_ATTRIBUTES_BY_USAGE,
                                                                                payload: {
                                                                                    usage,
                                                                                },
                                                                            }
                                                                        );
                                                                        export const addNewAttribute = (usage: Usage, attribute: Attribute) => (
                                                                            {
                                                                                type: ADD_NEW_ATTRIBUTE,
                                                                                payload: {
                                                                                    usage,
                                                                                    attribute,
                                                                                },
                                                                            }
                                                                        );
                                                                        export const editAttribute = (usage: Usage, attribute: Attribute) => (
                                                                            {
                                                                                type: EDIT_ATTRIBUTE,
                                                                                payload: {
                                                                                    usage,
                                                                                    attribute,
                                                                                },
                                                                            }
                                                                        );
                                                                        src / store / actions / chats.actions.tsx;
                                                                        import {Chat, ChatState, HistoryLog} from 'src/store/reducers/chats.reducer';
                                                                        import {AttributesByUserRole, ProfileOrSearchItem} from 'src/types';

                                                                        export const RECEIVE_CHATS = 'RECEIVE_CHATS' as const;
                                                                        export const REQUEST_CHATS = 'REQUEST_CHATS' as const;
                                                                        export const ERROR_CHATS = 'ERROR_CHATS' as const;

                                                                        export const RECEIVE_HISTORY_LOG = 'RECEIVE_HISTORY_LOG' as const;
                                                                        export const REQUEST_HISTORY_LOG = 'REQUEST_HISTORY_LOG' as const;
                                                                        export const ERROR_HISTORY_LOG = 'ERROR_HISTORY_LOG' as const;

                                                                        export const ADD_CHAT = 'ADD_CHAT' as const;
                                                                        export const DELETE_CHAT = 'DELETE_CHAT' as const;
                                                                        export const EDIT_CHAT = 'EDIT_CHAT' as const;
                                                                        export const ADD_CHAT_USER = 'ADD_CHAT_USER' as const;
                                                                        export const DELETE_CHAT_USER = 'DELETE_CHAT_USER' as const;
                                                                        export const ADD_HISTORY_LOGS = 'ADD_HISTORY_LOGS' as const;

                                                                        export const receiveChats = (attributes: AttributesByUserRole,
                                                                                                     chats: Chat[]) => ({
                                                                            type: RECEIVE_CHATS,
                                                                            payload: {attributes, chats},
                                                                        });

                                                                        export const errorChats = () => ({
                                                                            type: ERROR_CHATS,
                                                                        });

                                                                        export const requestChats = () => ({
                                                                            type: REQUEST_CHATS,
                                                                        });

                                                                        export const receiveHistoryLogs = (chatIndex: number,
                                                                                                           historyLogs: HistoryLog[]) => ({
                                                                            type: RECEIVE_HISTORY_LOG,
                                                                            payload: {chatIndex, historyLogs},
                                                                        });

                                                                        export const errorHistoryLogs = (chatIndex: number) => ({
                                                                            type: ERROR_HISTORY_LOG,
                                                                            payload: chatIndex,
                                                                        });

                                                                        export const requestHistoryLogs = (chatIndex: number) => ({
                                                                            type: REQUEST_HISTORY_LOG,
                                                                            payload: chatIndex,
                                                                        });

                                                                        export const addChat = (chat: Chat) => ({
                                                                            type: ADD_CHAT,
                                                                            payload: chat,
                                                                        });

                                                                        export const deleteChat = (chatIndex: number) => ({
                                                                            type: DELETE_CHAT,
                                                                            payload: {chatIndex},
                                                                        });

                                                                        export const editChat = (chatIndex: number, newChat: Partial<ChatState>) => ({
                                                                            type: EDIT_CHAT,
                                                                            payload: {chatIndex, newChat},
                                                                        });
                                                                        export const addChatUser = (chatIndex: number,
                                                                                                    user: ProfileOrSearchItem) => ({
                                                                            type: ADD_CHAT_USER,
                                                                            payload: {chatIndex, user},
                                                                        });
                                                                        export const deleteChatUser = (chatIndex: number, userId: string) => ({
                                                                            type: DELETE_CHAT_USER,
                                                                            payload: {chatIndex, userId},
                                                                        });

                                                                        export const addHistoryLogs = (chatIndex: number,
                                                                                                       historyLogs: HistoryLog[]) => ({
                                                                            type: ADD_HISTORY_LOGS,
                                                                            payload: {chatIndex, historyLogs},
                                                                        });
                                                                        src / store / actions /
                                                                    default
                                                                        -forms.actions.tsx;
                                                                        import {Form, FormType} from 'src/types';

                                                                        export const RECEIVE_FORM_BY_TYPE = 'RECEIVE_FORM_BY_TYPE' as const;
                                                                        export const REQUEST_FORM_BY_TYPE = 'REQUEST_FORM_BY_TYPE' as const;
                                                                        export const ERROR_FORM_BY_TYPE = 'ERROR_FORM_BY_TYPE' as const;

                                                                        export const receiveFormByType = (type: FormType, form: Form) => ({
                                                                            type: RECEIVE_FORM_BY_TYPE,
                                                                            payload: {
                                                                                type,
                                                                                form,
                                                                            },
                                                                        });
                                                                        export const requestFormByType = (type: FormType) => ({
                                                                            type: REQUEST_FORM_BY_TYPE,
                                                                            payload: {
                                                                                type,
                                                                            },
                                                                        });
                                                                        export const errorFormByType = (type: FormType) => ({
                                                                            type: ERROR_FORM_BY_TYPE,
                                                                            payload: {
                                                                                type,
                                                                            },
                                                                        });
                                                                        src / store / actions / user.actions.tsx;
                                                                        import {TOKEN_PARAM_NAME} from 'src/api/api';
                                                                        import {UserData} from 'src/types';
                                                                        import {deleteCookie} from 'src/ui/utils/cookie';

                                                                        export const SET_USER_DATA = 'SET_USER_DATA' as const;
                                                                        export const LOGOUT = 'LOGOUT' as const;

                                                                        export const setUserData = (userData: UserData) => ({
                                                                            type: SET_USER_DATA,
                                                                            payload: userData,
                                                                        });
                                                                        export const logout = () => {
                                                                            deleteCookie(TOKEN_PARAM_NAME);
                                                                            document.location.replace(window.location.origin);
                                                                            return ({
                                                                                type: LOGOUT,
                                                                            });
                                                                        };
                                                                        src / store / reducers / user - forms.reducer.tsx;
                                                                        import {Actions} from 'src/store/actions/action-type';
                                                                        import {
                                                                            ARCHIVE_ADD_FORM,
                                                                            ARCHIVE_REMOVE_FORM,
                                                                        } from 'src/store/actions/user-archive-forms.actions';
                                                                        import {
                                                                            ADD_DRAFT_FORM_ATTRIBUTE_PROPERTIES,
                                                                            ADD_DRAFT_FORM_ATTRIBUTES,
                                                                            ADD_NEW_USER_FORM,
                                                                            CHANGE_USER_FORM_MODE,
                                                                            DELETE_DRAFT_FORM_ATTRIBUTE,
                                                                            DELETE_NEW_USER_FORM,
                                                                            EDIT_USER_FORM,
                                                                            ERROR_FORM_STATS,
                                                                            ERROR_USER_FORM,
                                                                            ERROR_USER_FORMS,
                                                                            REQUEST_FORM_STATS,
                                                                            REQUEST_USER_FORMS,
                                                                            SET_DRAFT_FORM_BUTTON_NAME,
                                                                            SET_DRAFT_FORM_DESCRIPTION,
                                                                            SET_DRAFT_FORM_TITLE,
                                                                            SUCCESS_FORM_STATS,
                                                                            SUCCESS_USER_FORMS,
                                                                        } from 'src/store/actions/user-forms.actions';
                                                                        import {AsyncStatus, Attribute, Form, FormMode, StateForm} from 'src/types';

                                                                        export type UserFormsState = {
                                                                            status: AsyncStatus,
                                                                            forms: StateForm[]
                                                                        };

                                                                        export const userForms = (
                                                                            state: UserFormsState = {
                                                                                status: AsyncStatus.Initial,
                                                                                forms: [],
                                                                            }, action: Actions,
                                                                        ) => {
                                                                            switch (action.type) {
                                                                                case REQUEST_USER_FORMS: {
                                                                                    return {
                                                                                        ...state,
                                                                                        status: AsyncStatus.Pending,
                                                                                    };
                                                                                }
                                                                                case ERROR_USER_FORMS: {
                                                                                    return {
                                                                                        ...state,
                                                                                        status: AsyncStatus.Error,
                                                                                    };
                                                                                }
                                                                                case SUCCESS_USER_FORMS: {
                                                                                    return {
                                                                                        ...state,
                                                                                        status: AsyncStatus.Success,
                                                                                        forms: action.payload,
                                                                                    };
                                                                                }
                                                                                case ADD_NEW_USER_FORM: {
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: [
                                                                                            ...state.forms,
                                                                                            action.payload,
                                                                                        ],
                                                                                    };
                                                                                }
                                                                                case EDIT_USER_FORM: {
                                                                                    const {formIndex, form} = action.payload;
                                                                                    const newForms = state.forms.map((old: Form,
                                                                                                                      index: number) => index === formIndex
                                                                                                                                        ? {...old, ...form}
                                                                                                                                        : old);
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                case DELETE_NEW_USER_FORM: {
                                                                                    const formIndex = action.payload;
                                                                                    state.forms.splice(formIndex, 1);
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: [...state.forms],
                                                                                    };
                                                                                }
                                                                                case ERROR_USER_FORM: {
                                                                                    const {formIndex, errors} = action.payload;
                                                                                    const newForms = state.forms.map((old: StateForm,
                                                                                                                      index: number) => index === formIndex
                                                                                                                                        ? {
                                                                                            ...old,
                                                                                            errors,
                                                                                        }
                                                                                                                                        : old);
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                case CHANGE_USER_FORM_MODE: {
                                                                                    const {formIndex, mode} = action.payload;
                                                                                    const newForms = state.forms.map((old: Form, index: number) => {
                                                                                        if (mode === FormMode.Edit) {
                                                                                            return index === formIndex
                                                                                                   ? {...old, mode, backup: old}
                                                                                                   : old;
                                                                                        } else {
                                                                                            return index === formIndex
                                                                                                   ? {...old, mode, backup: undefined}
                                                                                                   : old;
                                                                                        }
                                                                                    });
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }

                                                                                case SET_DRAFT_FORM_TITLE: {
                                                                                    const {formIndex, title} = action.payload;
                                                                                    const newForms = state.forms.map((old: Form,
                                                                                                                      index: number) => index === formIndex
                                                                                                                                        ? {
                                                                                            ...old,
                                                                                            title,
                                                                                        }
                                                                                                                                        : old);
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                case SET_DRAFT_FORM_DESCRIPTION: {
                                                                                    const {formIndex, description} = action.payload;
                                                                                    const newForms = state.forms.map((old: Form,
                                                                                                                      index: number) => index === formIndex
                                                                                                                                        ? {
                                                                                            ...old,
                                                                                            description,
                                                                                        }
                                                                                                                                        : old);
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                case SET_DRAFT_FORM_BUTTON_NAME: {
                                                                                    const {formIndex, buttonName} = action.payload;
                                                                                    const newForms = state.forms.map((old: Form,
                                                                                                                      index: number) => index === formIndex
                                                                                                                                        ? {
                                                                                            ...old,
                                                                                            buttonName,
                                                                                        }
                                                                                                                                        : old);
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                case ADD_DRAFT_FORM_ATTRIBUTES: {
                                                                                    const {formIndex, attributes} = action.payload;
                                                                                    const oldAttributes = 'attributes' in state.forms[formIndex]
                                                                                                          ? state.forms[formIndex].attributes
                                                                                                          : [];

                                                                                    const newForms = state.forms.map((old: Form, index: number) => (
                                                                                                                                                       index === formIndex
                                                                                                                                                   )
                                                                                                                                                   ? {
                                                                                            ...old, attributes: [
                                                                                                ...oldAttributes,
                                                                                                ...attributes,
                                                                                            ],
                                                                                        }
                                                                                                                                                   : old,
                                                                                    );
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                case DELETE_DRAFT_FORM_ATTRIBUTE: {
                                                                                    const {formIndex, attributeIndex} = action.payload;
                                                                                    const oldAttributes = 'attributes' in state.forms[formIndex]
                                                                                                          ? state.forms[formIndex].attributes
                                                                                                          : [];

                                                                                    const newAttributes = oldAttributes.filter((oldAttribute: Attribute,
                                                                                                                                index: number) => index !== attributeIndex);
                                                                                    const newForms = state.forms.map((old: Form, index: number) => (
                                                                                                                                                       index === formIndex
                                                                                                                                                   )
                                                                                                                                                   ? {
                                                                                            ...old,
                                                                                            attributes: newAttributes,
                                                                                        }
                                                                                                                                                   : old,
                                                                                    );
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                case ADD_DRAFT_FORM_ATTRIBUTE_PROPERTIES: {
                                                                                    const {formIndex, attributeIndex, attribute} = action.payload;
                                                                                    const oldAttributes = 'attributes' in state.forms[formIndex]
                                                                                                          ? state.forms[formIndex].attributes
                                                                                                          : [];

                                                                                    const newAttributes = oldAttributes.map((oldAttribute: Attribute,
                                                                                                                             index: number) => index === attributeIndex
                                                                                                                                               ? {...oldAttribute, ...attribute}
                                                                                                                                               : oldAttribute);
                                                                                    const newForms = state.forms.map((old: Form, index: number) => (
                                                                                                                                                       index === formIndex
                                                                                                                                                   )
                                                                                                                                                   ? {
                                                                                            ...old,
                                                                                            attributes: newAttributes,
                                                                                        }
                                                                                                                                                   : old,
                                                                                    );
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }

                                                                                case ARCHIVE_REMOVE_FORM: {
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: [
                                                                                            ...state.forms,
                                                                                            action.payload.form,
                                                                                        ],
                                                                                    };
                                                                                }

                                                                                case ARCHIVE_ADD_FORM: {
                                                                                    const {formIndex} = action.payload;
                                                                                    const newForms = state.forms.filter((old: Form,
                                                                                                                         index: number) => index !== formIndex,
                                                                                    );
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }

                                                                                case REQUEST_FORM_STATS: {
                                                                                    const formIndex = action.payload;
                                                                                    const newForms = state.forms.map((old: Form,
                                                                                                                      index: number) => index === formIndex
                                                                                                                                        ? {
                                                                                            ...old,
                                                                                            stats: {status: AsyncStatus.Pending, records: []},
                                                                                        }
                                                                                                                                        : old);
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                case ERROR_FORM_STATS: {
                                                                                    const formIndex = action.payload;
                                                                                    const newForms = state.forms.map((old: Form,
                                                                                                                      index: number) => index === formIndex
                                                                                                                                        ? {
                                                                                            ...old,
                                                                                            stats: {status: AsyncStatus.Error, records: []},
                                                                                        }
                                                                                                                                        : old);
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                case SUCCESS_FORM_STATS: {
                                                                                    const {formIndex, records} = action.payload;
                                                                                    const newForms = state.forms.map((old: Form,
                                                                                                                      index: number) => index === formIndex
                                                                                                                                        ? {
                                                                                            ...old,
                                                                                            stats: {status: AsyncStatus.Success, records},
                                                                                        }
                                                                                                                                        : old);
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }

                                                                                default: {
                                                                                    return state;
                                                                                }
                                                                            }
                                                                        };
                                                                        src / store / reducers / user - archive - forms.reducer.tsx;
                                                                        import {Actions} from 'src/store/actions/action-type';
                                                                        import {
                                                                            ARCHIVE_ADD_FORM,
                                                                            ARCHIVE_REMOVE_FORM,
                                                                            ERROR_USER_ARCHIVE_FORM,
                                                                            ERROR_USER_ARCHIVE_FORMS,
                                                                            REQUEST_USER_ARCHIVE_FORMS,
                                                                            SUCCESS_USER_ARCHIVE_FORMS,
                                                                        } from 'src/store/actions/user-archive-forms.actions';
                                                                        import {UserFormsState} from 'src/store/reducers/user-forms.reducer';
                                                                        import {AsyncStatus, Form} from 'src/types';

                                                                        export const userArchiveForms = (
                                                                            state: UserFormsState = {
                                                                                status: AsyncStatus.Initial,
                                                                                forms: [],
                                                                            }, action: Actions,
                                                                        ) => {
                                                                            switch (action.type) {
                                                                                case REQUEST_USER_ARCHIVE_FORMS: {
                                                                                    return {
                                                                                        ...state,
                                                                                        status: AsyncStatus.Pending,
                                                                                    };
                                                                                }
                                                                                case ERROR_USER_ARCHIVE_FORMS: {
                                                                                    return {
                                                                                        ...state,
                                                                                        status: AsyncStatus.Error,
                                                                                    };
                                                                                }
                                                                                case SUCCESS_USER_ARCHIVE_FORMS: {
                                                                                    return {
                                                                                        ...state,
                                                                                        status: AsyncStatus.Success,
                                                                                        forms: action.payload,
                                                                                    };
                                                                                }
                                                                                case ARCHIVE_ADD_FORM: {
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: [
                                                                                            ...state.forms,
                                                                                            action.payload.form,
                                                                                        ],
                                                                                    };
                                                                                }

                                                                                case ARCHIVE_REMOVE_FORM: {
                                                                                    const {formIndex} = action.payload;
                                                                                    const newForms = state.forms.filter((old: Form,
                                                                                                                         index: number) => index !== formIndex,
                                                                                    );
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                case ERROR_USER_ARCHIVE_FORM: {
                                                                                    const {formIndex, errors} = action.payload;
                                                                                    const newForms = state.forms.map((old: Form,
                                                                                                                      index: number) => index === formIndex
                                                                                                                                        ? {
                                                                                            ...old,
                                                                                            errors,
                                                                                        }
                                                                                                                                        : old);
                                                                                    return {
                                                                                        ...state,
                                                                                        forms: newForms,
                                                                                    };
                                                                                }
                                                                                default: {
                                                                                    return state;
                                                                                }
                                                                            }
                                                                        };
                                                                        src / store / reducers / search.reducer.tsx;
                                                                        import {Actions} from 'src/store/actions/action-type';
                                                                        import {
                                                                            ERROR_FULL_SEARCH,
                                                                            ERROR_SEARCH,
                                                                            RECEIVE_FULL_SEARCH,
                                                                            RECEIVE_SEARCH,
                                                                            REQUEST_FULL_SEARCH,
                                                                            REQUEST_SEARCH,
                                                                            SELECT_SEARCH_TYPE,
                                                                            SET_FILTER,
                                                                        } from 'src/store/actions/search.actions';
                                                                        import {
                                                                            AsyncStatus,
                                                                            Attribute,
                                                                            ProfileOrSearchItem,
                                                                            SearchType,
                                                                        } from 'src/types';

                                                                        export type SearchState = {
                                                                            searchFilterStatus: AsyncStatus;
                                                                            searchStatus: AsyncStatus;
                                                                            searchType: SearchType;
                                                                            records: ProfileOrSearchItem[];
                                                                            fields: Attribute[];
                                                                        }

                                                                        export const search = (
                                                                            state: SearchState = {
                                                                                searchFilterStatus: AsyncStatus.Initial,
                                                                                searchStatus: AsyncStatus.Initial,
                                                                                searchType: SearchType.Initial,
                                                                                records: [],
                                                                                fields: [],
                                                                            }, action: Actions,
                                                                        ) => {
                                                                            switch (action.type) {
                                                                                case RECEIVE_FULL_SEARCH: {
                                                                                    const {schema, records} = action.payload;
                                                                                    const newRecords = records.map((item: ProfileOrSearchItem) => {
                                                                                        try {
                                                                                            return ({
                                                                                                ...item,
                                                                                                content: JSON.parse(item.schemaContent),
                                                                                            });
                                                                                        } catch (e) {
                                                                                            return {...item, content: {}};
                                                                                        }
                                                                                    });
                                                                                    return {
                                                                                        ...state,
                                                                                        searchFilterStatus: AsyncStatus.Success,
                                                                                        searchStatus: AsyncStatus.Success,
                                                                                        records: newRecords,
                                                                                        fields: schema.attributes,
                                                                                    };
                                                                                }
                                                                                case REQUEST_FULL_SEARCH: {
                                                                                    return {
                                                                                        ...state,
                                                                                        searchStatus: AsyncStatus.Pending,
                                                                                        records: [],
                                                                                        fields: [],
                                                                                    };
                                                                                }
                                                                                case ERROR_FULL_SEARCH: {
                                                                                    return {
                                                                                        ...state,
                                                                                        searchStatus: AsyncStatus.Error,
                                                                                        records: [],
                                                                                        fields: [],
                                                                                    };
                                                                                }

                                                                                case RECEIVE_SEARCH: {
                                                                                    const {records} = action.payload;
                                                                                    const newRecords = records.map((item: ProfileOrSearchItem) => {
                                                                                        try {
                                                                                            return ({
                                                                                                ...item,
                                                                                                content: JSON.parse(item.schemaContent),
                                                                                            });
                                                                                        } catch (e) {
                                                                                            return {...item, content: {}};
                                                                                        }
                                                                                    });
                                                                                    return {
                                                                                        ...state,
                                                                                        searchStatus: AsyncStatus.Success,
                                                                                        records: newRecords,
                                                                                    };
                                                                                }
                                                                                case REQUEST_SEARCH: {
                                                                                    return {
                                                                                        ...state,
                                                                                        searchStatus: AsyncStatus.Pending,
                                                                                        records: [],
                                                                                    };
                                                                                }
                                                                                case ERROR_SEARCH: {
                                                                                    return {
                                                                                        ...state,
                                                                                        searchStatus: AsyncStatus.Error,
                                                                                        records: [],
                                                                                    };
                                                                                }

                                                                                case SELECT_SEARCH_TYPE: {
                                                                                    return {
                                                                                        ...state,
                                                                                        searchType: action.payload,
                                                                                    };
                                                                                }
                                                                                case SET_FILTER: {
                                                                                    return {
                                                                                        ...state,
                                                                                        fields: action.payload,
                                                                                    };
                                                                                }

                                                                                default: {
                                                                                    return state;
                                                                                }
                                                                            }
                                                                        };
                                                                        src / store / reducers /
                                                                    default
                                                                        -forms.reducer.tsx;
                                                                        import {Actions} from 'src/store/actions/action-type';
                                                                        import {
                                                                            ERROR_FORM_BY_TYPE,
                                                                            RECEIVE_FORM_BY_TYPE,
                                                                            REQUEST_FORM_BY_TYPE,
                                                                        } from 'src/store/actions/default-forms.actions';
                                                                        import {AsyncStatus, Form, FormType, Usage} from 'src/types';

                                                                        export type DefaultFormsState = { [k in FormType]?: { status: AsyncStatus; form: Form } };
                                                                        export const defaultForms = (
                                                                            state: DefaultFormsState = {}, action: Actions,
                                                                        ) => {
                                                                            switch (action.type) {
                                                                                case RECEIVE_FORM_BY_TYPE: {
                                                                                    const {type, form} = action.payload;
                                                                                    if (type === FormType.ProjectRequest) {
                                                                                        form.attributes = form.attributes.filter(({usage}) => usage !== Usage.Activity);
                                                                                    }
                                                                                    return {
                                                                                        ...state,
                                                                                        [type]: {
                                                                                            form,
                                                                                            status: AsyncStatus.Success,
                                                                                        },
                                                                                    };
                                                                                }
                                                                                case REQUEST_FORM_BY_TYPE: {
                                                                                    const {type} = action.payload;
                                                                                    return {
                                                                                        ...state,
                                                                                        [type]: {
                                                                                            status: AsyncStatus.Pending,
                                                                                        },
                                                                                    };
                                                                                }
                                                                                case ERROR_FORM_BY_TYPE: {
                                                                                    const {type} = action.payload;
                                                                                    return {
                                                                                        ...state,
                                                                                        [type]: {
                                                                                            status: AsyncStatus.Error,
                                                                                        },
                                                                                    };
                                                                                }
                                                                                default: {
                                                                                    return state;
                                                                                }
                                                                            }
                                                                        };
                                                                        src / store / reducers / index.ts;
                                                                        import {combineReducers} from 'redux';
                                                                        import {Actions} from 'src/store/actions/action-type';
                                                                        import {chats, ChatsState} from 'src/store/reducers/chats.reducer';
                                                                        import {attributes, AttributesState} from './attributes.reducer';
                                                                        import {defaultForms, DefaultFormsState} from './default-forms.reducer';
                                                                        import {search, SearchState} from './search.reducer';
                                                                        import {userArchiveForms} from './user-archive-forms.reducer';
                                                                        import {userForms, UserFormsState} from './user-forms.reducer';
                                                                        import {user, UserState} from './user.reducer';

                                                                        export type State = {
                                                                            attributes: AttributesState;
                                                                            user: UserState,
                                                                            chats: ChatsState,
                                                                            search: SearchState,
                                                                            userForms: UserFormsState,
                                                                            defaultForms: DefaultFormsState,
                                                                            userArchiveForms: UserFormsState,
                                                                        };

                                                                        export const rootReducer = combineReducers<State, Actions>({
                                                                                                                                       attributes,
                                                                                                                                       user,
                                                                                                                                       chats,
                                                                                                                                       search,
                                                                                                                                       userForms,
                                                                                                                                       defaultForms,
                                                                                                                                       userArchiveForms,
                                                                                                                                   });
                                                                        src / store / reducers / attributes.reducer.tsx;
                                                                        import {Reducer} from 'redux';
                                                                        import {Actions} from 'src/store/actions/action-type';
                                                                        import {
                                                                            ADD_NEW_ATTRIBUTE,
                                                                            EDIT_ATTRIBUTE,
                                                                            ERROR_ATTRIBUTES_BY_USAGE,
                                                                            RECEIVE_ATTRIBUTES_BY_USAGE,
                                                                            REQUEST_ATTRIBUTES_BY_USAGE,
                                                                        } from 'src/store/actions/attributes.actions';
                                                                        import {AsyncStatus, Attribute, Usage} from 'src/types';

                                                                        export type AttributesState = { [k in Usage]?: { status: AsyncStatus; attributes: Attribute[] } };
                                                                        export const attributes: Reducer<AttributesState, Actions> = (
                                                                            state: AttributesState = {}, action: Actions,
                                                                        ) => {
                                                                            switch (action.type) {
                                                                                case ADD_NEW_ATTRIBUTE: {
                                                                                    const {usage, attribute} = action.payload;
                                                                                    const currentState = state[usage];
                                                                                    const prevAttributes = currentState
                                                                                                           ? currentState.attributes
                                                                                                           : [];
                                                                                    const status = currentState ? currentState.status : [];
                                                                                    return {
                                                                                        ...state,
                                                                                        [usage]: {
                                                                                            attributes: [
                                                                                                ...prevAttributes,
                                                                                                attribute,
                                                                                            ],
                                                                                            status,
                                                                                        },
                                                                                    };
                                                                                }
                                                                                case EDIT_ATTRIBUTE: {
                                                                                    const {usage, attribute} = action.payload;

                                                                                    const currentState = state[usage];
                                                                                    const prevAttributes = currentState
                                                                                                           ? currentState.attributes
                                                                                                           : [];
                                                                                    const status = currentState ? currentState.status : [];

                                                                                    return {
                                                                                        ...state,
                                                                                        [usage]: {
                                                                                            attributes: prevAttributes.map((attr: Attribute) => (attr.id === attribute.id)
                                                                                                                                                ? attribute
                                                                                                                                                : attr),
                                                                                            status,
                                                                                        },
                                                                                    };
                                                                                }
                                                                                case RECEIVE_ATTRIBUTES_BY_USAGE: {
                                                                                    const {usage, attributes} = action.payload;
                                                                                    return {
                                                                                        ...state,
                                                                                        [usage]: {
                                                                                            attributes,
                                                                                            status: AsyncStatus.Success,
                                                                                        },
                                                                                    };
                                                                                }
                                                                                case REQUEST_ATTRIBUTES_BY_USAGE: {
                                                                                    const {usage} = action.payload;
                                                                                    return {
                                                                                        ...state,
                                                                                        [usage]: {
                                                                                            status: AsyncStatus.Pending,
                                                                                        },
                                                                                    };
                                                                                }
                                                                                case ERROR_ATTRIBUTES_BY_USAGE: {
                                                                                    const {usage} = action.payload;
                                                                                    return {
                                                                                        ...state,
                                                                                        [usage]: {
                                                                                            status: AsyncStatus.Error,
                                                                                        },
                                                                                    };
                                                                                }
                                                                                default: {
                                                                                    return state;
                                                                                }
                                                                            }
                                                                        };
                                                                        src / store / reducers / chats.reducer.tsx;
                                                                        import {Reducer} from 'redux';
                                                                        import {Actions} from 'src/store/actions/action-type';
                                                                        import {
                                                                            ADD_CHAT,
                                                                            ADD_CHAT_USER,
                                                                            ADD_HISTORY_LOGS,
                                                                            DELETE_CHAT,
                                                                            DELETE_CHAT_USER,
                                                                            EDIT_CHAT,
                                                                            ERROR_CHATS,
                                                                            ERROR_HISTORY_LOG,
                                                                            RECEIVE_CHATS,
                                                                            RECEIVE_HISTORY_LOG,
                                                                            REQUEST_CHATS,
                                                                            REQUEST_HISTORY_LOG,
                                                                        } from 'src/store/actions/chats.actions';
                                                                        import {
                                                                            AsyncStatus,
                                                                            AttributesByUserRole,
                                                                            ProfileOrSearchItem,
                                                                        } from 'src/types';

                                                                        export type HistoryLog = {
                                                                            id: string;
                                                                            date: string;
                                                                            title: string;
                                                                            name?: string;
                                                                            link?: string;
                                                                        }

                                                                        export type Chat = {
                                                                            id: string;
                                                                            name: string;
                                                                            users: ProfileOrSearchItem[];
                                                                        }

                                                                        export type ChatState = Chat & {
                                                                            isEditing?: boolean;
                                                                            backup?: ChatState;
                                                                            history?: {
                                                                                status: AsyncStatus;
                                                                                logs: HistoryLog[]
                                                                            }
                                                                        }

                                                                        export type ChatsState =
                                                                            { status: AsyncStatus.Initial | AsyncStatus.Pending | AsyncStatus.Error; chats: ChatState[]; attributes: {} }
                                                                            | { status: AsyncStatus.Success; chats: ChatState[]; attributes: AttributesByUserRole }

                                                                        export const chats: Reducer<ChatsState, Actions> = (
                                                                            state: ChatsState = {
                                                                                status: AsyncStatus.Initial,
                                                                                chats: [],
                                                                                attributes: {},
                                                                            }, action: Actions,
                                                                        ) => {
                                                                            switch (action.type) {
                                                                                case RECEIVE_CHATS: {
                                                                                    const {attributes, chats} = action.payload;
                                                                                    return {
                                                                                        status: AsyncStatus.Success,
                                                                                        chats,
                                                                                        attributes,
                                                                                    };
                                                                                }
                                                                                case REQUEST_CHATS: {
                                                                                    return {
                                                                                        status: AsyncStatus.Pending,
                                                                                        chats: [],
                                                                                        attributes: {},
                                                                                    };
                                                                                }
                                                                                case ERROR_CHATS: {
                                                                                    return {
                                                                                        status: AsyncStatus.Error,
                                                                                        chats: [],
                                                                                        attributes: {},
                                                                                    };
                                                                                }
                                                                                case RECEIVE_HISTORY_LOG: {
                                                                                    if (!('chats' in state)) {
                                                                                        return state;
                                                                                    }
                                                                                    const {chatIndex, historyLogs} = action.payload;
                                                                                    const newChats = state.chats.map((chat: ChatState,
                                                                                                                      index: number) => (chatIndex === index)
                                                                                                                                        ? {
                                                                                            ...chat,
                                                                                            history: {status: AsyncStatus.Success, logs: historyLogs},
                                                                                        }
                                                                                                                                        : chat);

                                                                                    return {
                                                                                        ...state,
                                                                                        chats: newChats,
                                                                                    };

                                                                                }
                                                                                case ERROR_HISTORY_LOG: {
                                                                                    if (!('chats' in state)) {
                                                                                        return state;
                                                                                    }
                                                                                    const chatIndex = action.payload;
                                                                                    const newChats = state.chats.map((chat: ChatState,
                                                                                                                      index: number) => (chatIndex === index)
                                                                                                                                        ? {
                                                                                            ...chat,
                                                                                            history: {status: AsyncStatus.Error},
                                                                                        }
                                                                                                                                        : chat);

                                                                                    return {
                                                                                        ...state,
                                                                                        chats: newChats,
                                                                                    };
                                                                                }
                                                                                case REQUEST_HISTORY_LOG: {
                                                                                    if (!('chats' in state)) {
                                                                                        return state;
                                                                                    }
                                                                                    const chatIndex = action.payload;
                                                                                    const newChats = state.chats.map((chat: ChatState,
                                                                                                                      index: number) => (chatIndex === index)
                                                                                                                                        ? {
                                                                                            ...chat,
                                                                                            history: {status: AsyncStatus.Pending},
                                                                                        }
                                                                                                                                        : chat);

                                                                                    return {
                                                                                        ...state,
                                                                                        chats: newChats,
                                                                                    };
                                                                                }
                                                                                case ADD_CHAT: {
                                                                                    if (!('chats' in state)) {
                                                                                        return state;
                                                                                    }
                                                                                    const chat = action.payload;

                                                                                    return {
                                                                                        ...state,
                                                                                        chats: [...state.chats, chat],
                                                                                    };
                                                                                }
                                                                                case DELETE_CHAT: {
                                                                                    if (!('chats' in state)) {
                                                                                        return state;
                                                                                    }
                                                                                    const {chatIndex} = action.payload;
                                                                                    return {
                                                                                        ...state,
                                                                                        chats: state.chats.filter((chat,
                                                                                                                   index) => index !== chatIndex),
                                                                                    };
                                                                                }
                                                                                case EDIT_CHAT: {
                                                                                    if (!('chats' in state)) {
                                                                                        return state;
                                                                                    }
                                                                                    const {chatIndex, newChat} = action.payload;
                                                                                    const newChats = state.chats.map((chat: ChatState,
                                                                                                                      index: number) => (chatIndex === index)
                                                                                                                                        ? {
                                                                                            ...chat,
                                                                                            ...newChat,
                                                                                            backup: newChat.isEditing ? chat : chat.backup,
                                                                                        }
                                                                                                                                        : chat);

                                                                                    return {
                                                                                        ...state,
                                                                                        chats: newChats,
                                                                                    };
                                                                                }
                                                                                case ADD_CHAT_USER: {
                                                                                    if (!('chats' in state)) {
                                                                                        return state;
                                                                                    }
                                                                                    const {chatIndex, user} = action.payload;
                                                                                    const newChats = state.chats.map((chat: ChatState,
                                                                                                                      index: number) => {
                                                                                                                         if (chatIndex === index) {
                                                                                                                             return {
                                                                                                                                 ...chat,
                                                                                                                                 users: [...chat.users, user],
                                                                                                                             };
                                                                                                                         }
                                                                                                                         return chat;
                                                                                                                     },
                                                                                    );

                                                                                    return {
                                                                                        ...state,
                                                                                        chats: newChats,
                                                                                    };
                                                                                }
                                                                                case DELETE_CHAT_USER: {
                                                                                    if (!('chats' in state)) {
                                                                                        return state;
                                                                                    }
                                                                                    const {chatIndex, userId} = action.payload;
                                                                                    const newChats = state.chats.map((chat: ChatState,
                                                                                                                      index: number) => {
                                                                                                                         if (chatIndex === index) {
                                                                                                                             return {
                                                                                                                                 ...chat,
                                                                                                                                 users: chat.users.filter(({id}) => id !== userId),
                                                                                                                             };
                                                                                                                         }
                                                                                                                         return chat;
                                                                                                                     },
                                                                                    );

                                                                                    return {
                                                                                        ...state,
                                                                                        chats: newChats,
                                                                                    };
                                                                                }
                                                                                case ADD_HISTORY_LOGS: {
                                                                                    if (!('chats' in state)) {
                                                                                        return state;
                                                                                    }
                                                                                    const {chatIndex, historyLogs} = action.payload;
                                                                                    const newChats = state.chats.map((chat: ChatState,
                                                                                                                      index: number) => (chatIndex === index)
                                                                                                                                        ? {
                                                                                            ...chat,
                                                                                            history: {
                                                                                                ...chat.history,
                                                                                                logs: [...(chat.history?.logs || []), ...historyLogs],
                                                                                            },
                                                                                        }
                                                                                                                                        : chat);

                                                                                    return {
                                                                                        ...state,
                                                                                        chats: newChats,
                                                                                    };
                                                                                }
                                                                                default: {
                                                                                    return state;
                                                                                }
                                                                            }
                                                                        };
                                                                        src / store / reducers / user.reducer.tsx;
                                                                        import {Reducer} from 'redux';
                                                                        import {Actions} from 'src/store/actions/action-type';
                                                                        import {LOGOUT, SET_USER_DATA} from 'src/store/actions/user.actions';
                                                                        import {UserData} from 'src/types';

                                                                        export type UserState = {
                                                                                                    isAuthed: false;
                                                                                                } | ({ isAuthed: true; } & UserData)

                                                                        export const user: Reducer<UserState, Actions> = (
                                                                            state: UserState = {
                                                                                isAuthed: false,
                                                                            }, action: Actions,
                                                                        ) => {
                                                                            switch (action.type) {
                                                                                case SET_USER_DATA: {
                                                                                    return {
                                                                                        isAuthed: true,
                                                                                        ...action.payload,
                                                                                    };
                                                                                }
                                                                                case LOGOUT: {
                                                                                    return {
                                                                                        isAuthed: false,
                                                                                    };
                                                                                }
                                                                                default: {
                                                                                    return state;
                                                                                }
                                                                            }
                                                                        };;;;;;;;;;;;;;
